From 863f395485a705e13a7ba3c49b650f719d3be12a Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Wed, 7 Mar 2018 14:14:18 +0100
Subject: [PATCH 01/33] disable debug package gen

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 5c8c02ffd864..31148aa2e935 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -168,7 +168,7 @@ CONFIG_NFSD_V4=y
 CONFIG_NLS_CODEPAGE_437=y
 CONFIG_NLS_ISO8859_1=y
 CONFIG_PRINTK_TIME=y
-CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO=n
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_DETECT_HUNG_TASK=y
 # CONFIG_SCHED_DEBUG is not set
-- 
2.17.1


From 9d651948c4bad162eac64a6ecf5b4691dfb989cc Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Tue, 1 May 2018 16:02:19 +0200
Subject: [PATCH 02/33] Remove gittag from kernel (file) name(s)

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 31148aa2e935..d5758c68e455 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -1,3 +1,4 @@
+CONFIG_LOCALVERSION_AUTO=n
 CONFIG_SYSVIPC=y
 CONFIG_HIGH_RES_TIMERS=y
 CONFIG_IKCONFIG=y
-- 
2.17.1


From 8b24dee1205097ffbd1443780a8fd8bc0fc12949 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Wed, 7 Mar 2018 14:21:56 +0100
Subject: [PATCH 03/33] add ext4 root fs support and autofs4 module

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index d5758c68e455..5ac78d2ef09e 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -13,7 +13,7 @@ CONFIG_PROFILING=y
 CONFIG_OPROFILE=y
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
-# CONFIG_LBDAF is not set
+CONFIG_LBDAF=y
 # CONFIG_BLK_DEV_BSG is not set
 # CONFIG_IOSCHED_DEADLINE is not set
 # CONFIG_IOSCHED_CFQ is not set
@@ -153,7 +153,10 @@ CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 CONFIG_EXT3_FS=y
-CONFIG_AUTOFS4_FS=y
+CONFIG_EXT4_FS=y
+# CONFIG_AUTOFS4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
 CONFIG_VFAT_FS=y
 CONFIG_NTFS_FS=y
 CONFIG_NTFS_RW=y
-- 
2.17.1


From b81286a31d17e30d8a6af70da23b8c7787bc6170 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Wed, 7 Mar 2018 14:26:50 +0100
Subject: [PATCH 04/33] add .dtd files to kernel-image .deb

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 scripts/package/builddeb | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/scripts/package/builddeb b/scripts/package/builddeb
index 3c575cd07888..d67c791ddc2d 100755
--- a/scripts/package/builddeb
+++ b/scripts/package/builddeb
@@ -128,7 +128,7 @@ BUILD_DEBUG="$(grep -s '^CONFIG_DEBUG_INFO=y' $KCONFIG_CONFIG || true)"
 # Setup the directory structure
 rm -rf "$tmpdir" "$fwdir" "$kernel_headers_dir" "$libc_headers_dir" "$dbg_dir" $objtree/debian/files
 mkdir -m 755 -p "$tmpdir/DEBIAN"
-mkdir -p "$tmpdir/lib" "$tmpdir/boot"
+mkdir -p "$tmpdir/lib" "$tmpdir/boot/dtb"
 mkdir -p "$fwdir/lib/firmware/$version/"
 mkdir -p "$kernel_headers_dir/lib/modules/$version/"
 
@@ -146,8 +146,10 @@ fi
 # Not all arches include the boot path in KBUILD_IMAGE
 if [ -e $KBUILD_IMAGE ]; then
 	cp $KBUILD_IMAGE "$tmpdir/$installed_image_path"
+	cp dts/*.dtb "$tmpdir/boot/dtb"
 else
 	cp arch/$ARCH/boot/$KBUILD_IMAGE "$tmpdir/$installed_image_path"
+	cp arch/$ARCH/boot/dts/*.dtb "$tmpdir/boot/dtb"
 fi
 
 if grep -q "^CONFIG_OF=y" $KCONFIG_CONFIG ; then
-- 
2.17.1


From f2eb467110902e85f4f8a7aa50946bdb38e463db Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Wed, 7 Mar 2018 14:33:44 +0100
Subject: [PATCH 05/33] add generate /boot/extlinux/extlinux.conf and
 /boot/uEnv.txt for uboot boot info

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 scripts/package/builddeb | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/scripts/package/builddeb b/scripts/package/builddeb
index d67c791ddc2d..d6a4058377f4 100755
--- a/scripts/package/builddeb
+++ b/scripts/package/builddeb
@@ -203,6 +203,27 @@ if grep -q '^CONFIG_BLK_DEV_INITRD=y' $KCONFIG_CONFIG; then
 else
 	want_initrd=No
 fi
+# create uEnv.txt containing current kernelversio in /boot folder (for u-boot probing)
+cat <<EOF > "$tmpdir/boot/uEnv.txt"
+kver=${version}
+initrd_installed=$want_initrd
+hostname=holosynthv
+EOF
+cat <<'EOF' >> "$tmpdir/boot/uEnv.txt"
+fpgaload=mmc rescan;load mmc ${bootpart} ${loadaddr} ${bitimage}; fpga load 0 ${loadaddr} ${filesize}
+loadimage=run fpgaload; bridge enable; mw.b 0xffd05018 0xf0; load mmc ${bootpart} ${loadaddr} ${bootimage}; load mmc ${bootpart} ${fdt_addr} ${fdtimage}
+mmcboot=setenv bootargs console=ttyS0,115200 root=${mmcroot} rootfstype=ext4 rw rootwait fbcon=rotate:2;bootz ${loadaddr} - ${fdt_addr}
+EOF
+
+# create extlinux.conf in /boot folder (for u-boot probing)
+mkdir -p "$tmpdir/boot/extlinux"
+cat <<EOF > "$tmpdir/boot/extlinux/extlinux.conf"
+label Linux ${version}
+    kernel /boot/vmlinuz-$version
+    append  console=ttyS0,115200 root=/dev/mmcblk0p3 rw rootfstype=ext4 rootwait
+    fdtdir /boot/dtb
+EOF
+
 for script in postinst postrm preinst prerm ; do
 	mkdir -p "$tmpdir$debhookdir/$script.d"
 	cat <<EOF > "$tmpdir/DEBIAN/$script"
-- 
2.17.1


From 7cc8a9c6441367bbfe4d367b6d5a5d5c2a1e2b25 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Wed, 7 Mar 2018 15:43:11 +0100
Subject: [PATCH 06/33] add configfs and fpgacfg dts entities, and dynamic dts
 overlay support

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 5ac78d2ef09e..44eb99105dcd 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -62,8 +62,6 @@ CONFIG_MTD_NAND_DENALI_DT=y
 CONFIG_MTD_SPI_NOR=y
 # CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
 CONFIG_SPI_CADENCE_QUADSPI=y
-CONFIG_OF_OVERLAY=y
-CONFIG_OF_CONFIGFS=y
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_COUNT=2
 CONFIG_BLK_DEV_RAM_SIZE=8192
@@ -149,6 +147,11 @@ CONFIG_FPGA_BRIDGE=y
 CONFIG_SOCFPGA_FPGA_BRIDGE=y
 CONFIG_ALTERA_FREEZE_BRIDGE=y
 CONFIG_ALTERA_FREEZE_BRIDGE_PLAT=y
+CONFIG_UIO=m
+CONFIG_UIO_PDRV_GENIRQ=m
+CONFIG_OF_OVERLAY=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_OF_CONFIGFS=y
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
-- 
2.17.1


From cb14e913b3af5a3f41fc5337c3d4ea8b44faf496 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sat, 10 Mar 2018 12:55:03 +0100
Subject: [PATCH 07/33] rename kernel package names to *-socfpga-rt-ltsi

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 scripts/package/builddeb | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/scripts/package/builddeb b/scripts/package/builddeb
index d6a4058377f4..ee58811e94d0 100755
--- a/scripts/package/builddeb
+++ b/scripts/package/builddeb
@@ -96,9 +96,9 @@ fwdir="$objtree/debian/fwtmp"
 kernel_headers_dir="$objtree/debian/hdrtmp"
 libc_headers_dir="$objtree/debian/headertmp"
 dbg_dir="$objtree/debian/dbgtmp"
-packagename=linux-image-$version
-fwpackagename=linux-firmware-image-$version
-kernel_headers_packagename=linux-headers-$version
+packagename=linux-image-socfpga-rt-ltsi
+fwpackagename=linux-firmware-image-socfpga-rt-ltsi
+kernel_headers_packagename=linux-headers-socfpga-rt-ltsi
 libc_headers_packagename=linux-libc-dev
 dbg_packagename=$packagename-dbg
 debarch=
-- 
2.17.1


From c4d51ebaf0fd72b6ec4bad6d54bbf2d205702d22 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Mon, 21 May 2018 13:19:43 +0200
Subject: [PATCH 08/33] Enable bridges in dtb's

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/socfpga.dtsi | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index 595eb4f1a761..3de276d42114 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -526,6 +526,7 @@
 			reg = <0xff400000 0x100000>;
 			resets = <&rst LWHPS2FPGA_RESET>;
 			clocks = <&l4_main_clk>;
+            bridge-enable = <1>;
 		};
 
 		fpga_bridge1: fpga_bridge@ff500000 {
@@ -533,6 +534,7 @@
 			reg = <0xff500000 0x10000>;
 			resets = <&rst HPS2FPGA_RESET>;
 			clocks = <&l4_main_clk>;
+            bridge-enable = <1>;
 		};
 
 		fpgamgr0: fpgamgr@ff706000 {
-- 
2.17.1


From ce25054a5cd29a0439ec7b0c36ed9c56d60a14d6 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sat, 10 Mar 2018 13:13:12 +0100
Subject: [PATCH 09/33] add spidev in dts so driver is loaded

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/socfpga.dtsi | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index 3de276d42114..dce11432fcbd 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -804,8 +804,17 @@
 			reg = <0xfff01000 0x1000>;
 			interrupts = <0 155 4>;
 			num-cs = <4>;
+			tx-dma-channel = <&pdma 20>;
+			rx-dma-channel = <&pdma 21>;
 			clocks = <&spi_m_clk>;
-			status = "disabled";
+			status = "okay";
+
+            spidev1: spidev@0 {
+                compatible = "rohm,dh2228fv";
+                reg = <0>;
+                spi-max-frequency = <100000000>;
+                enable-dma = <1>;
+            };
 		};
 
 		sysmgr: sysmgr@ffd08000 {
-- 
2.17.1


From f10355556e59c9f1b516e97135810d130aa87588 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Mon, 12 Mar 2018 23:41:23 +0100
Subject: [PATCH 10/33] set ACL secutity

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 44eb99105dcd..bce72c27b9d5 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -157,13 +157,17 @@ CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 CONFIG_EXT3_FS=y
 CONFIG_EXT4_FS=y
-# CONFIG_AUTOFS4_FS=y
 CONFIG_EXT4_FS_POSIX_ACL=y
 CONFIG_EXT4_FS_SECURITY=y
+CONFIG_EXT4_FS_XATTR=y
 CONFIG_VFAT_FS=y
 CONFIG_NTFS_FS=y
 CONFIG_NTFS_RW=y
+CONFIG_AUTOFS4_FS=m
 CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_SECURITY=y
+CONFIG_TMPFS_XATTR=y
 CONFIG_JFFS2_FS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3_ACL=y
@@ -181,3 +185,5 @@ CONFIG_DETECT_HUNG_TASK=y
 # CONFIG_SCHED_DEBUG is not set
 CONFIG_FUNCTION_TRACER=y
 CONFIG_DEBUG_USER=y
+CONFIG_ISCSI_TCP=m
+CONFIG_ISCSI_TARGET=m
-- 
2.17.1


From 8d2003f8a906701e0f569d93e65fdfa666f32a06 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Fri, 30 Mar 2018 20:41:53 +0200
Subject: [PATCH 11/33] Enable altvip framebuffer

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/Kconfig                   |   1 +
 arch/arm/configs/socfpga_defconfig | 111 +++++++++++++++++++++++++++++
 2 files changed, 112 insertions(+)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 5715844e83e3..62f0881d75e9 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1737,6 +1737,7 @@ source "mm/Kconfig"
 
 config FORCE_MAX_ZONEORDER
 	int "Maximum zone order"
+	default "13" if ARCH_SOCFPGA
 	default "12" if SOC_AM33XX
 	default "9" if SA1111 || ARCH_EFM32
 	default "11"
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index bce72c27b9d5..ad7ca9d21361 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -187,3 +187,114 @@ CONFIG_FUNCTION_TRACER=y
 CONFIG_DEBUG_USER=y
 CONFIG_ISCSI_TCP=m
 CONFIG_ISCSI_TARGET=m
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_ARM_HEAVY_MB=y
+CONFIG_ARCH_SUPPORTS_BIG_ENDIAN=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_FORCE_MAX_ZONEORDER=13
+CONFIG_CMA=y
+CONFIG_DMA_CMA=y
+CONFIG_MEMORY_ISOLATION=y
+CONFIG_CMA_DEBUG=y
+CONFIG_CMA_DEBUGFS=y
+CONFIG_CMA_AREAS=7
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_FRAME_VECTOR=y
+CONFIG_CMA_SIZE_MBYTES=512
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_MEDIA_CONTROLLER_DVB=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_VMALLOC=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=y
+CONFIG_USB_M5602=y
+CONFIG_USB_STV06XX=y
+CONFIG_USB_GL860=y
+CONFIG_USB_GSPCA_BENQ=y
+CONFIG_USB_GSPCA_CONEX=y
+CONFIG_USB_GSPCA_CPIA1=y
+CONFIG_USB_GSPCA_DTCS033=y
+CONFIG_USB_GSPCA_ETOMS=y
+CONFIG_USB_GSPCA_FINEPIX=y
+CONFIG_USB_GSPCA_JEILINJ=y
+CONFIG_USB_GSPCA_JL2005BCD=y
+CONFIG_USB_GSPCA_KINECT=y
+CONFIG_USB_GSPCA_KONICA=y
+CONFIG_USB_GSPCA_MARS=y
+CONFIG_USB_GSPCA_MR97310A=y
+CONFIG_USB_GSPCA_NW80X=y
+CONFIG_USB_GSPCA_OV519=y
+CONFIG_USB_GSPCA_OV534=y
+CONFIG_USB_GSPCA_OV534_9=y
+CONFIG_USB_GSPCA_PAC207=y
+CONFIG_USB_GSPCA_PAC7302=y
+CONFIG_USB_GSPCA_PAC7311=y
+CONFIG_USB_GSPCA_SE401=y
+CONFIG_USB_GSPCA_SN9C2028=y
+CONFIG_USB_GSPCA_SN9C20X=y
+CONFIG_USB_GSPCA_SONIXB=y
+CONFIG_USB_GSPCA_SONIXJ=y
+CONFIG_USB_GSPCA_SPCA500=y
+CONFIG_USB_GSPCA_SPCA501=y
+CONFIG_USB_GSPCA_SPCA505=y
+CONFIG_USB_GSPCA_SPCA506=y
+CONFIG_USB_GSPCA_SPCA508=y
+CONFIG_USB_GSPCA_SPCA561=y
+CONFIG_USB_GSPCA_SPCA1528=y
+CONFIG_USB_GSPCA_SQ905=y
+CONFIG_USB_GSPCA_SQ905C=y
+CONFIG_USB_GSPCA_SQ930X=y
+CONFIG_USB_GSPCA_STK014=y
+CONFIG_USB_GSPCA_STK1135=y
++CONFIG_USB_GSPCA_STV0680=y
+CONFIG_USB_GSPCA_SUNPLUS=y
+CONFIG_USB_GSPCA_T613=y
+CONFIG_USB_GSPCA_TOPRO=y
+CONFIG_USB_GSPCA_TOUPTEK=y
+CONFIG_USB_GSPCA_TV8532=y
+CONFIG_USB_GSPCA_VC032X=y
+CONFIG_USB_GSPCA_VICAM=y
+CONFIG_USB_GSPCA_XIRLINK_CIT=y
+CONFIG_USB_GSPCA_ZC3XX=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_SOC_CAMERA=y
+CONFIG_SOC_CAMERA_PLATFORM=y
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_ALTERA_VIP=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+CONFIG_LIBCRC32C=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=y
+CONFIG_HID=y
+CONFIG_USB_HID=y
+CONFIG_HID_MULTITOUCH=y
+#CONFIG_ALTERA_PR_IP_CORE=y
+#CONFIG_ALTERA_PR_IP_CORE_PLAT=y
-- 
2.17.1


From c9317aa2f577862ee595cf4bdeb114e2f223863e Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sun, 11 Mar 2018 22:21:04 +0100
Subject: [PATCH 12/33] Added DE-10 Nano with uio, with/without framebuffer
 1024x768 and 1920x1080(hd) dts dtb

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/Makefile                    |   3 +
 .../boot/dts/socfpga_cyclone5_de10_nano.dts   | 112 +++++++++
 .../dts/socfpga_cyclone5_de10_nano_uio_fb.dts | 215 ++++++++++++++++++
 .../socfpga_cyclone5_de10_nano_uio_fb_hd.dts  | 215 ++++++++++++++++++
 4 files changed, 545 insertions(+)
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index b786f24d20e5..24fc153474bb 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -700,6 +700,9 @@ dtb-$(CONFIG_ARCH_SOCFPGA) += \
 	socfpga_cyclone5_mcvevk.dtb \
 	socfpga_cyclone5_socdk.dtb \
 	socfpga_cyclone5_de0_sockit.dtb \
+	socfpga_cyclone5_de10_nano_uio_fb.dtb \
+	socfpga_cyclone5_de10_nano_uio_fb_hd.dtb \
+	socfpga_cyclone5_de10_nano.dtb \
 	socfpga_cyclone5_sockit.dtb \
 	socfpga_cyclone5_socrates.dtb \
 	socfpga_cyclone5_sodia.dtb \
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts
new file mode 100644
index 000000000000..7645340f9787
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts
@@ -0,0 +1,112 @@
+/*
+ * Copyright Intel Corporation (C) 2017. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE10-Nano";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@0 {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	clock-frequency = <100000>;
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl345";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
new file mode 100644
index 000000000000..074a58924fa6
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
@@ -0,0 +1,215 @@
+/*
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE10-Nano";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+				<0x00000001 0x00002000 0xff202000 0x00000008>,
+				<0x00000001 0x00003000 0xff203000 0x00000010>,
+				<0x00000001 0x00004000 0xff204000 0x00000010>,
+				<0x00000001 0x00005000 0xff205000 0x00000010>,
+				<0x00000001 0x00030000 0xff230000 0x00000100>,
+				<0x00000001 0x00031000 0xff231000 0x00000080>,
+				<0x00000001 0x00040000 0xff240000 0x00010000>;
+
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <0xacd51302>;
+			timestamp = <0x5929e204>;
+		};
+
+		serial@0x100002000 {
+			compatible = "altr,juart-15.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00002000 0x00000008>;
+			interrupt-parent = <0x3>;
+			interrupts = <0x0 0x2a 0x4>;
+			clocks = <0x2>;
+		};
+
+		gpio@0x100003000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00003000 0x00000010>;
+			altr,gpio-bank-width = <0x8>;
+			resetvalue = <0xff>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100004000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00004000 0x00000010>;
+			altr,gpio-bank-width = <0x4>;
+			altr,interrupt-type = <0x3>;
+			altr,interrupt_type = <0x3>;
+			edge_type = <0x2>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100005000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00005000 0x00000010>;
+			altr,gpio-bank-width = <0x2>;
+			altr,interrupt-type = <0x2>;
+			altr,interrupt_type = <0x2>;
+			edge_type = <0x1>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		ilc@0x100030000 {
+			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
+			reg = <0x00000001 0x00030000 0x00000100>;
+			interrupt-controller;
+			#interrupt-cells = <0x1>;
+			altr,sw-fifo-depth = <0x20>;
+		};
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-9.1";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <1024>;
+			max-height = <768>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+
+		uio-socfpg0@0x100040000 {
+			compatible = "generic-uio,ui_pdrv";
+			reg = <0x00000001 0x00040000 0x00010000>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 43 1>;
+			address_width = <14>;
+			data_width = <32>;
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl34x";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
new file mode 100644
index 000000000000..bfb289855be1
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
@@ -0,0 +1,215 @@
+/*
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE10-Nano";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+				<0x00000001 0x00002000 0xff202000 0x00000008>,
+				<0x00000001 0x00003000 0xff203000 0x00000010>,
+				<0x00000001 0x00004000 0xff204000 0x00000010>,
+				<0x00000001 0x00005000 0xff205000 0x00000010>,
+				<0x00000001 0x00030000 0xff230000 0x00000100>,
+				<0x00000001 0x00031000 0xff231000 0x00000080>,
+				<0x00000001 0x00040000 0xff240000 0x00010000>;
+
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <0xacd51302>;
+			timestamp = <0x5929e204>;
+		};
+
+		serial@0x100002000 {
+			compatible = "altr,juart-15.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00002000 0x00000008>;
+			interrupt-parent = <0x3>;
+			interrupts = <0x0 0x2a 0x4>;
+			clocks = <0x2>;
+		};
+
+		gpio@0x100003000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00003000 0x00000010>;
+			altr,gpio-bank-width = <0x8>;
+			resetvalue = <0xff>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100004000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00004000 0x00000010>;
+			altr,gpio-bank-width = <0x4>;
+			altr,interrupt-type = <0x3>;
+			altr,interrupt_type = <0x3>;
+			edge_type = <0x2>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100005000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00005000 0x00000010>;
+			altr,gpio-bank-width = <0x2>;
+			altr,interrupt-type = <0x2>;
+			altr,interrupt_type = <0x2>;
+			edge_type = <0x1>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		ilc@0x100030000 {
+			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
+			reg = <0x00000001 0x00030000 0x00000100>;
+			interrupt-controller;
+			#interrupt-cells = <0x1>;
+			altr,sw-fifo-depth = <0x20>;
+		};
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-9.1";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <1920>;
+			max-height = <1080>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+
+		uio-socfpg0@0x100040000 {
+			compatible = "generic-uio,ui_pdrv";
+			reg = <0x00000001 0x00040000 0x00010000>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 43 1>;
+			address_width = <14>;
+			data_width = <32>;
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl34x";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
-- 
2.17.1


From ea682e9a715ee7962c92f0a0dd83e333809e12f4 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Fri, 18 May 2018 20:35:35 +0200
Subject: [PATCH 13/33] Add framebuffer-ii core driver based on Mister, and
 enable it

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig |   4 +-
 drivers/video/fbdev/Kconfig        |  48 ++--
 drivers/video/fbdev/Makefile       |   1 +
 drivers/video/fbdev/altvipfb.c     | 420 ++++++++++++++---------------
 drivers/video/fbdev/altvipfbii.c   | 260 ++++++++++++++++++
 5 files changed, 503 insertions(+), 230 deletions(-)
 create mode 100644 drivers/video/fbdev/altvipfbii.c

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index ad7ca9d21361..cb504b62a019 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -118,7 +118,9 @@ CONFIG_MFD_STMPE=y
 CONFIG_REGULATOR=y
 CONFIG_REGULATOR_FIXED_VOLTAGE=y
 CONFIG_FB=y
-CONFIG_FB_ALTERA_VIP_FB2_PLAT=m
+CONFIG_FB_ALTERA_VIP=y
+CONFIG_FB_ALTERA_VIP_II=y
+CONFIG_FB_ALTERA_VIP_FB2_PLAT=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
 CONFIG_USB=y
diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index cf29ed5e40ca..d30601787b5d 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -238,6 +238,16 @@ config FB_ALTERA_VIP
 	  This driver supports the Altera Video and Image Processing(VIP)
 	  Frame Reader
 
+config FB_ALTERA_VIP_II
+	tristate "Altera VIP II Framebuffer support"
+	depends on FB
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This driver supports the Altera Video and Image Processing(VIP)
+	  Framebuffer II
+
 config FB_ALTERA_VIP_FB2
     tristate "Altera VIP Frame Buffer II framebuffer support"
 	depends on FB
@@ -725,7 +735,7 @@ config FB_STI
 	  BIOS routines contained in a ROM chip in HP PA-RISC based machines.
 	  Enabling this option will implement the linux framebuffer device
 	  using calls to the STI BIOS routines for initialisation.
-	
+
 	  If you enable this option, you will get a planar framebuffer device
 	  /dev/fb which will work on the most common HP graphic cards of the
 	  NGLE family, including the artist chips (in the 7xx and Bxxx series),
@@ -1159,36 +1169,36 @@ config FB_I810
 	select FB_CFB_IMAGEBLIT
 	select VGASTATE
 	help
-	  This driver supports the on-board graphics built in to the Intel 810 
+	  This driver supports the on-board graphics built in to the Intel 810
           and 815 chipsets.  Say Y if you have and plan to use such a board.
 
           To compile this driver as a module, choose M here: the
 	  module will be called i810fb.
 
-          For more information, please read 
+          For more information, please read
 	  <file:Documentation/fb/intel810.txt>
 
 config FB_I810_GTF
 	bool "use VESA Generalized Timing Formula"
 	depends on FB_I810
 	help
-	  If you say Y, then the VESA standard, Generalized Timing Formula 
+	  If you say Y, then the VESA standard, Generalized Timing Formula
           or GTF, will be used to calculate the required video timing values
-	  per video mode.  Since the GTF allows nondiscrete timings 
+	  per video mode.  Since the GTF allows nondiscrete timings
           (nondiscrete being a range of values as opposed to discrete being a
-          set of values), you'll be able to use any combination of horizontal 
+          set of values), you'll be able to use any combination of horizontal
 	  and vertical resolutions, and vertical refresh rates without having
 	  to specify your own timing parameters.  This is especially useful
-	  to maximize the performance of an aging display, or if you just 
-          have a display with nonstandard dimensions. A VESA compliant 
+	  to maximize the performance of an aging display, or if you just
+          have a display with nonstandard dimensions. A VESA compliant
 	  monitor is recommended, but can still work with non-compliant ones.
-	  If you need or want this, then select this option. The timings may 
-	  not be compliant with Intel's recommended values. Use at your own 
+	  If you need or want this, then select this option. The timings may
+	  not be compliant with Intel's recommended values. Use at your own
 	  risk.
 
-          If you say N, the driver will revert to discrete video timings 
+          If you say N, the driver will revert to discrete video timings
 	  using a set recommended by Intel in their documentation.
-  
+
           If unsure, say N.
 
 config FB_I810_I2C
@@ -1306,10 +1316,10 @@ config FB_MATROX_G
 	  G450/G550 secondary head and digital output are supported without
 	  additional modules.
 
-	  The driver starts in monitor mode. You must use the matroxset tool 
-	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to 
-	  swap primary and secondary head outputs, or to change output mode.  
-	  Secondary head driver always start in 640x480 resolution and you 
+	  The driver starts in monitor mode. You must use the matroxset tool
+	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to
+	  swap primary and secondary head outputs, or to change output mode.
+	  Secondary head driver always start in 640x480 resolution and you
 	  must use fbset to change it.
 
 	  Do not forget that second head supports only 16 and 32 bpp
@@ -1392,7 +1402,7 @@ config FB_RADEON_I2C
 	select FB_DDC
 	default y
 	help
-	  Say Y here if you want DDC/I2C support for your Radeon board. 
+	  Say Y here if you want DDC/I2C support for your Radeon board.
 
 config FB_RADEON_BACKLIGHT
 	bool "Support for backlight control"
@@ -1625,7 +1635,7 @@ config FB_NEOMAGIC
 	select VGASTATE
 	help
 	  This driver supports notebooks with NeoMagic PCI chips.
-	  Say Y if you have such a graphics card. 
+	  Say Y if you have such a graphics card.
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called neofb.
@@ -1680,7 +1690,7 @@ config FB_VOODOO1
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
 	---help---
-	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or 
+	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or
 	  Voodoo2 (cvg) based graphics card.
 
 	  To compile this driver as a module, choose M here: the
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index bb8f9d0ac6b3..5951a8f70640 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_FB_WMT_GE_ROPS)   += wmt_ge_rops.o
 
 # Hardware specific drivers go first
 obj-$(CONFIG_FB_ALTERA_VIP)	  += altvipfb.o
+obj-$(CONFIG_FB_ALTERA_VIP_II)	  += altvipfbii.o
 obj-$(CONFIG_FB_ALTERA_VIP_FB2) += altvipfb2.o
 obj-$(CONFIG_FB_ALTERA_VIP_FB2_PLAT) += altvipfb2_drv.o
 altvipfb2_drv-objs := altvipfb2-plat.o altvipfb2.o
diff --git a/drivers/video/fbdev/altvipfb.c b/drivers/video/fbdev/altvipfb.c
index b247858ba43a..4724a0e975e5 100644
--- a/drivers/video/fbdev/altvipfb.c
+++ b/drivers/video/fbdev/altvipfb.c
@@ -41,260 +41,260 @@
 struct altvipfb_type;
 
 struct altvipfb_dev {
-	struct platform_device *pdev;
-	struct fb_info info;
-	struct resource *reg_res;
-	void __iomem *base;
-	int mem_word_width;
-	u32 pseudo_palette[PALETTE_SIZE];
+    struct platform_device *pdev;
+    struct fb_info info;
+    struct resource *reg_res;
+    void __iomem *base;
+    int mem_word_width;
+    u32 pseudo_palette[PALETTE_SIZE];
 };
 
 static int altvipfb_setcolreg(unsigned regno, unsigned red, unsigned green,
-			   unsigned blue, unsigned transp, struct fb_info *info)
+                              unsigned blue, unsigned transp, struct fb_info *info)
 {
-	/*
-	 *  Set a single color register. The values supplied have a 32 bit
-	 *  magnitude.
-	 *  Return != 0 for invalid regno.
-	 */
+    /*
+     *  Set a single color register. The values supplied have a 32 bit
+     *  magnitude.
+     *  Return != 0 for invalid regno.
+     */
 
-	if (regno > 255)
-		return 1;
+    if (regno > 255)
+        return 1;
 
-	red >>= 8;
-	green >>= 8;
-	blue >>= 8;
+    red >>= 8;
+    green >>= 8;
+    blue >>= 8;
 
-	if (regno < 255) {
-		((u32 *)info->pseudo_palette)[regno] =
-		((red & 255) << 16) | ((green & 255) << 8) | (blue & 255);
-	}
+    if (regno < 255) {
+        ((u32 *)info->pseudo_palette)[regno] =
+        ((red & 255) << 16) | ((green & 255) << 8) | (blue & 255);
+    }
 
-	return 0;
+    return 0;
 }
 
 static struct fb_ops altvipfb_ops = {
-	.owner = THIS_MODULE,
-	.fb_fillrect = cfb_fillrect,
-	.fb_copyarea = cfb_copyarea,
-	.fb_imageblit = cfb_imageblit,
-	.fb_setcolreg = altvipfb_setcolreg,
+    .owner = THIS_MODULE,
+    .fb_fillrect = cfb_fillrect,
+    .fb_copyarea = cfb_copyarea,
+    .fb_imageblit = cfb_imageblit,
+    .fb_setcolreg = altvipfb_setcolreg,
 };
 
 static int altvipfb_of_setup(struct altvipfb_dev *fbdev)
 {
-	struct device_node *np = fbdev->pdev->dev.of_node;
-	int ret;
-	u32 bits_per_color;
-
-	ret = of_property_read_u32(np, "max-width", &fbdev->info.var.xres);
-	if (ret) {
-		dev_err(&fbdev->pdev->dev,
-			"Missing required parameter 'max-width'");
-		return ret;
-	}
-	fbdev->info.var.xres_virtual = fbdev->info.var.xres,
-
-	ret = of_property_read_u32(np, "max-height", &fbdev->info.var.yres);
-	if (ret) {
-		dev_err(&fbdev->pdev->dev,
-			"Missing required parameter 'max-height'");
-		return ret;
-	}
-	fbdev->info.var.yres_virtual = fbdev->info.var.yres;
-
-	ret = of_property_read_u32(np, "bits-per-color", &bits_per_color);
-	if (ret) {
-		dev_err(&fbdev->pdev->dev,
-			"Missing required parameter 'bits-per-color'");
-		return ret;
-	}
-	if (bits_per_color != 8) {
-		dev_err(&fbdev->pdev->dev,
-			"bits-per-color is set to %i.  Curently only 8 is supported.",
-			bits_per_color);
-		return -ENODEV;
-	}
-	fbdev->info.var.bits_per_pixel = 32;
-
-	ret = of_property_read_u32(np, "mem-word-width",
-				   &fbdev->mem_word_width);
-	if (ret) {
-		dev_err(&fbdev->pdev->dev,
-			"Missing required parameter 'mem-word-width'");
-		return ret;
-	}
-	if (!(fbdev->mem_word_width >= 32 && fbdev->mem_word_width % 32 == 0)) {
-		dev_err(&fbdev->pdev->dev,
-			"mem-word-width is set to %i.  must be >= 32 and multiple of 32.",
-			fbdev->mem_word_width);
-		return -ENODEV;
-	}
-
-	return 0;
+    struct device_node *np = fbdev->pdev->dev.of_node;
+    int ret;
+    u32 bits_per_color;
+
+    ret = of_property_read_u32(np, "max-width", &fbdev->info.var.xres);
+    if (ret) {
+        dev_err(&fbdev->pdev->dev,
+                "Missing required parameter 'max-width'");
+        return ret;
+    }
+    fbdev->info.var.xres_virtual = fbdev->info.var.xres,
+
+    ret = of_property_read_u32(np, "max-height", &fbdev->info.var.yres);
+    if (ret) {
+        dev_err(&fbdev->pdev->dev,
+                "Missing required parameter 'max-height'");
+        return ret;
+    }
+    fbdev->info.var.yres_virtual = fbdev->info.var.yres;
+
+    ret = of_property_read_u32(np, "bits-per-color", &bits_per_color);
+    if (ret) {
+        dev_err(&fbdev->pdev->dev,
+                "Missing required parameter 'bits-per-color'");
+        return ret;
+    }
+    if (bits_per_color != 8) {
+        dev_err(&fbdev->pdev->dev,
+                "bits-per-color is set to %i.  Curently only 8 is supported.",
+                bits_per_color);
+        return -ENODEV;
+    }
+    fbdev->info.var.bits_per_pixel = 32;
+
+    ret = of_property_read_u32(np, "mem-word-width",
+                               &fbdev->mem_word_width);
+    if (ret) {
+        dev_err(&fbdev->pdev->dev,
+                "Missing required parameter 'mem-word-width'");
+        return ret;
+    }
+    if (!(fbdev->mem_word_width >= 32 && fbdev->mem_word_width % 32 == 0)) {
+        dev_err(&fbdev->pdev->dev,
+                "mem-word-width is set to %i.  must be >= 32 and multiple of 32.",
+                fbdev->mem_word_width);
+        return -ENODEV;
+    }
+
+    return 0;
 }
 
 static void altvipfb_start_hw(struct altvipfb_dev *fbdev)
 {
-	writel(fbdev->info.fix.smem_start, fbdev->base +
-	       ALTVIPFB_FRAME0_BASE_ADDRESS);
-	writel(fbdev->info.var.xres * fbdev->info.var.yres /
-	       (fbdev->mem_word_width/32),
-	       fbdev->base + ALTVIPFB_FRAME0_NUM_WORDS);
-	writel(fbdev->info.var.xres * fbdev->info.var.yres,
-	       fbdev->base + ALTVIPFB_FRAME0_SAMPLES);
-	writel(fbdev->info.var.xres, fbdev->base + ALTVIPFB_FRAME0_WIDTH);
-	writel(fbdev->info.var.yres, fbdev->base + ALTVIPFB_FRAME0_HEIGHT);
-	writel(3, fbdev->base + ALTVIPFB_FRAME0_INTERLACED);
-	writel(0, fbdev->base + ALTVIPFB_FRAME_SELECT);
-
-	/* Finally set the control register to 1 to start streaming */
-	writel(1, fbdev->base + ALTVIPFB_CONTROL);
+    writel(fbdev->info.fix.smem_start, fbdev->base +
+    ALTVIPFB_FRAME0_BASE_ADDRESS);
+    writel(fbdev->info.var.xres * fbdev->info.var.yres /
+    (fbdev->mem_word_width/32),
+           fbdev->base + ALTVIPFB_FRAME0_NUM_WORDS);
+    writel(fbdev->info.var.xres * fbdev->info.var.yres,
+           fbdev->base + ALTVIPFB_FRAME0_SAMPLES);
+    writel(fbdev->info.var.xres, fbdev->base + ALTVIPFB_FRAME0_WIDTH);
+    writel(fbdev->info.var.yres, fbdev->base + ALTVIPFB_FRAME0_HEIGHT);
+    writel(3, fbdev->base + ALTVIPFB_FRAME0_INTERLACED);
+    writel(0, fbdev->base + ALTVIPFB_FRAME_SELECT);
+
+    /* Finally set the control register to 1 to start streaming */
+    writel(1, fbdev->base + ALTVIPFB_CONTROL);
 }
 
 static void altvipfb_disable_hw(struct altvipfb_dev *fbdev)
 {
-	/* set the control register to 0 to stop streaming */
-	writel(0, fbdev->base + ALTVIPFB_CONTROL);
+    /* set the control register to 0 to stop streaming */
+    writel(0, fbdev->base + ALTVIPFB_CONTROL);
 }
 
 
 static int altvipfb_setup_fb_info(struct altvipfb_dev *fbdev)
 {
-	struct fb_info *info = &fbdev->info;
-	int ret;
-
-	strcpy(info->fix.id, DRIVER_NAME);
-	info->fix.type = FB_TYPE_PACKED_PIXELS;
-	info->fix.visual = FB_VISUAL_TRUECOLOR;
-	info->fix.accel = FB_ACCEL_NONE;
-
-	info->fbops = &altvipfb_ops;
-	info->var.activate = FB_ACTIVATE_NOW;
-	info->var.height = -1;
-	info->var.width = -1;
-	info->var.vmode = FB_VMODE_NONINTERLACED;
-
-	ret = altvipfb_of_setup(fbdev);
-	if (ret)
-		return ret;
-
-	/* settings for 32bit pixels */
-	info->var.red.offset = 16;
-	info->var.red.length = 8;
-	info->var.red.msb_right = 0;
-	info->var.green.offset = 8;
-	info->var.green.length = 8;
-	info->var.green.msb_right = 0;
-	info->var.blue.offset = 0;
-	info->var.blue.length = 8;
-	info->var.blue.msb_right = 0;
-
-	info->fix.line_length = (info->var.xres *
-		(info->var.bits_per_pixel >> 3));
-	info->fix.smem_len = info->fix.line_length * info->var.yres;
-
-	info->pseudo_palette = fbdev->pseudo_palette;
-	info->flags = FBINFO_FLAG_DEFAULT;
-
-	return 0;
+    struct fb_info *info = &fbdev->info;
+    int ret;
+
+    strcpy(info->fix.id, DRIVER_NAME);
+    info->fix.type = FB_TYPE_PACKED_PIXELS;
+    info->fix.visual = FB_VISUAL_TRUECOLOR;
+    info->fix.accel = FB_ACCEL_NONE;
+
+    info->fbops = &altvipfb_ops;
+    info->var.activate = FB_ACTIVATE_NOW;
+    info->var.height = -1;
+    info->var.width = -1;
+    info->var.vmode = FB_VMODE_NONINTERLACED;
+
+    ret = altvipfb_of_setup(fbdev);
+    if (ret)
+        return ret;
+
+    /* settings for 32bit pixels */
+    info->var.red.offset = 16;
+    info->var.red.length = 8;
+    info->var.red.msb_right = 0;
+    info->var.green.offset = 8;
+    info->var.green.length = 8;
+    info->var.green.msb_right = 0;
+    info->var.blue.offset = 0;
+    info->var.blue.length = 8;
+    info->var.blue.msb_right = 0;
+
+    info->fix.line_length = (info->var.xres *
+    (info->var.bits_per_pixel >> 3));
+    info->fix.smem_len = info->fix.line_length * info->var.yres;
+
+    info->pseudo_palette = fbdev->pseudo_palette;
+    info->flags = FBINFO_FLAG_DEFAULT;
+
+    return 0;
 }
 
 static int altvipfb_probe(struct platform_device *pdev)
 {
-	int retval;
-	void *fbmem_virt;
-	struct altvipfb_dev *fbdev;
-
-	fbdev = devm_kzalloc(&pdev->dev, sizeof(*fbdev), GFP_KERNEL);
-	if (!fbdev)
-		return -ENOMEM;
-
-	fbdev->pdev = pdev;
-	fbdev->reg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!fbdev->reg_res)
-		return -ENODEV;
-
-	retval = altvipfb_setup_fb_info(fbdev);
-
-	fbmem_virt = dma_alloc_coherent(NULL,
-					fbdev->info.fix.smem_len,
-					(void *)&(fbdev->info.fix.smem_start),
-					GFP_KERNEL);
-	if (!fbmem_virt) {
-		dev_err(&pdev->dev,
-			"altvipfb: unable to allocate %d Bytes fb memory\n",
-			fbdev->info.fix.smem_len);
-		return retval;
-	}
-
-	fbdev->info.screen_base = fbmem_virt;
-
-	retval = fb_alloc_cmap(&fbdev->info.cmap, PALETTE_SIZE, 0);
-	if (retval < 0)
-		goto err_dma_free;
-
-	platform_set_drvdata(pdev, fbdev);
-
-	fbdev->base = devm_ioremap_resource(&pdev->dev, fbdev->reg_res);
-	if (IS_ERR(fbdev->base)) {
-		dev_err(&pdev->dev, "devm_ioremap_resource failed\n");
-		retval = PTR_ERR(fbdev->base);
-		goto err_dealloc_cmap;
-	}
-
-	altvipfb_start_hw(fbdev);
-
-	retval = register_framebuffer(&fbdev->info);
-	if (retval < 0)
-		goto err_dealloc_cmap;
-
-	dev_info(&pdev->dev, "fb%d: %s frame buffer device at 0x%x+0x%x\n",
-		 fbdev->info.node, fbdev->info.fix.id,
-		 (unsigned)fbdev->info.fix.smem_start,
-		 fbdev->info.fix.smem_len);
-
-	return 0;
-
-err_dealloc_cmap:
-	fb_dealloc_cmap(&fbdev->info.cmap);
-err_dma_free:
-	dma_free_coherent(NULL, fbdev->info.fix.smem_len, fbmem_virt,
-			  fbdev->info.fix.smem_start);
-	return retval;
+    int retval;
+    void *fbmem_virt;
+    struct altvipfb_dev *fbdev;
+
+    fbdev = devm_kzalloc(&pdev->dev, sizeof(*fbdev), GFP_KERNEL);
+    if (!fbdev)
+        return -ENOMEM;
+
+    fbdev->pdev = pdev;
+    fbdev->reg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!fbdev->reg_res)
+        return -ENODEV;
+
+    retval = altvipfb_setup_fb_info(fbdev);
+
+    fbmem_virt = dma_alloc_coherent(NULL,
+                                    fbdev->info.fix.smem_len,
+                                    (void *)&(fbdev->info.fix.smem_start),
+                                    GFP_KERNEL);
+    if (!fbmem_virt) {
+        dev_err(&pdev->dev,
+                "altvipfb: unable to allocate %d Bytes fb memory\n",
+                fbdev->info.fix.smem_len);
+        return retval;
+    }
+
+    fbdev->info.screen_base = fbmem_virt;
+
+    retval = fb_alloc_cmap(&fbdev->info.cmap, PALETTE_SIZE, 0);
+    if (retval < 0)
+        goto err_dma_free;
+
+    platform_set_drvdata(pdev, fbdev);
+
+    fbdev->base = devm_ioremap_resource(&pdev->dev, fbdev->reg_res);
+    if (IS_ERR(fbdev->base)) {
+        dev_err(&pdev->dev, "devm_ioremap_resource failed\n");
+        retval = PTR_ERR(fbdev->base);
+        goto err_dealloc_cmap;
+    }
+
+    altvipfb_start_hw(fbdev);
+
+    retval = register_framebuffer(&fbdev->info);
+    if (retval < 0)
+        goto err_dealloc_cmap;
+
+    dev_info(&pdev->dev, "fb%d: %s frame buffer device at 0x%x+0x%x\n",
+             fbdev->info.node, fbdev->info.fix.id,
+             (unsigned)fbdev->info.fix.smem_start,
+             fbdev->info.fix.smem_len);
+
+    return 0;
+
+    err_dealloc_cmap:
+    fb_dealloc_cmap(&fbdev->info.cmap);
+    err_dma_free:
+    dma_free_coherent(NULL, fbdev->info.fix.smem_len, fbmem_virt,
+                      fbdev->info.fix.smem_start);
+    return retval;
 }
 
 static int altvipfb_remove(struct platform_device *dev)
 {
-	struct altvipfb_dev *fbdev = platform_get_drvdata(dev);
-
-	if (fbdev) {
-		unregister_framebuffer(&fbdev->info);
-		fb_dealloc_cmap(&fbdev->info.cmap);
-		dma_free_coherent(NULL, fbdev->info.fix.smem_len,
-				  fbdev->info.screen_base,
-				  fbdev->info.fix.smem_start);
-		altvipfb_disable_hw(fbdev);
-	}
-	return 0;
+    struct altvipfb_dev *fbdev = platform_get_drvdata(dev);
+
+    if (fbdev) {
+        unregister_framebuffer(&fbdev->info);
+        fb_dealloc_cmap(&fbdev->info.cmap);
+        dma_free_coherent(NULL, fbdev->info.fix.smem_len,
+                          fbdev->info.screen_base,
+                          fbdev->info.fix.smem_start);
+        altvipfb_disable_hw(fbdev);
+    }
+    return 0;
 }
 
 
 static struct of_device_id altvipfb_match[] = {
-	{ .compatible = "altr,vip-frame-reader-1.0" },
-	{ .compatible = "altr,vip-frame-reader-9.1" },
-	{},
+    { .compatible = "altr,vip-frame-reader-1.0" },
+    { .compatible = "altr,vip-frame-reader-9.1" },
+    {},
 };
 MODULE_DEVICE_TABLE(of, altvipfb_match);
 
 static struct platform_driver altvipfb_driver = {
-	.probe = altvipfb_probe,
-	.remove = altvipfb_remove,
-	.driver = {
-		.owner = THIS_MODULE,
-		.name = DRIVER_NAME,
-		.of_match_table = altvipfb_match,
-	},
+    .probe = altvipfb_probe,
+    .remove = altvipfb_remove,
+    .driver = {
+        .owner = THIS_MODULE,
+        .name = DRIVER_NAME,
+        .of_match_table = altvipfb_match,
+    },
 };
 module_platform_driver(altvipfb_driver);
 
diff --git a/drivers/video/fbdev/altvipfbii.c b/drivers/video/fbdev/altvipfbii.c
new file mode 100644
index 000000000000..a80ae1a714f7
--- /dev/null
+++ b/drivers/video/fbdev/altvipfbii.c
@@ -0,0 +1,260 @@
+/*
+ *  altvipfb.c -- Altera Video and Image Processing(VIP) Frame Reader driver
+ *
+ *  This is based on a driver made by Thomas Chou <thomas@wytron.com.tw> and
+ *  Walter Goossens <waltergoossens@home.nl> This driver supports the Altera VIP
+ *  Frame Reader component.  More info on the hardware can be found in
+ *  the Altera Video and Image Processing Suite User Guide at this address
+ *  http://www.altera.com/literature/ug/ug_vip.pdf.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#define PALETTE_SIZE	256
+#define DRIVER_NAME	"altvipfbii"
+
+/* control registers */
+#define ALTVIPFB_CONTROL		0
+#define ALTVIPFB_FRAMEINFO		20
+#define ALTVIPFB_FRAMEADDR		24
+
+struct altvipfb_type;
+
+struct altvipfb_dev {
+    struct platform_device *pdev;
+    struct fb_info info;
+    struct resource *reg_res;
+    void __iomem *base;
+    u32 pseudo_palette[PALETTE_SIZE];
+};
+
+static int altvipfb_setcolreg(unsigned regno, unsigned red, unsigned green,
+                              unsigned blue, unsigned transp, struct fb_info *info)
+{
+    /*
+     *  Set a single color register. The values supplied have a 32 bit
+     *  magnitude.
+     *  Return != 0 for invalid regno.
+     */
+
+    if (regno > 255)
+        return 1;
+
+    red >>= 8;
+    green >>= 8;
+    blue >>= 8;
+
+    if (regno < 255) {
+        ((u32 *)info->pseudo_palette)[regno] =
+        ((red & 255) << 16) | ((green & 255) << 8) | (blue & 255);
+    }
+
+    return 0;
+}
+
+static struct fb_ops altvipfb_ops = {
+    .owner = THIS_MODULE,
+    .fb_fillrect = cfb_fillrect,
+    .fb_copyarea = cfb_copyarea,
+    .fb_imageblit = cfb_imageblit,
+    .fb_setcolreg = altvipfb_setcolreg,
+};
+
+static void altvipfb_start_hw(struct altvipfb_dev *fbdev)
+{
+    writel(1, fbdev->base + ALTVIPFB_CONTROL);
+    writel((fbdev->info.var.xres & 0xFFF) | ((fbdev->info.var.yres & 0xFFF) << 13), fbdev->base + ALTVIPFB_FRAMEINFO);
+    writel(fbdev->info.fix.smem_start, fbdev->base + ALTVIPFB_FRAMEADDR);
+}
+
+static void altvipfb_disable_hw(struct altvipfb_dev *fbdev)
+{
+    /* set the control register to 0 to stop streaming */
+    writel(0, fbdev->base + ALTVIPFB_CONTROL);
+}
+
+static int altvipfb_setup_fb_info(struct altvipfb_dev *fbdev)
+{
+    struct fb_info *info = &fbdev->info;
+    struct device_node *np = fbdev->pdev->dev.of_node;
+
+    int ret;
+
+    //     u32 width = readl(fbdev->base + 0x80);
+    //     u32 height = readl(fbdev->base + 0x88);
+    //     info->var.xres = (((width>>12)&0xf)*1000) + (((width>>8)&0xf)*100) + (((width>>4)&0xf)*10) + (width&0xf);
+    //     info->var.yres = (((height>>12)&0xf)*1000) + (((height>>8)&0xf)*100) + (((height>>4)&0xf)*10) + (height&0xf);
+
+    ret = of_property_read_u32(np, "max-width", &fbdev->info.var.xres);
+    if (ret) {
+        dev_err(&fbdev->pdev->dev,
+                "Missing required parameter 'max-width'");
+        return ret;
+    }
+
+    ret = of_property_read_u32(np, "max-height", &fbdev->info.var.yres);
+    if (ret) {
+        dev_err(&fbdev->pdev->dev,
+                "Missing required parameter 'max-height'");
+        return ret;
+    }
+
+    strcpy(info->fix.id, DRIVER_NAME);
+    info->fix.type = FB_TYPE_PACKED_PIXELS;
+    info->fix.visual = FB_VISUAL_TRUECOLOR;
+    info->fix.accel = FB_ACCEL_NONE;
+
+    info->fbops = &altvipfb_ops;
+    info->var.activate = FB_ACTIVATE_NOW;
+    info->var.height = -1;
+    info->var.width = -1;
+    info->var.vmode = FB_VMODE_NONINTERLACED;
+
+    info->var.xres_virtual = info->var.xres,
+    info->var.yres_virtual = info->var.yres;
+    info->var.bits_per_pixel = 32;
+
+    dev_info(&fbdev->pdev->dev, "FB width = %u, FB height = %u\n", info->var.xres, info->var.yres);
+
+    /* settings for 32bit pixels */
+    info->var.red.offset = 16;
+    info->var.red.length = 8;
+    info->var.red.msb_right = 0;
+    info->var.green.offset = 8;
+    info->var.green.length = 8;
+    info->var.green.msb_right = 0;
+    info->var.blue.offset = 0;
+    info->var.blue.length = 8;
+    info->var.blue.msb_right = 0;
+
+    info->fix.line_length = (info->var.xres *
+    (info->var.bits_per_pixel >> 3));
+    info->fix.smem_len = info->fix.line_length * info->var.yres;
+
+    info->pseudo_palette = fbdev->pseudo_palette;
+    info->flags = FBINFO_FLAG_DEFAULT;
+
+    return 0;
+}
+
+static int altvipfb_probe(struct platform_device *pdev)
+{
+    int retval;
+    void *fbmem_virt;
+    struct altvipfb_dev *fbdev;
+
+    fbdev = devm_kzalloc(&pdev->dev, sizeof(*fbdev), GFP_KERNEL);
+    if (!fbdev)
+        return -ENOMEM;
+
+    fbdev->pdev = pdev;
+    fbdev->reg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!fbdev->reg_res)
+        return -ENODEV;
+
+    //     fbdev->base = devm_ioremap_resource(&pdev->dev, fbdev->reg_res);
+    //     if (IS_ERR(fbdev->base)) {
+    //         dev_err(&pdev->dev, "devm_ioremap_resource failed\n");
+    //         return PTR_ERR(fbdev->base);
+    //     }
+
+    retval = altvipfb_setup_fb_info(fbdev);
+
+    fbmem_virt = dma_alloc_coherent(NULL,
+                                    fbdev->info.fix.smem_len,
+                                    (void *)&(fbdev->info.fix.smem_start),
+                                    GFP_KERNEL);
+    if (!fbmem_virt) {
+        dev_err(&pdev->dev,
+                "altvipfb: unable to allocate %d Bytes fb memory\n",
+                fbdev->info.fix.smem_len);
+        return retval;
+    }
+
+    fbdev->info.screen_base = fbmem_virt;
+
+    retval = fb_alloc_cmap(&fbdev->info.cmap, PALETTE_SIZE, 0);
+    if (retval < 0)
+        goto err_dma_free;
+
+    platform_set_drvdata(pdev, fbdev);
+
+    fbdev->base = devm_ioremap_resource(&pdev->dev, fbdev->reg_res);
+    if (IS_ERR(fbdev->base)) {
+        dev_err(&pdev->dev, "devm_ioremap_resource failed\n");
+        retval = PTR_ERR(fbdev->base);
+        goto err_dealloc_cmap;
+    }
+
+    altvipfb_start_hw(fbdev);
+
+    retval = register_framebuffer(&fbdev->info);
+    if (retval < 0)
+        goto err_dealloc_cmap;
+
+    dev_info(&pdev->dev, "fb%d: %s frame buffer device at 0x%x+0x%x\n",
+             fbdev->info.node, fbdev->info.fix.id,
+             (unsigned)fbdev->info.fix.smem_start,
+             fbdev->info.fix.smem_len);
+
+    return 0;
+
+    err_dealloc_cmap:
+    fb_dealloc_cmap(&fbdev->info.cmap);
+    err_dma_free:
+    dma_free_coherent(NULL, fbdev->info.fix.smem_len, fbmem_virt,
+                      fbdev->info.fix.smem_start);
+    return retval;
+}
+
+static int altvipfb_remove(struct platform_device *dev)
+{
+    struct altvipfb_dev *fbdev = platform_get_drvdata(dev);
+
+    if (fbdev) {
+        unregister_framebuffer(&fbdev->info);
+        fb_dealloc_cmap(&fbdev->info.cmap);
+        dma_free_coherent(NULL, fbdev->info.fix.smem_len,
+                          fbdev->info.screen_base,
+                          fbdev->info.fix.smem_start);
+        altvipfb_disable_hw(fbdev);
+    }
+    return 0;
+}
+
+
+static struct of_device_id altvipfb_match[] = {
+    { .compatible = "altr,vip-frame-buffer-ii-2.0" },
+    {},
+};
+MODULE_DEVICE_TABLE(of, altvipfb_match);
+
+static struct platform_driver altvipfb_driver = {
+    .probe = altvipfb_probe,
+    .remove = altvipfb_remove,
+    .driver = {
+        .owner = THIS_MODULE,
+        .name = DRIVER_NAME,
+        .of_match_table = altvipfb_match,
+    },
+};
+module_platform_driver(altvipfb_driver);
+
+MODULE_DESCRIPTION("Altera VIP Frame Reader framebuffer driver");
+MODULE_AUTHOR("Chris Rauer <crauer@altera.com>");
+MODULE_LICENSE("GPL v2");
-- 
2.17.1


From ca4835c1d3ff31515598b5d263ba60241aee7bea Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sun, 8 Apr 2018 22:39:54 +0200
Subject: [PATCH 14/33] Add audio and midi drivers for holosynth and builtin
 audio codec on de1 board

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/Makefile                    |   1 +
 .../arm/boot/dts/socfpga_cyclone5_de1_soc.dts | 285 +++++++++++
 arch/arm/configs/socfpga_defconfig            |  64 ++-
 sound/soc/Kconfig                             |   3 +-
 sound/soc/Makefile                            |   1 +
 sound/soc/codecs/Kconfig                      |   5 +
 sound/soc/codecs/Makefile                     |   2 +
 sound/soc/codecs/hsynth7002.c                 | 115 +++++
 sound/soc/socsynth/Kconfig                    |  31 ++
 sound/soc/socsynth/Makefile                   |  11 +
 sound/soc/socsynth/de1-soc-wm8731-hsynth.c    | 458 ++++++++++++++++++
 sound/soc/socsynth/hsynth-midi.c              | 296 +++++++++++
 sound/soc/socsynth/hsynthdma.c                | 418 ++++++++++++++++
 sound/soc/socsynth/opencores_i2s.c            | 436 +++++++++++++++++
 14 files changed, 2122 insertions(+), 4 deletions(-)
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
 create mode 100644 sound/soc/codecs/hsynth7002.c
 create mode 100644 sound/soc/socsynth/Kconfig
 create mode 100644 sound/soc/socsynth/Makefile
 create mode 100644 sound/soc/socsynth/de1-soc-wm8731-hsynth.c
 create mode 100644 sound/soc/socsynth/hsynth-midi.c
 create mode 100644 sound/soc/socsynth/hsynthdma.c
 create mode 100644 sound/soc/socsynth/opencores_i2s.c

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 24fc153474bb..3ddb76dff383 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -703,6 +703,7 @@ dtb-$(CONFIG_ARCH_SOCFPGA) += \
 	socfpga_cyclone5_de10_nano_uio_fb.dtb \
 	socfpga_cyclone5_de10_nano_uio_fb_hd.dtb \
 	socfpga_cyclone5_de10_nano.dtb \
+	socfpga_cyclone5_de1_soc.dtb \
 	socfpga_cyclone5_sockit.dtb \
 	socfpga_cyclone5_socrates.dtb \
 	socfpga_cyclone5_sodia.dtb \
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
new file mode 100644
index 000000000000..d2b80e6d9044
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
@@ -0,0 +1,285 @@
+/*
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE1-SoC";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	sound {
+		compatible = "opencores,de1soc-wm8731-audio-midi";
+		i2s-controller = <&i2s>;
+		audio-codec = <&wm8731>;
+		i2c-mux-gpio = <&portb 19 0>;
+		dmalink-controller = <&dmalink>;
+		synth-codec = <&hsynth7002_codec>;
+	};
+
+	clk48: clk48 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <24576000>;
+		clock-output-names = "clk48";
+	};
+
+	clk44: clk44 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <33868800>;
+		clock-output-names = "clk44";
+	};
+
+	i2s: i2s@0x0 {
+		#sound-dai-cells = <1>;
+		compatible = "opencores,i2s";
+		reg = <0xff200000 0x20>, <0xff200040 0x20>;
+		clocks = <&clk44>, <&clk48>;
+		clock-names = "clk44", "clk48";
+		dmas = <&pdma 0>, <&pdma 1>, <&pdma 2>;
+		dma-names = "tx", "rx", "rx";
+	};
+
+	dmalink: dmalink@0x20 {
+		#sound-dai-cells = <1>;
+		compatible = "holotr,dmalink";
+		reg = <0xff200020 0x20>, <0xff200060 0x20>;
+		clocks = <&clk44>;
+		clock-names = "clk44";
+		dmas = <&pdma 2>;
+		dma-names = "rx";
+	};
+
+	hsynth7002_codec: hsynth7002-codec {
+	#sound-dai-cells = <0>;
+		compatible = "holotr,hsynth7002";
+/*     IOVDD-supply = <&supply>;*/
+		status = "okay";
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		bridge-enable = <1>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00020000 0xff220000 0x00000008>,
+			<0x00000001 0x00031000 0xff231000 0x00000080>,
+			<0x00000001 0x00010000 0xff210000 0x00000008>,
+			<0x00000001 0x000100c0 0xff2100c0 0x00000010>,
+			<0x00000001 0x00010080 0xff210080 0x00000010>,
+			<0x00000001 0x00010040 0xff210040 0x00000010>,
+			<0x00000001 0x00040000 0xff240000 0x00010000>,
+			<0x00000001 0x00050000 0xff250000 0x00010000>;
+
+		serial@0x100020000 {
+			compatible = "altr,juart-17.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00020000 0x00000008>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 40 4>;
+			clocks = <0x2>;
+		}; //end serial@0x100020000 (jtag_uart)
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-14.0";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <0x556>;
+			max-height = <0x300>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+
+		sysid@0x100010000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00010000 0x00000008>;
+			id = <2899645186>;
+			timestamp = <1524157570>;
+		};
+
+		gpio@0x1000100c0 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x000100c0 0x00000010>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 41 1>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <2>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			altr,interrupt-type = <2>;	/* embeddedsw.dts.params.altr,interrupt-type type NUMBER */
+			altr,interrupt_type = <2>;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
+			edge_type = <1>;	/* embeddedsw.dts.params.edge_type type NUMBER */
+			level_trigger = <0>;	/* embeddedsw.dts.params.level_trigger type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x1000100c0 (button_pio)
+
+		gpio@0x100010080 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00010080 0x00000010>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 42 1>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			altr,interrupt-type = <3>;	/* embeddedsw.dts.params.altr,interrupt-type type NUMBER */
+			altr,interrupt_type = <3>;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
+			edge_type = <2>;	/* embeddedsw.dts.params.edge_type type NUMBER */
+			level_trigger = <0>;	/* embeddedsw.dts.params.level_trigger type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x100010080 (dipsw_pio)
+
+		gpio@0x100010040 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00010040 0x00000010>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x100010040 (led_pio)
+
+		uio-socfpg0@0x100040000 {
+			compatible = "generic-uio,ui_pdrv";
+			reg = <0x00000001 0x00040000 0x00010000>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 43 4>;
+			address_width = <14>;
+			data_width = <32>;
+		};
+
+		socmidi@0x100050000 {
+			compatible = "holotr,socsynth-midi";
+			reg = <0x00000001 0x00050000 0x00010000>;
+			interrupt-parent = <0x2>;
+/*			interrupts = <0 44 4>;*/
+			address_width = <3>;   /* embeddedsw.dts.params.address_width type NUMBER */
+			data_width = <8>;      /* embeddedsw.dts.params.data_width type NUMBER */
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	wm8731: wm8731@34 {
+		#sound-dai-cells = <0>;
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+	};
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl345";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&i2c1 {
+	status = "okay";
+	speed-mode = <0>;
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index cb504b62a019..d090fe7cd7c5 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -280,7 +280,6 @@ CONFIG_FB_NOTIFY=y
 CONFIG_FB_CFB_FILLRECT=y
 CONFIG_FB_CFB_COPYAREA=y
 CONFIG_FB_CFB_IMAGEBLIT=y
-CONFIG_FB_ALTERA_VIP=y
 CONFIG_DUMMY_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
@@ -298,5 +297,64 @@ CONFIG_TOUCHSCREEN_USB_COMPOSITE=y
 CONFIG_HID=y
 CONFIG_USB_HID=y
 CONFIG_HID_MULTITOUCH=y
-#CONFIG_ALTERA_PR_IP_CORE=y
-#CONFIG_ALTERA_PR_IP_CORE_PLAT=y
+CONFIG_ALTERA_PR_IP_CORE=y
+CONFIG_ALTERA_PR_IP_CORE_PLAT=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+CONFIG_SND_SOC_SIGMADSP=m
+CONFIG_SND_SOC_SIGMADSP_I2C=m
+CONFIG_SND_SOC_SSM2602=m
+CONFIG_SND_SOC_SSM2602_I2C=m
+CONFIG_SND_ALOOP=m
+CONFIG_SND_VIRMIDI=m
+CONFIG_SND_SOC_DE1_WM8731_HSYNTH=m
+CONFIG_SND_SOC_HSYNTH_MIDI=m
+CONFIG_SND_SOC_PCM5102A=m
+CONFIG_FPGADMA=m
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_RAWMIDI=y
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+CONFIG_SND_SEQUENCER=y
+CONFIG_SND_SEQ_DUMMY=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_SND_VERBOSE_PRINTK=y
+CONFIG_SND_DEBUG=y
+CONFIG_SND_DEBUG_VERBOSE=y
+CONFIG_SND_DMA_SGBUF=y
+CONFIG_SND_DRIVERS=y
+CONFIG_SND_DUMMY=m
+CONFIG_SND_SERIAL_U16550=m
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_DESIGNWARE_CORE=y
+CONFIG_I2C_OCORES=y
+CONFIG_REGULATOR_DEBUG=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_SND_ARM=y
+CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM=y
+CONFIG_SND_ATMEL_SOC=m
+CONFIG_SND_DESIGNWARE_I2S=m
+CONFIG_SND_SOC_FSL_ASRC=m
+CONFIG_SND_SOC_FSL_SAI=m
+CONFIG_SND_SOC_FSL_SSI=m
+CONFIG_SND_SOC_FSL_SPDIF=m
+CONFIG_SND_SOC_FSL_ESAI=m
+CONFIG_SND_SOC_IMX_AUDMUX=m
+CONFIG_SND_SOC_I2C_AND_SPI=y
+CONFIG_HZ_1000=y
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 182d92efc7c8..48d18daab20e 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -13,7 +13,7 @@ menuconfig SND_SOC
 
 	  If you want ASoC support, you should say Y here and also to the
 	  specific driver for your SoC platform below.
-	  
+
 	  ASoC provides power efficient ALSA support for embedded battery powered
 	  SoC based systems like PDA's, Phones and Personal Media Players.
 
@@ -62,6 +62,7 @@ source "sound/soc/samsung/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/sirf/Kconfig"
 source "sound/soc/spear/Kconfig"
+source "sound/soc/socsynth/Kconfig"
 source "sound/soc/sti/Kconfig"
 source "sound/soc/sunxi/Kconfig"
 source "sound/soc/tegra/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 9a30f21d16ee..c802f476183f 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_SND_SOC)	+= samsung/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= sirf/
 obj-$(CONFIG_SND_SOC)	+= spear/
+obj-$(CONFIG_SND_SOC)	+= socsynth/
 obj-$(CONFIG_SND_SOC)	+= sti/
 obj-$(CONFIG_SND_SOC)	+= sunxi/
 obj-$(CONFIG_SND_SOC)	+= tegra/
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index c67667bb970f..49e8c241583d 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -72,6 +72,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_ES8328_I2C if I2C
 	select SND_SOC_GTM601
 	select SND_SOC_HDAC_HDMI
+	select SND_SOC_HSYNTH7002
 	select SND_SOC_ICS43432
 	select SND_SOC_INNO_RK3036
 	select SND_SOC_ISABELLE if I2C
@@ -512,6 +513,10 @@ config SND_SOC_HDMI_CODEC
 	select SND_PCM_IEC958
 	select HDMI
 
+config SND_SOC_HSYNTH7002
+	tristate "Dummy Soc synthesizer codec-driver driver"
+
+
 config SND_SOC_ES8328
 	tristate "Everest Semi ES8328 CODEC"
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 958cd4912fbc..be562a487dd2 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -66,6 +66,7 @@ snd-soc-es8328-i2c-objs := es8328-i2c.o
 snd-soc-es8328-spi-objs := es8328-spi.o
 snd-soc-gtm601-objs := gtm601.o
 snd-soc-hdac-hdmi-objs := hdac_hdmi.o
+snd-soc-hsynth7002-objs := hsynth7002.o
 snd-soc-ics43432-objs := ics43432.o
 snd-soc-inno-rk3036-objs := inno_rk3036.o
 snd-soc-isabelle-objs := isabelle.o
@@ -291,6 +292,7 @@ obj-$(CONFIG_SND_SOC_ES8328_I2C)+= snd-soc-es8328-i2c.o
 obj-$(CONFIG_SND_SOC_ES8328_SPI)+= snd-soc-es8328-spi.o
 obj-$(CONFIG_SND_SOC_GTM601)    += snd-soc-gtm601.o
 obj-$(CONFIG_SND_SOC_HDAC_HDMI) += snd-soc-hdac-hdmi.o
+obj-$(CONFIG_SND_SOC_HSYNTH7002)+= snd-soc-hsynth7002.o
 obj-$(CONFIG_SND_SOC_ICS43432)	+= snd-soc-ics43432.o
 obj-$(CONFIG_SND_SOC_INNO_RK3036)	+= snd-soc-inno-rk3036.o
 obj-$(CONFIG_SND_SOC_ISABELLE)	+= snd-soc-isabelle.o
diff --git a/sound/soc/codecs/hsynth7002.c b/sound/soc/codecs/hsynth7002.c
new file mode 100644
index 000000000000..b1898b3a5379
--- /dev/null
+++ b/sound/soc/codecs/hsynth7002.c
@@ -0,0 +1,115 @@
+/*
+ * HSYNTH7002 Soc Synthesizer dummy codec driver
+ *
+ * Copyright 2017 Holotronic
+ *  Michael Brown (the-snowwhite) <producer@holotronic.dk>
+ *  based on hsynth7002.c
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include <sound/soc.h>
+
+static const struct snd_soc_dapm_widget hsynth7002_widgets[] = {
+	SND_SOC_DAPM_INPUT("HSYNTH"),
+//	SND_SOC_DAPM_REGULATOR_SUPPLY("IOVDD", 0, 0),
+};
+
+static const struct snd_soc_dapm_route hsynth7002_routes[] = {
+	{ "Capture", NULL, "HSYNTH" },
+//	{ "Capture", NULL, "IOVDD" },
+};
+
+static int hsynth7002_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_DSP_A:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops hsynth7002_dai_ops = {
+	.set_fmt = hsynth7002_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver hsynth7002_dai = {
+	.name = "hsynth7002-hifi",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_96000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S18_3LE |
+			SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |
+			SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE,
+		.sig_bits = 20,
+	},
+	.ops = &hsynth7002_dai_ops,
+};
+
+static const struct snd_soc_codec_driver hsynth7002_codec_driver = {
+	.component_driver = {
+		.dapm_widgets = hsynth7002_widgets,
+		.num_dapm_widgets = ARRAY_SIZE(hsynth7002_widgets),
+		.dapm_routes = hsynth7002_routes,
+		.num_dapm_routes = ARRAY_SIZE(hsynth7002_routes),
+	},
+};
+
+static int hsynth7002_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &hsynth7002_codec_driver,
+			&hsynth7002_dai, 1);
+}
+
+static int hsynth7002_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+//#ifdef CONFIG_OF
+static const struct of_device_id hsynth7002_dt_ids[] = {
+	{ .compatible = "holotr,hsynth7002", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hsynth7002_dt_ids);
+//#endif
+
+static struct platform_driver hsynth7002_driver = {
+	.driver = {
+		.name = "hsynth7002",
+		.of_match_table	= of_match_ptr(hsynth7002_dt_ids),
+	},
+	.probe = hsynth7002_probe,
+	.remove = hsynth7002_remove,
+};
+module_platform_driver(hsynth7002_driver);
+
+MODULE_AUTHOR("Michael Brown <producer@holotronic.dk>");
+MODULE_DESCRIPTION("HSYNTH7002 Dummy Soc synthesizer codec-driver driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/socsynth/Kconfig b/sound/soc/socsynth/Kconfig
new file mode 100644
index 000000000000..83cc38697b9e
--- /dev/null
+++ b/sound/soc/socsynth/Kconfig
@@ -0,0 +1,31 @@
+config SND_SOC_OC_I2S
+       tristate "OpenCores I2S Controller"
+       help
+         If you say yes to this option, support will be included for the
+         OpenCores I2S controller. For details see
+
+         This driver can also be built as a module.  If so, the module
+         will be called opencores_i2s.
+
+config SND_SOC_HSYNTHDMA
+       tristate "holosynth DMA Controller"
+       help
+         If you say yes to this option, support will be included for the
+         HSYNTHDMA dma controller. For details see
+
+         This driver can also be built as a module.  If so, the module
+         will be called hsynthdma.
+
+config SND_SOC_DE1_WM8731_HSYNTH
+       tristate "DE1-Audio MIDI support"
+       select SND_SOC_WM8731
+       select SND_SOC_OC_I2S
+       select SND_SOC_GENERIC_DMAENGINE_PCM
+       select REGMAP_MMIO
+       select SND_SOC_HSYNTH7002
+       select SND_SOC_HSYNTHDMA
+
+config SND_SOC_HSYNTH_MIDI
+       tristate "Holosynth MIDI support"
+       select SND_RAWMIDI
+       select REGMAP_MMIO
diff --git a/sound/soc/socsynth/Makefile b/sound/soc/socsynth/Makefile
new file mode 100644
index 000000000000..aa55f564c844
--- /dev/null
+++ b/sound/soc/socsynth/Makefile
@@ -0,0 +1,11 @@
+snd-soc-opencores_i2s-objs := opencores_i2s.o
+obj-$(CONFIG_SND_SOC_OC_I2S) += snd-soc-opencores_i2s.o
+
+snd-de1-soc-wm8731-hsynth-objs := de1-soc-wm8731-hsynth.o
+obj-$(CONFIG_SND_SOC_DE1_WM8731_HSYNTH) += snd-de1-soc-wm8731-hsynth.o
+
+snd-soc-hsynthdma-objs := hsynthdma.o
+obj-$(CONFIG_SND_SOC_HSYNTHDMA) += snd-soc-hsynthdma.o
+
+snd-soc-hsynth-midi-objs := hsynth-midi.o
+obj-$(CONFIG_SND_SOC_HSYNTH_MIDI) += snd-soc-hsynth-midi.o
diff --git a/sound/soc/socsynth/de1-soc-wm8731-hsynth.c b/sound/soc/socsynth/de1-soc-wm8731-hsynth.c
new file mode 100644
index 000000000000..ba83a1120d6c
--- /dev/null
+++ b/sound/soc/socsynth/de1-soc-wm8731-hsynth.c
@@ -0,0 +1,458 @@
+/*
+* de1-soc-wm8731 -- SoC audio for Terasic DE1-SoC board
+* Author: B. Steinsbo <bsteinsbo@gmail.com>
+*
+* Based on sam9g20_wm8731 by
+* Sedji Gaouaou <sedji.gaouaou@atmel.com>
+*
+* Licensed under the GPL-2.
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/uaccess.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+// #include <sound/seq_kernel.h>
+// #include <sound/rawmidi.h>
+#include <sound/initval.h>
+
+// #define SOCSYNTHMIDI_LOG_PREFIX "socsynthmidi: "
+// #define midi_ins 0
+// #define midi_outs 1
+//
+// #define MIDIREG_BASE 0xff200000
+// #define MIDIREG_SIZE PAGE_SIZE
+// #define MIDIREG_OFFSET 0x50000
+
+#define WM8731_SYSCLK_XTAL 1
+#define WM8731_SYSCLK_MCLK 2
+#define MCLK_RATE_48K 12288000 /* fs*256 */
+#define MCLK_RATE_44K 16934400 /* fs*384 */
+
+// #define printe(...) pr_err(SOCSYNTHMIDI_LOG_PREFIX __VA_ARGS__)
+//
+// static int snd_socmidi_open(struct snd_rawmidi_substream *substream);
+// static int snd_socmidi_close(struct snd_rawmidi_substream *substream);
+// static int hmidi_card_probe(struct snd_soc_card *card);
+// static int hmidi_card_remove(struct snd_soc_card *card);
+// static void snd_socmidi_transmit(unsigned char data);
+// static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int);
+// static int hsound_midi_init(struct snd_card *card);
+//
+// void *midireg_mem;
+//
+// static int snd_socmidi_open(struct snd_rawmidi_substream *substream)
+// {
+//     return 0;
+// }
+//
+// static int snd_socmidi_close(struct snd_rawmidi_substream *substream)
+// {
+//     return 0;
+// }
+//
+// static int hmidi_card_probe(struct snd_soc_card *card)
+// {
+//     int err;
+//
+//     err = hsound_midi_init(card->snd_card);
+//
+//     if (err < 0) {
+//         //		dev_dbg(&pdev->dev,"hsound_midi_init failed: %d\n", err);
+//         return err;
+//     }
+//
+//     return 0;
+// }
+//
+// static int hmidi_card_remove(struct snd_soc_card *card)
+// {
+//     return 0;
+// }
+//
+// static void snd_socmidi_transmit(unsigned char data){
+//
+//     iowrite8(data, midireg_mem);
+//
+// }
+//
+// static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int up) {
+//
+//     if (!up)
+//         return;
+//
+//     while (1) {
+//         unsigned char data;
+//         if (snd_rawmidi_transmit(substream, &data, 1) != 1)
+//             break; /* no more data */
+//         snd_socmidi_transmit(data);
+//     }
+// }
+//
+// static struct snd_rawmidi *g_rmidi;
+//
+// static struct snd_rawmidi_ops snd_socmidi_output_ops = {
+//     .open = snd_socmidi_open,
+//     .close = snd_socmidi_close,
+//     .trigger = snd_socmidi_output_trigger,
+// };
+//
+// static void pisnd_get_port_info(struct snd_rawmidi *rmidi, int number, struct snd_seq_port_info *seq_port_info)
+// {
+//     seq_port_info->type =
+//     SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
+//     SNDRV_SEQ_PORT_TYPE_HARDWARE |
+//     SNDRV_SEQ_PORT_TYPE_PORT;
+//     seq_port_info->midi_voices = 0;
+// }
+//
+// static struct snd_rawmidi_global_ops hsnd_global_ops = {.get_port_info = pisnd_get_port_info, };
+//
+// static int hsound_midi_init(struct snd_card *card)
+// {
+//     int err;
+//     struct resource *res;
+//
+//     err = snd_rawmidi_new(card, "SocMIDI", 0, midi_outs, midi_ins, &g_rmidi);
+//
+//     if (err < 0) {
+//         printe("snd_rawmidi_new failed: %d\n", err);
+//         return err;
+//     }
+//
+//     strcpy(g_rmidi->name, "Holosynth MIDI ");
+//
+//     g_rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT;
+//     // rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
+//     //                     SNDRV_RAWMIDI_INFO_INPUT |
+//     //                     SNDRV_RAWMIDI_INFO_DUPLEX;
+//
+//     g_rmidi->ops = &hsnd_global_ops;
+//
+//     g_rmidi->private_data = (void *)0;
+//
+//     snd_rawmidi_set_ops(g_rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_socmidi_output_ops);
+//     //    snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_socmidi_input_ops);
+//
+//     res = request_mem_region((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE, "MIDIREG");
+//     if (res == NULL) {
+//         return -EBUSY;
+//     }
+//
+//     midireg_mem = ioremap((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE);
+//     if (midireg_mem == NULL) {
+//         release_mem_region(MIDIREG_BASE, MIDIREG_SIZE);
+//         return -EFAULT;
+//     }
+//
+//     return 0;
+// }
+
+static unsigned int i2c_mux_gpio;
+
+static int de1soc_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct device *dev = rtd->card->dev;
+    unsigned int mclk_freq;
+    int ret;
+
+    if ((params_rate(params) % 44100) == 0) {
+        mclk_freq = MCLK_RATE_44K;
+    } else if ((params_rate(params) % 48000) == 0) {
+        mclk_freq = MCLK_RATE_48K;
+    } else
+        return -EINVAL;
+
+    /* set codec mclk configuration */
+    ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+        mclk_freq, SND_SOC_CLOCK_OUT);
+    if (ret < 0)
+        return ret;
+
+    dev_dbg(dev, "hw_params: mclk_freq=%d\n", mclk_freq);
+    return 0;
+}
+
+static void de1soc_shutdown(struct snd_pcm_substream *substream)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct device *dev = rtd->card->dev;
+    int ret;
+
+    dev_dbg(dev, "shutdown\n");
+    ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+        0, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        dev_err(dev, "Failed to reset WM8731 SYSCLK: %d\n", ret);
+    }
+}
+
+static struct snd_soc_ops de1soc_ops = {
+    // .startup
+    .shutdown = de1soc_shutdown,
+    .hw_params = de1soc_hw_params,
+    // .hw_free
+    // .prepare
+    // .trigger
+};
+
+static const struct snd_soc_dapm_widget de1soc_dapm_widgets[] = {
+    SND_SOC_DAPM_HP("Headphone Jack", NULL),
+    SND_SOC_DAPM_MIC("Microphone Jack", NULL),
+    SND_SOC_DAPM_LINE("Line In Jack", NULL),
+    SND_SOC_DAPM_LINE("Line Out Jack", NULL),
+    SND_SOC_DAPM_LINE("Hsynth in", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+    {"MICIN", NULL, "Mic Bias"},
+    {"Mic Bias", NULL, "Microphone Jack"},
+    {"LLINEIN", NULL, "Line In Jack"},
+    {"RLINEIN", NULL, "Line In Jack"},
+    {"Line Out Jack", NULL, "LOUT"},
+    {"Line Out Jack", NULL, "ROUT"},
+    {"Headphone Jack", NULL, "LHPOUT"},
+    {"Headphone Jack", NULL, "RHPOUT"},
+    {"HSYNTH", NULL, "Hsynth in"},
+};
+
+static int de1soc_wm8731_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct device *dev = rtd->card->dev;
+    unsigned int fmt;
+    int ret;
+
+    dev_dbg(dev, "init\n");
+
+    fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+        SND_SOC_DAIFMT_CBS_CFS;
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    /* Don't let codec constraints interfere */
+    ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+        0, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        dev_err(dev, "Failed to set WM8731 SYSCLK: %d\n", ret);
+        return ret;
+    }
+
+    return 0;
+}
+
+static int soc_hsynth_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct device *dev = rtd->card->dev;
+    unsigned int fmt;
+    int ret;
+
+    dev_dbg(dev, "init\n");
+
+    fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+    SND_SOC_DAIFMT_CBS_CFS;
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    return 0;
+}
+
+static struct snd_soc_dai_link de1soc_dai[] = {
+	{ /* Primary DAI i/f */
+    .name = "SSND0",
+    .stream_name = "WM8731 PCM",
+    .cpu_dai_name = "ff200000.i2s",
+    .codec_dai_name = "wm8731-hifi",
+    .init = de1soc_wm8731_init,
+    .platform_name = "de1soc",
+    .codec_name = "wm8731.0-001a",
+    .ops = &de1soc_ops,
+	}, { /* Sec_Fifo Playback i/f */
+    .name = "SSND1",
+    .stream_name = "HSYNTH PCM",
+    .cpu_dai_name = "ff200000.dmalink",
+    .codec_dai_name = "hsynth7002-hifi",
+    .init = soc_hsynth_init,
+    .platform_name = "de1soc",
+    .codec_name = "hsynth7002.hsynth",
+	},
+};
+/*
+static struct snd_soc_dai_link hsynth_soc_dai = {
+    .name = "HSYNTH",
+    .stream_name = "HSYNTH PCM",
+    .cpu_dai_name = "ff200000.dmalink",
+    .codec_dai_name = "hsynth7002-hifi",
+    .init = soc_hsynth_init,
+    .platform_name = "de1soc",
+    .codec_name = "hsynth7002.hsynth",
+};
+*/
+static struct snd_soc_card snd_soc_de1soc = {
+    .name = "DE1SND",
+    .owner = THIS_MODULE,
+    .dai_link = de1soc_dai,
+//    .dai_link = &hsynth_soc_dai,
+    .num_links = ARRAY_SIZE(de1soc_dai),
+
+//     .probe        = hmidi_card_probe,
+//     .remove       = hmidi_card_remove,
+
+    .dapm_widgets = de1soc_dapm_widgets,
+    .num_dapm_widgets = ARRAY_SIZE(de1soc_dapm_widgets),
+    .dapm_routes = intercon,
+    .num_dapm_routes = ARRAY_SIZE(intercon),
+};
+
+static int de1soc_audio_probe(struct platform_device *pdev)
+{
+    struct device_node *np = pdev->dev.of_node;
+    struct device_node *codec_np, *cpu_np;
+    struct snd_soc_card *card = &snd_soc_de1soc;
+    int ret;
+
+    if (!np) {
+        return -ENODEV;
+    }
+
+    card->dev = &pdev->dev;
+
+    /* I2C bus is muxed between HPS and FPGA. Set mux to HPS */
+    i2c_mux_gpio = of_get_named_gpio(np, "i2c-mux-gpio", 0);
+    if (gpio_is_valid(i2c_mux_gpio)) {
+        ret = devm_gpio_request_one(&pdev->dev,
+            i2c_mux_gpio, GPIOF_OUT_INIT_LOW, "I2C_MUX");
+        if (ret) {
+            dev_err(&pdev->dev,
+                "Failed to request GPIO_%d for i2c_mux: %d\n",
+                i2c_mux_gpio, ret);
+            return ret;
+        }
+        gpio_set_value(i2c_mux_gpio, 1);
+    }
+
+    /* Parse codec1 info */
+    de1soc_dai[0].codec_name = NULL;
+    codec_np = of_parse_phandle(np, "audio-codec", 0);
+    if (!codec_np) {
+        dev_err(&pdev->dev, "audio-codec info missing\n");
+        return -EINVAL;
+    }
+    de1soc_dai[0].codec_of_node = codec_np;
+
+    /* Parse dai and platform info */
+    de1soc_dai[0].cpu_dai_name = NULL;
+    de1soc_dai[0].platform_name = NULL;
+    cpu_np = of_parse_phandle(np, "i2s-controller", 0);
+    if (!cpu_np) {
+        dev_err(&pdev->dev, "i2s dai1 and pcm info missing\n");
+        return -EINVAL;
+    }
+
+    de1soc_dai[0].cpu_of_node = cpu_np;
+    de1soc_dai[0].platform_of_node = cpu_np;
+
+    of_node_put(codec_np);
+    of_node_put(cpu_np);
+
+    /* Parse codec2 info */
+    de1soc_dai[1].codec_name = NULL;
+    codec_np = of_parse_phandle(np, "synth-codec", 0);
+    if (!codec_np) {
+        dev_err(&pdev->dev, "synth-codec info missing\n");
+        return -EINVAL;
+    }
+    de1soc_dai[1].codec_of_node = codec_np;
+
+    /* Parse dai and platform info */
+    de1soc_dai[1].cpu_dai_name = NULL;
+    de1soc_dai[1].platform_name = NULL;
+    cpu_np = of_parse_phandle(np, "dmalink-controller", 0);
+    if (!cpu_np) {
+        dev_err(&pdev->dev, "dmalink-controller info missing\n");
+        return -EINVAL;
+    }
+
+    de1soc_dai[1].cpu_of_node = cpu_np;
+    de1soc_dai[1].platform_of_node = cpu_np;
+
+    of_node_put(codec_np);
+    of_node_put(cpu_np);
+
+
+    ret = snd_soc_register_card(card);
+    if (ret) {
+        dev_err(&pdev->dev, "snd_soc_register_card() failed\n");
+    }
+
+    return ret;
+}
+
+static int de1soc_audio_remove(struct platform_device *pdev)
+{
+    struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+    if (gpio_is_valid(i2c_mux_gpio))
+        devm_gpio_free(&pdev->dev, i2c_mux_gpio);
+
+    snd_soc_unregister_card(card);
+
+    return 0;
+}
+
+static const struct of_device_id de1soc_wm8731_dt_ids[] = {
+    { .compatible = "opencores,de1soc-wm8731-audio-midi", },
+    { }
+};
+MODULE_DEVICE_TABLE(of, de1soc_wm8731_dt_ids);
+
+static struct platform_driver de1soc_audio_driver = {
+    .driver = {
+        .name	= "de1soc-audio",
+        .owner	= THIS_MODULE,
+        .of_match_table = of_match_ptr(de1soc_wm8731_dt_ids),
+    },
+    .probe	= de1soc_audio_probe,
+    .remove	= de1soc_audio_remove,
+};
+
+module_platform_driver(de1soc_audio_driver);
+
+/* Module information */
+MODULE_AUTHOR("Bjarne Steinsbo <bsteinsbo@gmail.com>");
+MODULE_DESCRIPTION("ALSA SoC DE1-SoC_WM8731");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/socsynth/hsynth-midi.c b/sound/soc/socsynth/hsynth-midi.c
new file mode 100644
index 000000000000..e226bd80cc41
--- /dev/null
+++ b/sound/soc/socsynth/hsynth-midi.c
@@ -0,0 +1,296 @@
+/*
+* hsynth-soc -- SoC audio ( midi for Altera SoC boards
+* Author: Michael Brown the-snowwhite <producer@holotronic.dk>
+*
+* Based on de1-soc-wm8731 by
+*  B. Steinsbo <bsteinsbo@gmail.com>
+*
+* Licensed under the GPL-2.
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/uaccess.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/seq_kernel.h>
+#include <sound/rawmidi.h>
+#include <sound/initval.h>
+// #include <sound/pcm.h>
+// #include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#define SYNTHSOCSOUND_LOG_PREFIX "synthsound: "
+
+#define midi_ins 0
+#define midi_outs 1
+
+#define MIDIREG_BASE 0xff200000
+#define MIDIREG_SIZE PAGE_SIZE
+#define MIDIREG_OFFSET 0x50000
+
+#define printe(...) pr_err(SYNTHSOCSOUND_LOG_PREFIX __VA_ARGS__)
+
+static int snd_socmidi_open(struct snd_rawmidi_substream *substream);
+static int snd_socmidi_close(struct snd_rawmidi_substream *substream);
+static int hmidi_card_probe(struct snd_soc_card *card);
+static int hmidi_card_remove(struct snd_soc_card *card);
+static void snd_socmidi_transmit(unsigned char data);
+static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int);
+static int hsound_midi_init(struct snd_card *card);
+
+void *midireg_mem;
+
+static int snd_socmidi_open(struct snd_rawmidi_substream *substream)
+{
+    return 0;
+}
+
+static int snd_socmidi_close(struct snd_rawmidi_substream *substream)
+{
+    return 0;
+}
+
+static int hmidi_card_probe(struct snd_soc_card *card)
+{
+    int err;
+
+    err = hsound_midi_init(card->snd_card);
+
+    if (err < 0) {
+//		dev_dbg(&pdev->dev,"hsound_midi_init failed: %d\n", err);
+        return err;
+    }
+
+    return 0;
+}
+
+static int hmidi_card_remove(struct snd_soc_card *card)
+{
+    return 0;
+}
+
+static void snd_socmidi_transmit(unsigned char data){
+
+    iowrite8(data, midireg_mem);
+
+}
+
+static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int up) {
+
+    if (!up)
+        return;
+
+    while (1) {
+        unsigned char data;
+        if (snd_rawmidi_transmit(substream, &data, 1) != 1)
+            break; /* no more data */
+        snd_socmidi_transmit(data);
+    }
+}
+
+static struct snd_rawmidi *g_rmidi;
+
+static struct snd_rawmidi_ops snd_socmidi_output_ops = {
+    .open = snd_socmidi_open,
+    .close = snd_socmidi_close,
+    .trigger = snd_socmidi_output_trigger,
+};
+
+static void pisnd_get_port_info(struct snd_rawmidi *rmidi, int number, struct snd_seq_port_info *seq_port_info)
+{
+    seq_port_info->type =
+        SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
+        SNDRV_SEQ_PORT_TYPE_HARDWARE |
+        SNDRV_SEQ_PORT_TYPE_PORT;
+    seq_port_info->midi_voices = 0;
+}
+
+static struct snd_rawmidi_global_ops hsnd_global_ops = {.get_port_info = pisnd_get_port_info, };
+
+static int hsound_midi_init(struct snd_card *card)
+{
+    int err;
+struct resource *res;
+
+    err = snd_rawmidi_new(card, "SocMIDI", 0, midi_outs, midi_ins, &g_rmidi);
+
+    if (err < 0) {
+        printe("snd_rawmidi_new failed: %d\n", err);
+        return err;
+    }
+
+    strcpy(g_rmidi->name, "Holosynth MIDI ");
+//	strcat(g_rmidi->name, pisnd_spi_get_serial());
+
+    g_rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT;
+    // rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
+    //                     SNDRV_RAWMIDI_INFO_INPUT |
+    //                     SNDRV_RAWMIDI_INFO_DUPLEX;
+
+    g_rmidi->ops = &hsnd_global_ops;
+
+    g_rmidi->private_data = (void *)0;
+
+    snd_rawmidi_set_ops(g_rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_socmidi_output_ops);
+//    snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_socmidi_input_ops);
+
+    res = request_mem_region((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE, "MIDIREG");
+    if (res == NULL) {
+        return -EBUSY;
+    }
+
+    midireg_mem = ioremap((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE);
+    if (midireg_mem == NULL) {
+        release_mem_region(MIDIREG_BASE, MIDIREG_SIZE);
+        return -EFAULT;
+    }
+
+    return 0;
+}
+
+/*
+static const struct snd_soc_dapm_widget soc_dapm_widgets[] = {
+    SND_SOC_DAPM_LINE("Hsynth in", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+    {"PDM_DAT", NULL, "Hsynth in"},
+//	{"Mic Bias", NULL, "Microphone Jack"},
+//	{"LLINEIN", NULL, "Line In Jack"},
+//	{"RLINEIN", NULL, "Line In Jack"},
+//	{"Line Out Jack", NULL, "LOUT"},
+//	{"Line Out Jack", NULL, "ROUT"},
+//	{"Headphone Jack", NULL, "LHPOUT"},
+//	{"Headphone Jack", NULL, "RHPOUT"},
+};
+
+static int soc_hsynth_init(struct snd_soc_pcm_runtime *rtd)
+{
+//	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct device *dev = rtd->card->dev;
+    unsigned int fmt;
+    int ret;
+
+    dev_dbg(dev, "init\n");
+
+    fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+        SND_SOC_DAIFMT_CBS_CFS;
+
+    // set cpu DAI configuration
+    ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+
+    return 0;
+}
+
+static struct snd_soc_dai_link hsynth_soc_dai = {
+    .name = "HSYNTH",
+    .stream_name = "HSYNTH PCM",
+    .cpu_dai_name = "ff200000.dmalink",
+    .codec_dai_name = "hsynth7002-hifi",
+    .init = soc_hsynth_init,
+    .platform_name = "socsynth",
+    .codec_name = "hsynth7002.hsynth",
+//	.ops = &hsynth_soc_ops,
+};
+*/
+static struct snd_soc_card snd_soc_hsynth_soc = {
+    .name = "HSYNTH-MIDI",
+    .owner = THIS_MODULE,
+//     .dai_link = &hsynth_soc_dai,
+//     .num_links = 1,
+
+    .probe        = hmidi_card_probe,
+    .remove       = hmidi_card_remove,
+
+//    .dapm_widgets = soc_dapm_widgets,
+//    .num_dapm_widgets = ARRAY_SIZE(soc_dapm_widgets),
+//    .dapm_routes = intercon,
+//    .num_dapm_routes = ARRAY_SIZE(intercon),
+};
+
+static int hsynth_soc_audio_probe(struct platform_device *pdev)
+{
+//         struct device_node *np = pdev->dev.of_node;
+//     struct device_node *codec_np, *cpu_np;
+    struct snd_soc_card *card = &snd_soc_hsynth_soc;
+    int ret;
+//
+//     if (!np) {
+//         return -ENODEV;
+//     }
+//
+    card->dev = &pdev->dev;
+//
+//
+//     /* Parse codec info */
+//     hsynth_soc_dai.codec_name = NULL;
+//     codec_np = of_parse_phandle(np, "audio-codec", 0);
+//     if (!codec_np) {
+//         dev_err(&pdev->dev, "codec info missing\n");
+//         return -EINVAL;
+//     }
+//     hsynth_soc_dai.codec_of_node = codec_np;
+//
+//     /* Parse dai and platform info */
+//     hsynth_soc_dai.cpu_dai_name = NULL;
+//     hsynth_soc_dai.platform_name = NULL;
+//     cpu_np = of_parse_phandle(np, "dmalink-controller", 0);
+//     if (!cpu_np) {
+//         dev_err(&pdev->dev, "dai and pcm info missing\n");
+//         return -EINVAL;
+//     }
+//     hsynth_soc_dai.cpu_of_node = cpu_np;
+//     hsynth_soc_dai.platform_of_node = cpu_np;
+//
+//     of_node_put(codec_np);
+//     of_node_put(cpu_np);
+//
+    ret = snd_soc_register_card(card);
+    if (ret) {
+        dev_err(&pdev->dev, "snd_soc_register_card() failed\n");
+    }
+
+    return ret;
+}
+
+static int soc_audio_remove(struct platform_device *pdev)
+{
+    struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+     snd_soc_unregister_card(card);
+
+    return 0;
+}
+
+static const struct of_device_id soc_hsynth_dt_ids[] = {
+    { .compatible = "holotr,socsynth-midi", },
+    { }
+};
+MODULE_DEVICE_TABLE(of, soc_hsynth_dt_ids);
+
+static struct platform_driver soc_audio_driver = {
+    .driver = {
+        .name	= "soc-synth-midi",
+        .owner	= THIS_MODULE,
+        .of_match_table = of_match_ptr(soc_hsynth_dt_ids),
+    },
+    .probe	= hsynth_soc_audio_probe,
+    .remove	= soc_audio_remove,
+};
+
+module_platform_driver(soc_audio_driver);
+
+/* Module information */
+MODULE_AUTHOR("Michael Brown (the-snowwhite) <producer@holotronic.dk>");
+MODULE_DESCRIPTION("ALSA SoC HSYNTH-MIDI");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/socsynth/hsynthdma.c b/sound/soc/socsynth/hsynthdma.c
new file mode 100644
index 000000000000..afb4850d98ed
--- /dev/null
+++ b/sound/soc/socsynth/hsynthdma.c
@@ -0,0 +1,418 @@
+/*
+* Copyright (C) 2017 Michael Brown (the-snowwhite) <producer@holotronic.dk>
+* Largely based on opencores_i2s.c by Bjarne Steinsbo <bsteinsbo@gmail.com>.
+*
+* Licensed under the GPL-2.
+*/
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+//#define DAC_FIFO_ADDR  0x00
+#define STATUS_ADDR    0x04
+#define CMD_ADDR       0x08
+#define ADC_FIFO_ADDR  0x00
+
+/* Commands to register at CMD_ADDR */
+#define PB_FIFO_CLEAR  BIT(0)
+#define PB_ENABLE      BIT(1)
+#define CAP_FIFO_CLEAR BIT(2)
+#define CAP_ENABLE     BIT(3)
+
+#define CLK_CTRL1      0x00
+#define CLK_CTRL2      0x04
+
+/* Bit-fields of clk control register 1 */
+#define CLK_MASTER_SLAVE  BIT(0)
+#define CLK_SEL_48_44    BIT(1)
+#define MCLK_DIV_SHIFT   (24)
+#define MCLK_DIV_MASK    GENMASK(MCLK_DIV_SHIFT + 7, MCLK_DIV_SHIFT)
+#define BCLK_DIV_SHIFT   (16)
+#define BCLK_DIV_MASK    GENMASK(BCLK_DIV_SHIFT + 7, BCLK_DIV_SHIFT)
+/* Bit-fields of clk control register 2 */
+#define PB_LRC_DIV_SHIFT  (8)
+#define PB_LRC_DIV_MASK          GENMASK(PB_LRC_DIV_SHIFT + 7, PB_LRC_DIV_SHIFT)
+#define CAP_LRC_DIV_SHIFT (0)
+#define CAP_LRC_DIV_MASK  GENMASK(CAP_LRC_DIV_SHIFT + 7, CAP_LRC_DIV_SHIFT)
+
+/* The frame size is not configurable */
+#define BITS_PER_FRAME 64
+
+struct holotr_dmalink {
+    struct regmap *regmap_data;
+    struct regmap *regmap_clk;
+//       struct clk *clk48;
+    struct clk *clk44;
+
+    struct snd_soc_dai_driver dai_driver;
+
+    struct snd_dmaengine_dai_dma_data capture_dma_data;
+//       struct snd_dmaengine_dai_dma_data playback_dma_data;
+
+    struct snd_ratnum ratnum;
+    struct snd_pcm_hw_constraint_ratnums rate_constraints;
+};
+
+static int holotr_dmalink_trigger(struct snd_pcm_substream *substream, int cmd,
+    struct snd_soc_dai *dai)
+{
+    struct holotr_dmalink *dmalink = snd_soc_dai_get_drvdata(dai);
+    unsigned int mask, val;
+
+    if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+            mask = CAP_ENABLE;
+    else
+            mask = PB_ENABLE;
+
+    switch (cmd) {
+    case SNDRV_PCM_TRIGGER_START:
+    case SNDRV_PCM_TRIGGER_RESUME:
+    case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+            val = mask;
+            break;
+    case SNDRV_PCM_TRIGGER_STOP:
+    case SNDRV_PCM_TRIGGER_SUSPEND:
+    case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+            val = 0;
+            break;
+    default:
+            return -EINVAL;
+    }
+
+    regmap_update_bits(dmalink->regmap_data, CMD_ADDR, mask, val);
+//     regmap_write(dmalink->regmap_data, CMD_ADDR, val);
+
+    dev_dbg(dai->dev, "trigger %x\n", val);
+    return 0;
+}
+
+static int divisor_value(unsigned long xtal_rate, unsigned long rate, int shift)
+{
+    return ((xtal_rate / rate / 2) >> shift) - 1;
+}
+
+static int holotr_dmalink_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+    struct holotr_dmalink *dmalink = snd_soc_dai_get_drvdata(dai);
+    unsigned long xtal_rate;
+    int lrclk_div;
+    int mclk_div;
+    int bclk_div;
+    int mask, val;
+    int mask2, val2;
+
+    dev_dbg(dai->dev, "hw_params fmt=0x%x\n", params_format(params));
+    dev_dbg(dai->dev, "hw_params rate=%d\n", params_rate(params));
+    if (params_format(params) != SNDRV_PCM_FORMAT_S32_LE)
+            return -EINVAL;
+
+    if ((params_rate(params) % 44100) == 0) {
+        val = CLK_SEL_48_44;
+        xtal_rate = clk_get_rate(dmalink->clk44);
+        mclk_div = divisor_value(xtal_rate, 16934400, 0); /* fs*384 at 44.1kHz */
+    }
+//    else if ((params_rate(params) % 48000) == 0) {
+//      val = 0;
+//      xtal_rate = clk_get_rate(dmalink->clk48);
+//      mclk_div = divisor_value(xtal_rate, 12288000, 0); /* fs*256 at 48kHz */
+//    }
+    else
+        return -EINVAL;
+
+    mask = CLK_SEL_48_44;
+    mask2 = 0;
+
+    lrclk_div = divisor_value(xtal_rate, params_rate(params), 4);
+    bclk_div = divisor_value(xtal_rate, params_rate(params) * BITS_PER_FRAME, 0);
+    dev_dbg(dai->dev, "hw_params mclk_div=%d\n", mclk_div);
+    dev_dbg(dai->dev, "hw_params lrclk_div=%d\n", lrclk_div);
+    dev_dbg(dai->dev, "hw_params bclk_div=%d\n", bclk_div);
+    val |= mclk_div << MCLK_DIV_SHIFT;
+    mask |= MCLK_DIV_MASK;
+    val |= bclk_div << BCLK_DIV_SHIFT;
+    mask |= BCLK_DIV_MASK;
+    regmap_update_bits(dmalink->regmap_clk, CLK_CTRL1, mask, val);
+    dev_dbg(dai->dev, "hw_params mask=0x%x val=0x%x\n", mask, val);
+    if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+        val2 = lrclk_div << CAP_LRC_DIV_SHIFT;
+        mask2 = CAP_LRC_DIV_MASK;
+    } else {
+        val2 = lrclk_div << PB_LRC_DIV_SHIFT;
+        mask2 = PB_LRC_DIV_MASK;
+    }
+    regmap_update_bits(dmalink->regmap_clk, CLK_CTRL2, mask2, val2);
+    dev_dbg(dai->dev, "hw_params mask2=0x%x val2=0x%x\n", mask2, val2);
+    return 0;
+}
+
+static int holotr_dmalink_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+    struct holotr_dmalink *dmalink = snd_soc_dai_get_drvdata(dai);
+    int val = 0;
+    dev_dbg(dai->dev, "set_fmt 0x%x\n", fmt);
+
+    if ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_I2S)
+        return -EINVAL;
+
+    if ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF)
+        return -EINVAL;
+
+    switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+    case SND_SOC_DAIFMT_CBM_CFM:
+        val = 0;
+        break;
+    case SND_SOC_DAIFMT_CBS_CFS:
+        val = 1;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    dev_dbg(dai->dev, "set_fmt master=%d\n", val);
+    regmap_update_bits(dmalink->regmap_clk, 0, CLK_MASTER_SLAVE, val);
+    return 0;
+}
+
+static int holotr_dmalink_sysclk(struct snd_soc_dai *dai, int clk_id,
+    unsigned int freq, int dir)
+{
+    struct holotr_dmalink *dmalink = snd_soc_dai_get_drvdata(dai);
+    int val = SND_SOC_CLOCK_IN ? 1 : 0;
+    dev_dbg(dai->dev, "sysclk id=%d freq=%d dir=%d\n", clk_id, freq, dir);
+    regmap_update_bits(dmalink->regmap_clk, 0, CLK_MASTER_SLAVE, val);
+    return 0;
+}
+
+static void holotr_dmalink_shutdown(struct snd_pcm_substream *substream,
+    struct snd_soc_dai *dai)
+{
+    struct holotr_dmalink *dmalink = snd_soc_dai_get_drvdata(dai);
+    int mask;
+    int val;
+    dev_dbg(dai->dev, "shutdown\n");
+
+    if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+        mask = CAP_ENABLE | CAP_FIFO_CLEAR;
+    else
+        mask = PB_ENABLE | PB_FIFO_CLEAR;
+
+    val = PB_FIFO_CLEAR | CAP_FIFO_CLEAR;
+    regmap_update_bits(dmalink->regmap_data, CMD_ADDR, mask, val);
+}
+
+static int holotr_dmalink_dai_probe(struct snd_soc_dai *dai)
+{
+    struct holotr_dmalink *dmalink = snd_soc_dai_get_drvdata(dai);
+
+    dev_dbg(dai->dev, "dai_probe\n");
+//       snd_soc_dai_init_dma_data(dai, &dmalink->playback_dma_data,
+    snd_soc_dai_init_dma_data(dai, NULL,
+    &dmalink->capture_dma_data);
+
+    return 0;
+}
+
+static const struct snd_soc_dai_ops holotr_dmalink_dai_ops = {
+    .set_sysclk = holotr_dmalink_sysclk,
+    .set_fmt = holotr_dmalink_set_fmt,
+    .shutdown = holotr_dmalink_shutdown,
+    .hw_params = holotr_dmalink_hw_params,
+    .trigger = holotr_dmalink_trigger,
+};
+
+static struct snd_soc_dai_driver holotr_dmalink_dai = {
+    .probe = holotr_dmalink_dai_probe,
+    .capture = {
+        .channels_min = 2,
+        .channels_max = 2,
+//      .rates = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000
+//      | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000
+//      | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000,
+        .rates = SNDRV_PCM_RATE_44100,
+        .formats = SNDRV_PCM_FMTBIT_S32_LE,
+    },
+    .ops = &holotr_dmalink_dai_ops,
+    .symmetric_rates = 1,
+};
+
+static const struct snd_soc_component_driver holotr_dmalink_component = {
+    .name = "holotr-dmalink",
+};
+
+static const struct regmap_config holotr_dmalink_regmap_data_config = {
+    .name = "holotr_dmalink.data",
+    .reg_bits = 32,
+    .reg_stride = 4,
+    .val_bits = 32,
+    .max_register = CMD_ADDR,
+};
+
+static const struct regmap_config holotr_dmalink_regmap_clk_config = {
+    .name = "holotr_dmalink.clk",
+    .reg_bits = 32,
+    .reg_stride = 4,
+    .val_bits = 32,
+    .max_register = CLK_CTRL2,
+};
+
+static int holotr_dmalink_probe(struct platform_device *pdev)
+{
+    struct resource *res, *res_clk;
+    struct holotr_dmalink *dmalink;
+    void __iomem *base;
+    int signature;
+    int ret;
+
+    dmalink = devm_kzalloc(&pdev->dev, sizeof(*dmalink), GFP_KERNEL);
+    if (!dmalink) {
+            dev_err(&pdev->dev, "Can't allocate holotr_dmalink\n");
+            return -ENOMEM;
+    }
+    platform_set_drvdata(pdev, dmalink);
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res) {
+            dev_err(&pdev->dev, "No memory resource\n");
+            return -ENODEV;
+    }
+    base = devm_ioremap_resource(&pdev->dev, res);
+    if (IS_ERR(base)) {
+            dev_err(&pdev->dev, "No ioremap resource\n");
+            return PTR_ERR(base);
+    }
+    printk(KERN_ALERT "holotr_dmalink at %08x\n", (int)base);
+
+    dmalink->regmap_data = devm_regmap_init_mmio(&pdev->dev, base,
+            &holotr_dmalink_regmap_data_config);
+    if (IS_ERR(dmalink->regmap_data)) {
+            dev_err(&pdev->dev, "No regmap_data\n");
+            return PTR_ERR(dmalink->regmap_data);
+    }
+
+    res_clk = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+    if (!res_clk) {
+            dev_err(&pdev->dev, "No memory resource\n");
+            return -ENODEV;
+    }
+    base = devm_ioremap_resource(&pdev->dev, res_clk);
+    if (IS_ERR(base)) {
+            dev_err(&pdev->dev, "No ioremap resource\n");
+            return PTR_ERR(base);
+    }
+
+    dmalink->regmap_clk = devm_regmap_init_mmio(&pdev->dev, base,
+            &holotr_dmalink_regmap_clk_config);
+    if (IS_ERR(dmalink->regmap_clk)) {
+            dev_err(&pdev->dev, "No regmap_clk\n");
+            return PTR_ERR(dmalink->regmap_clk);
+    }
+/*
+    dmalink->clk48 = devm_clk_get(&pdev->dev, "clk48");
+    if (IS_ERR(dmalink->clk48)) {
+            dev_err(&pdev->dev, "No clk48 clock\n");
+            return PTR_ERR(dmalink->clk48);
+    }
+
+    ret = clk_prepare_enable(dmalink->clk48);
+    if (ret) {
+            dev_err(&pdev->dev, "Cannot enable clock\n");
+            return ret;
+    }
+*/
+    dmalink->clk44 = devm_clk_get(&pdev->dev, "clk44");
+    if (IS_ERR(dmalink->clk44)) {
+            dev_err(&pdev->dev, "No clk44 clock\n");
+            return PTR_ERR(dmalink->clk44);
+    }
+
+    ret = clk_prepare_enable(dmalink->clk44);
+    if (ret) {
+            dev_err(&pdev->dev, "Cannot enable clock\n");
+            return ret;
+    }
+
+//       dmalink->playback_dma_data.addr = res->start + DAC_FIFO_ADDR;
+//       dmalink->playback_dma_data.addr_width = 4;
+//       dmalink->playback_dma_data.maxburst = 1;
+    //dmalink->playback_dma_data.maxburst = 2;
+//       dev_dbg(&pdev->dev, "probe playback dma addr : %8x\n",
+//       dmalink->playback_dma_data.addr);
+
+    dmalink->capture_dma_data.addr = res->start + ADC_FIFO_ADDR;
+    dmalink->capture_dma_data.addr_width = 4;
+    dmalink->capture_dma_data.maxburst = 1;
+    //dmalink->capture_dma_data.maxburst = 2;
+
+/*
+    dmalink->ratnum.num = clk_get_rate(dmalink->clk_ref) / 2 / BITS_PER_FRAME;
+    dmalink->ratnum.den_step = 1;
+    dmalink->ratnum.den_min = 1;
+    dmalink->ratnum.den_max = 64;
+
+    dmalink->rate_constraints.rats = &dmalink->ratnum;
+    dmalink->rate_constraints.nrats = 1;
+*/
+
+    regmap_write(dmalink->regmap_data, CMD_ADDR, PB_FIFO_CLEAR | CAP_FIFO_CLEAR);
+    ret = regmap_read(dmalink->regmap_data, STATUS_ADDR, &signature);
+    if (ret) {
+        dev_err(&pdev->dev, "Cannot read signature\n");
+        printk(KERN_ALERT "holotr_dmalink probe signature : %4x\n", signature);
+        goto err_clk_disable;
+    }
+    dev_dbg(&pdev->dev, "probe signature : %4x\n", signature);
+
+    ret = devm_snd_soc_register_component(&pdev->dev, &holotr_dmalink_component,
+                                        &holotr_dmalink_dai, 1);
+    if (ret) {
+        dev_err(&pdev->dev, "Cannot register component\n");
+        goto err_clk_disable;
+    }
+
+    ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+    if (ret) {
+        dev_err(&pdev->dev, "Cannot register dmaengine\n");
+        goto err_clk_disable;
+    }
+
+    dev_dbg(&pdev->dev, "probe finishing\n");
+    return ret;
+
+err_clk_disable:
+//       clk_disable_unprepare(dmalink->clk48);
+    clk_disable_unprepare(dmalink->clk44);
+    return ret;
+}
+
+static const struct of_device_id holotr_dmalink_of_match[] = {
+    { .compatible = "holotr,dmalink", },
+    {},
+};
+MODULE_DEVICE_TABLE(of, holotr_dmalink_of_match);
+
+static struct platform_driver holotr_dmalink_driver = {
+    .probe = holotr_dmalink_probe,
+    .driver = {
+        .name = "holotr-dmalink",
+//        .owner = THIS_MODULE,
+        .of_match_table = holotr_dmalink_of_match,
+    },
+};
+module_platform_driver(holotr_dmalink_driver);
+
+MODULE_AUTHOR("Michael Brown (the-snowwhite) <producer@holotronic.dk");
+MODULE_DESCRIPTION("DMA sound driver for soc at https://github.com/the-snowwhite");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/socsynth/opencores_i2s.c b/sound/soc/socsynth/opencores_i2s.c
new file mode 100644
index 000000000000..1f4268c7387f
--- /dev/null
+++ b/sound/soc/socsynth/opencores_i2s.c
@@ -0,0 +1,436 @@
+/*
+ * Copyright (C) 2014 Bjarne Steinsbo <bsteinsbo@gmail.com>
+ * Largely based on axi-i2s.c by Lars-Peter Clausen.
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+
+#define DAC_FIFO_ADDR	0x00
+#define STATUS_ADDR	0x04
+#define CMD_ADDR	0x08
+#define ADC_FIFO_ADDR	0x00
+
+/* Commands to register at CMD_ADDR */
+#define PB_FIFO_CLEAR	BIT(0)
+#define PB_ENABLE	BIT(1)
+#define CAP_FIFO_CLEAR	BIT(2)
+#define CAP_ENABLE	BIT(3)
+
+#define CLK_CTRL1	0x00
+#define CLK_CTRL2	0x04
+
+/* Bit-fields of clk control register 1 */
+#define CLK_MASTER_SLAVE  BIT(0)
+#define CLK_SEL_48_44	  BIT(1)
+#define MCLK_DIV_SHIFT	  (24)
+#define MCLK_DIV_MASK	  GENMASK(MCLK_DIV_SHIFT + 7, MCLK_DIV_SHIFT)
+#define BCLK_DIV_SHIFT	  (16)
+#define BCLK_DIV_MASK	  GENMASK(BCLK_DIV_SHIFT + 7, BCLK_DIV_SHIFT)
+/* Bit-fields of clk control register 2 */
+#define PB_LRC_DIV_SHIFT  (8)
+#define PB_LRC_DIV_MASK	  GENMASK(PB_LRC_DIV_SHIFT + 7, PB_LRC_DIV_SHIFT)
+#define CAP_LRC_DIV_SHIFT (0)
+#define CAP_LRC_DIV_MASK  GENMASK(CAP_LRC_DIV_SHIFT + 7, CAP_LRC_DIV_SHIFT)
+
+/* The frame size is not configurable */
+#define BITS_PER_FRAME 64
+
+struct opencores_i2s {
+	struct regmap *regmap_data;
+	struct regmap *regmap_clk;
+	struct clk *clk48;
+	struct clk *clk44;
+
+	struct snd_soc_dai_driver dai_driver;
+
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+
+	struct snd_ratnum ratnum;
+	struct snd_pcm_hw_constraint_ratnums rate_constraints;
+};
+
+static int opencores_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+	struct opencores_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	unsigned int mask, val;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		mask = CAP_ENABLE;
+	else
+		mask = PB_ENABLE;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		val = mask;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		val = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(i2s->regmap_data, CMD_ADDR, mask, val);
+//	regmap_write(i2s->regmap_data, CMD_ADDR, val);
+
+	dev_dbg(dai->dev, "trigger %x\n", val);
+	return 0;
+}
+
+static int divisor_value(unsigned long xtal_rate, unsigned long rate, int shift)
+{
+	return ((xtal_rate / rate / 2) >> shift) - 1;
+}
+
+static int opencores_i2s_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct opencores_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	unsigned long xtal_rate;
+	int lrclk_div;
+	int mclk_div;
+	int bclk_div;
+	int mask, val;
+	int mask2, val2;
+
+	dev_dbg(dai->dev, "hw_params fmt=0x%x\n", params_format(params));
+	dev_dbg(dai->dev, "hw_params rate=%d\n", params_rate(params));
+	if (params_format(params) != SNDRV_PCM_FORMAT_S32_LE)
+		return -EINVAL;
+
+	if ((params_rate(params) % 44100) == 0) {
+		val = CLK_SEL_48_44;
+		xtal_rate = clk_get_rate(i2s->clk44);
+		mclk_div = divisor_value(xtal_rate, 16934400, 0); /* fs*384 at 44.1kHz */
+	} else if ((params_rate(params) % 48000) == 0) {
+		val = 0;
+		xtal_rate = clk_get_rate(i2s->clk48);
+		mclk_div = divisor_value(xtal_rate, 12288000, 0); /* fs*256 at 48kHz */
+	} else
+		return -EINVAL;
+	mask = CLK_SEL_48_44;
+	mask2 = 0;
+
+	lrclk_div = divisor_value(xtal_rate, params_rate(params), 4);
+	bclk_div = divisor_value(xtal_rate, params_rate(params) * BITS_PER_FRAME, 0);
+	dev_dbg(dai->dev, "hw_params mclk_div=%d\n", mclk_div);
+	dev_dbg(dai->dev, "hw_params lrclk_div=%d\n", lrclk_div);
+	dev_dbg(dai->dev, "hw_params bclk_div=%d\n", bclk_div);
+	val |= mclk_div << MCLK_DIV_SHIFT;
+	mask |= MCLK_DIV_MASK;
+	val |= bclk_div << BCLK_DIV_SHIFT;
+	mask |= BCLK_DIV_MASK;
+	regmap_update_bits(i2s->regmap_clk, CLK_CTRL1, mask, val);
+	dev_dbg(dai->dev, "hw_params mask=0x%x val=0x%x\n", mask, val);
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		val2 = lrclk_div << CAP_LRC_DIV_SHIFT;
+		mask2 = CAP_LRC_DIV_MASK;
+	} else {
+		val2 = lrclk_div << PB_LRC_DIV_SHIFT;
+		mask2 = PB_LRC_DIV_MASK;
+	}
+	regmap_update_bits(i2s->regmap_clk, CLK_CTRL2, mask2, val2);
+	dev_dbg(dai->dev, "hw_params mask2=0x%x val2=0x%x\n", mask2, val2);
+	return 0;
+}
+
+static int opencores_i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct opencores_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	int val = 0;
+	dev_dbg(dai->dev, "set_fmt 0x%x\n", fmt);
+
+	if ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_I2S)
+		return -EINVAL;
+
+	if ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF)
+		return -EINVAL;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		val = 0;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		val = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dev_dbg(dai->dev, "set_fmt master=%d\n", val);
+	regmap_update_bits(i2s->regmap_clk, 0, CLK_MASTER_SLAVE, val);
+	return 0;
+}
+
+static int opencores_i2s_sysclk(struct snd_soc_dai *dai, int clk_id,
+	unsigned int freq, int dir)
+{
+	struct opencores_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	int val = SND_SOC_CLOCK_IN ? 1 : 0;
+	dev_dbg(dai->dev, "sysclk id=%d freq=%d dir=%d\n", clk_id, freq, dir);
+	regmap_update_bits(i2s->regmap_clk, 0, CLK_MASTER_SLAVE, val);
+	return 0;
+}
+
+static void opencores_i2s_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct opencores_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	int mask;
+	int val;
+	dev_dbg(dai->dev, "shutdown\n");
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		mask = CAP_ENABLE | CAP_FIFO_CLEAR;
+	else
+		mask = PB_ENABLE | PB_FIFO_CLEAR;
+	val = PB_FIFO_CLEAR | CAP_FIFO_CLEAR;
+	regmap_update_bits(i2s->regmap_data, CMD_ADDR, mask, val);
+}
+
+static int opencores_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	struct opencores_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(dai->dev, "dai_probe\n");
+	snd_soc_dai_init_dma_data(dai, &i2s->playback_dma_data,
+		&i2s->capture_dma_data);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops opencores_i2s_dai_ops = {
+	.set_sysclk = opencores_i2s_sysclk,
+	// .set_pll
+	//.set_clkdiv = opencores_i2s_set_clkdiv,
+	// .set_bclk_ratio
+        .set_fmt = opencores_i2s_set_fmt,
+        // .xlate_tdm_slot_mask
+        // .set_tdm_slot
+        // .set_channel_map
+        // .set_tristate
+
+        // .digital_mute
+        // .mute_stream
+
+	//.startup = opencores_i2s_startup,
+	.shutdown = opencores_i2s_shutdown,
+	.hw_params = opencores_i2s_hw_params,
+	// .hw_free
+	// .prepare
+	.trigger = opencores_i2s_trigger,
+	// .bespoke_trigger
+	// .delay
+};
+
+static struct snd_soc_dai_driver opencores_i2s_dai = {
+	.probe = opencores_i2s_dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000
+			| SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000
+			| SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000,
+		.formats = SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000
+			| SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000
+			| SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000,
+		.formats = SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &opencores_i2s_dai_ops,
+	.symmetric_rates = 1,
+};
+
+static const struct snd_soc_component_driver opencores_i2s_component = {
+	.name = "opencores-i2s",
+};
+
+static const struct regmap_config opencores_i2s_regmap_data_config = {
+	.name = "opencores_i2s.data",
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = CMD_ADDR,
+};
+
+static const struct regmap_config opencores_i2s_regmap_clk_config = {
+	.name = "opencores_i2s.clk",
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = CLK_CTRL2,
+};
+
+static int opencores_i2s_probe(struct platform_device *pdev)
+{
+	struct resource *res, *res_clk;
+	struct opencores_i2s *i2s;
+	void __iomem *base;
+	int signature;
+	int ret;
+
+	i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
+	if (!i2s) {
+		dev_err(&pdev->dev, "Can't allocate opencores_i2s\n");
+		return -ENOMEM;
+	}
+	platform_set_drvdata(pdev, i2s);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "No memory resource\n");
+		return -ENODEV;
+	}
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base)) {
+		dev_err(&pdev->dev, "No ioremap resource\n");
+		return PTR_ERR(base);
+	}
+	printk(KERN_ALERT "opencores_i2s at %08x\n", (int)base);
+
+	i2s->regmap_data = devm_regmap_init_mmio(&pdev->dev, base,
+		&opencores_i2s_regmap_data_config);
+	if (IS_ERR(i2s->regmap_data)) {
+		dev_err(&pdev->dev, "No regmap_data\n");
+		return PTR_ERR(i2s->regmap_data);
+	}
+
+	res_clk = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res_clk) {
+		dev_err(&pdev->dev, "No memory resource\n");
+		return -ENODEV;
+	}
+	base = devm_ioremap_resource(&pdev->dev, res_clk);
+	if (IS_ERR(base)) {
+		dev_err(&pdev->dev, "No ioremap resource\n");
+		return PTR_ERR(base);
+	}
+
+	i2s->regmap_clk = devm_regmap_init_mmio(&pdev->dev, base,
+		&opencores_i2s_regmap_clk_config);
+	if (IS_ERR(i2s->regmap_clk)) {
+		dev_err(&pdev->dev, "No regmap_clk\n");
+		return PTR_ERR(i2s->regmap_clk);
+	}
+
+	i2s->clk48 = devm_clk_get(&pdev->dev, "clk48");
+	if (IS_ERR(i2s->clk48)) {
+		dev_err(&pdev->dev, "No clk48 clock\n");
+		return PTR_ERR(i2s->clk48);
+	}
+
+	ret = clk_prepare_enable(i2s->clk48);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot enable clock\n");
+		return ret;
+	}
+
+	i2s->clk44 = devm_clk_get(&pdev->dev, "clk44");
+	if (IS_ERR(i2s->clk44)) {
+		dev_err(&pdev->dev, "No clk44 clock\n");
+		return PTR_ERR(i2s->clk44);
+	}
+
+	ret = clk_prepare_enable(i2s->clk44);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot enable clock\n");
+		return ret;
+	}
+
+	i2s->playback_dma_data.addr = res->start + DAC_FIFO_ADDR;
+	i2s->playback_dma_data.addr_width = 4;
+	i2s->playback_dma_data.maxburst = 1;
+	//i2s->playback_dma_data.maxburst = 2;
+	dev_dbg(&pdev->dev, "probe playback dma addr : %8x\n",
+		i2s->playback_dma_data.addr);
+
+	i2s->capture_dma_data.addr = res->start + ADC_FIFO_ADDR;
+	i2s->capture_dma_data.addr_width = 4;
+	i2s->capture_dma_data.maxburst = 1;
+	//i2s->capture_dma_data.maxburst = 2;
+
+/*
+	i2s->ratnum.num = clk_get_rate(i2s->clk_ref) / 2 / BITS_PER_FRAME;
+	i2s->ratnum.den_step = 1;
+	i2s->ratnum.den_min = 1;
+	i2s->ratnum.den_max = 64;
+
+	i2s->rate_constraints.rats = &i2s->ratnum;
+	i2s->rate_constraints.nrats = 1;
+*/
+
+	regmap_write(i2s->regmap_data, CMD_ADDR, PB_FIFO_CLEAR | CAP_FIFO_CLEAR);
+	ret = regmap_read(i2s->regmap_data, STATUS_ADDR, &signature);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot read signature\n");
+		printk(KERN_ALERT "opencores_i2s probe signature : %4x\n", signature);
+		goto err_clk_disable;
+	}
+	dev_dbg(&pdev->dev, "probe signature : %4x\n", signature);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &opencores_i2s_component,
+					 &opencores_i2s_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot register component\n");
+		goto err_clk_disable;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot register dmaengine\n");
+		goto err_clk_disable;
+	}
+
+	dev_dbg(&pdev->dev, "probe finishing\n");
+	return ret;
+
+err_clk_disable:
+	clk_disable_unprepare(i2s->clk48);
+	clk_disable_unprepare(i2s->clk44);
+	return ret;
+}
+
+static const struct of_device_id opencores_i2s_of_match[] = {
+	{ .compatible = "opencores,i2s", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, opencores_i2s_of_match);
+
+static struct platform_driver opencores_i2s_driver = {
+	.driver = {
+		.name = "opencores-i2s",
+		.owner = THIS_MODULE,
+		.of_match_table = opencores_i2s_of_match,
+	},
+	.probe = opencores_i2s_probe,
+};
+module_platform_driver(opencores_i2s_driver);
+
+MODULE_AUTHOR("Bjarne Steinsbo <bsteinsbo@gmail.com>");
+MODULE_DESCRIPTION("I2S driver for core at https://github.com/bsteinsbo/i2s.git");
+MODULE_LICENSE("GPL");
-- 
2.17.1


From 409f0b04555861a5af789a6435a58bf03573a46e Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Thu, 17 May 2018 10:58:21 +0200
Subject: [PATCH 15/33] Add Hsynth audio driver with Phat(pcm5102) audio output
 Add vipii fb,pidac/hsynth audio dtb for DE10 Nano HD HDMI

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/Makefile                    |   1 +
 ...pga_cyclone5_de10_nano_uio_aud_fbii_hd.dts | 261 +++++++++++
 arch/arm/configs/socfpga_defconfig            |   1 +
 sound/soc/codecs/Kconfig                      |   5 +-
 sound/soc/codecs/Makefile                     |   2 +
 sound/soc/codecs/hsynthpcm5102.c              | 124 +++++
 sound/soc/socsynth/Kconfig                    |   7 +-
 sound/soc/socsynth/Makefile                   |   3 +
 sound/soc/socsynth/pcm5102-hsynth.c           | 438 ++++++++++++++++++
 9 files changed, 840 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
 create mode 100644 sound/soc/codecs/hsynthpcm5102.c
 create mode 100644 sound/soc/socsynth/pcm5102-hsynth.c

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 3ddb76dff383..b80aa1c22d5d 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -702,6 +702,7 @@ dtb-$(CONFIG_ARCH_SOCFPGA) += \
 	socfpga_cyclone5_de0_sockit.dtb \
 	socfpga_cyclone5_de10_nano_uio_fb.dtb \
 	socfpga_cyclone5_de10_nano_uio_fb_hd.dtb \
+	socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dtb \
 	socfpga_cyclone5_de10_nano.dtb \
 	socfpga_cyclone5_de1_soc.dtb \
 	socfpga_cyclone5_sockit.dtb \
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
new file mode 100644
index 000000000000..7e1acf94ba6b
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
@@ -0,0 +1,261 @@
+/*
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE10-Nano";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	sound {
+		compatible = "opencores,hsynthpcm5102-audio";
+		i2s-controller = <&i2s>;
+		audio-codec = <&hsynthpcm5102_codec>;
+	};
+
+	clk48: clk48 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <24576000>;
+		clock-output-names = "clk48";
+	};
+
+	clk44: clk44 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <33868800>;
+		clock-output-names = "clk44";
+	};
+
+	i2s: i2s@0x0 {
+		#sound-dai-cells = <1>;
+		compatible = "opencores,i2s";
+		reg = <0xff200000 0x20>, <0xff200020 0x20>;
+		clocks = <&clk44>, <&clk48>;
+		clock-names = "clk44", "clk48";
+		dmas = <&pdma 0>, <&pdma 1>;
+		dma-names = "tx", "rx";
+	};
+
+	hsynthpcm5102_codec: hsynthpcm5102-codec {
+	#sound-dai-cells = <0>;
+		compatible = "holotr,hsynthpcm5102";
+		status = "okay";
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+				<0x00000001 0x00002000 0xff202000 0x00000008>,
+				<0x00000001 0x00003000 0xff203000 0x00000010>,
+				<0x00000001 0x00004000 0xff204000 0x00000010>,
+				<0x00000001 0x00005000 0xff205000 0x00000010>,
+				<0x00000001 0x00030000 0xff230000 0x00000100>,
+				<0x00000001 0x00031000 0xff231000 0x00000080>,
+				<0x00000001 0x00040000 0xff240000 0x00010000>,
+				<0x00000001 0x00050000 0xff250000 0x00010000>;
+
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <0xacd51302>;
+			timestamp = <0x5929e204>;
+		};
+
+		serial@0x100002000 {
+			compatible = "altr,juart-15.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00002000 0x00000008>;
+			interrupt-parent = <0x3>;
+			interrupts = <0x0 0x2a 0x4>;
+			clocks = <0x2>;
+		};
+
+		gpio@0x100003000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00003000 0x00000010>;
+			altr,gpio-bank-width = <0x8>;
+			resetvalue = <0xff>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100004000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00004000 0x00000010>;
+			altr,gpio-bank-width = <0x4>;
+			altr,interrupt-type = <0x3>;
+			altr,interrupt_type = <0x3>;
+			edge_type = <0x2>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100005000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00005000 0x00000010>;
+			altr,gpio-bank-width = <0x2>;
+			altr,interrupt-type = <0x2>;
+			altr,interrupt_type = <0x2>;
+			edge_type = <0x1>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		ilc@0x100030000 {
+			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
+			reg = <0x00000001 0x00030000 0x00000100>;
+			interrupt-controller;
+			#interrupt-cells = <0x1>;
+			altr,sw-fifo-depth = <0x20>;
+		};
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-buffer-ii-2.0";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <1920>;
+			max-height = <1080>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+
+		uio-socfpg0@0x100040000 {
+			compatible = "generic-uio,ui_pdrv";
+			reg = <0x00000001 0x00040000 0x00010000>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 43 1>;
+			address_width = <14>;
+			data_width = <32>;
+		};
+
+		socmidi@0x100050000 {
+			compatible = "holotr,socsynth-midi";
+			reg = <0x00000001 0x00050000 0x00010000>;
+			interrupt-parent = <0x2>;
+/*			interrupts = <0 44 4>;*/
+			address_width = <3>;   /* embeddedsw.dts.params.address_width type NUMBER */
+			data_width = <8>;      /* embeddedsw.dts.params.data_width type NUMBER */
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl34x";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index d090fe7cd7c5..25f92bd18920 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -311,6 +311,7 @@ CONFIG_SND_VIRMIDI=m
 CONFIG_SND_SOC_DE1_WM8731_HSYNTH=m
 CONFIG_SND_SOC_HSYNTH_MIDI=m
 CONFIG_SND_SOC_PCM5102A=m
+CONFIG_SND_SOC_PCM5102_HSYNTH=m
 CONFIG_FPGADMA=m
 CONFIG_REGMAP_I2C=y
 CONFIG_REGMAP_SPI=y
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 49e8c241583d..616211318a2d 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -73,6 +73,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_GTM601
 	select SND_SOC_HDAC_HDMI
 	select SND_SOC_HSYNTH7002
+	select SND_SOC_HSYNTHPCM5102
 	select SND_SOC_ICS43432
 	select SND_SOC_INNO_RK3036
 	select SND_SOC_ISABELLE if I2C
@@ -514,8 +515,10 @@ config SND_SOC_HDMI_CODEC
 	select HDMI
 
 config SND_SOC_HSYNTH7002
-	tristate "Dummy Soc synthesizer codec-driver driver"
+	tristate "Dummy Soc synthesizer codec-driver"
 
+config SND_SOC_HSYNTHPCM5102
+	tristate "Pihat Hsynth Soc synthesizer codec-driver"
 
 config SND_SOC_ES8328
 	tristate "Everest Semi ES8328 CODEC"
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index be562a487dd2..2c4c3f5d7cb1 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -67,6 +67,7 @@ snd-soc-es8328-spi-objs := es8328-spi.o
 snd-soc-gtm601-objs := gtm601.o
 snd-soc-hdac-hdmi-objs := hdac_hdmi.o
 snd-soc-hsynth7002-objs := hsynth7002.o
+snd-soc-hsynthpcm5102-objs := hsynthpcm5102.o
 snd-soc-ics43432-objs := ics43432.o
 snd-soc-inno-rk3036-objs := inno_rk3036.o
 snd-soc-isabelle-objs := isabelle.o
@@ -293,6 +294,7 @@ obj-$(CONFIG_SND_SOC_ES8328_SPI)+= snd-soc-es8328-spi.o
 obj-$(CONFIG_SND_SOC_GTM601)    += snd-soc-gtm601.o
 obj-$(CONFIG_SND_SOC_HDAC_HDMI) += snd-soc-hdac-hdmi.o
 obj-$(CONFIG_SND_SOC_HSYNTH7002)+= snd-soc-hsynth7002.o
+obj-$(CONFIG_SND_SOC_HSYNTHPCM5102)+= snd-soc-hsynthpcm5102.o
 obj-$(CONFIG_SND_SOC_ICS43432)	+= snd-soc-ics43432.o
 obj-$(CONFIG_SND_SOC_INNO_RK3036)	+= snd-soc-inno-rk3036.o
 obj-$(CONFIG_SND_SOC_ISABELLE)	+= snd-soc-isabelle.o
diff --git a/sound/soc/codecs/hsynthpcm5102.c b/sound/soc/codecs/hsynthpcm5102.c
new file mode 100644
index 000000000000..dd97160ac437
--- /dev/null
+++ b/sound/soc/codecs/hsynthpcm5102.c
@@ -0,0 +1,124 @@
+/*
+* HSYNTH7002 Soc Synthesizer dummy codec driver
+*
+* Copyright 2017 Holotronic
+*  Michael Brown (the-snowwhite) <producer@holotronic.dk>
+*  based on hsynth7002.c
+*
+* Licensed under the GPL-2.
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include <sound/soc.h>
+
+static const struct snd_soc_dapm_widget hsynthpcm5102_widgets[] = {
+    SND_SOC_DAPM_OUTPUT("PCMOUT"),
+    SND_SOC_DAPM_INPUT("HSYNTH"),
+};
+
+static const struct snd_soc_dapm_route hsynthpcm5102_routes[] = {
+	{ "Playback", NULL, "PCMOUT" },
+    { "Capture", NULL, "HSYNTH" },
+};
+
+static int hsynthpcm5102_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+    switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+    case SND_SOC_DAIFMT_CBS_CFS:
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+    case SND_SOC_DAIFMT_NB_NF:
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_I2S:
+    case SND_SOC_DAIFMT_DSP_A:
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static const struct snd_soc_dai_ops hsynthpcm5102_dai_ops = {
+    .set_fmt = hsynthpcm5102_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver hsynthpcm5102_dai = {
+    .name = "hsynthpcm5102-hifi",
+    .playback = {
+        .stream_name = "Playback",
+        .channels_min = 2,
+        .channels_max = 2,
+        .rates = SNDRV_PCM_RATE_8000_192000,
+        .formats = SNDRV_PCM_FMTBIT_S16_LE |
+            SNDRV_PCM_FMTBIT_S24_LE |
+            SNDRV_PCM_FMTBIT_S32_LE,
+    },
+    .capture = {
+        .stream_name = "Capture",
+        .channels_min = 2,
+        .channels_max = 2,
+        .rates = SNDRV_PCM_RATE_8000_192000,
+        .formats = SNDRV_PCM_FMTBIT_S16_LE |
+            SNDRV_PCM_FMTBIT_S24_LE |
+            SNDRV_PCM_FMTBIT_S32_LE,
+        .sig_bits = 20,
+    },
+    .ops = &hsynthpcm5102_dai_ops,
+};
+
+static const struct snd_soc_codec_driver hsynthpcm5102_codec_driver = {
+    .component_driver = {
+        .dapm_widgets = hsynthpcm5102_widgets,
+        .num_dapm_widgets = ARRAY_SIZE(hsynthpcm5102_widgets),
+        .dapm_routes = hsynthpcm5102_routes,
+        .num_dapm_routes = ARRAY_SIZE(hsynthpcm5102_routes),
+    },
+};
+
+static int hsynthpcm5102_probe(struct platform_device *pdev)
+{
+    return snd_soc_register_codec(&pdev->dev, &hsynthpcm5102_codec_driver,
+            &hsynthpcm5102_dai, 1);
+}
+
+static int hsynthpcm5102_remove(struct platform_device *pdev)
+{
+    snd_soc_unregister_codec(&pdev->dev);
+    return 0;
+}
+
+//#ifdef CONFIG_OF
+static const struct of_device_id hsynthpcm5102_dt_ids[] = {
+    { .compatible = "holotr,hsynthpcm5102", },
+    { }
+};
+MODULE_DEVICE_TABLE(of, hsynthpcm5102_dt_ids);
+//#endif
+
+static struct platform_driver hsynthpcm5102_driver = {
+    .driver = {
+        .name = "hsynthpcm5102",
+        .of_match_table	= of_match_ptr(hsynthpcm5102_dt_ids),
+    },
+    .probe = hsynthpcm5102_probe,
+    .remove = hsynthpcm5102_remove,
+};
+module_platform_driver(hsynthpcm5102_driver);
+
+MODULE_AUTHOR("Michael Brown <producer@holotronic.dk>");
+MODULE_DESCRIPTION("HSYNTH7002 Dummy Soc synthesizer codec-driver driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/socsynth/Kconfig b/sound/soc/socsynth/Kconfig
index 83cc38697b9e..5d71a4ee1f62 100644
--- a/sound/soc/socsynth/Kconfig
+++ b/sound/soc/socsynth/Kconfig
@@ -27,5 +27,10 @@ config SND_SOC_DE1_WM8731_HSYNTH
 
 config SND_SOC_HSYNTH_MIDI
        tristate "Holosynth MIDI support"
-       select SND_RAWMIDI
+
+config SND_SOC_PCM5102_HSYNTH
+       tristate "DE10-Nano-PiDac/Holosynth audio support"
+       select SND_SOC_HSYNTHPCM5102
+       select SND_SOC_OC_I2S
+       select SND_SOC_GENERIC_DMAENGINE_PCM
        select REGMAP_MMIO
diff --git a/sound/soc/socsynth/Makefile b/sound/soc/socsynth/Makefile
index aa55f564c844..2043f43d0400 100644
--- a/sound/soc/socsynth/Makefile
+++ b/sound/soc/socsynth/Makefile
@@ -9,3 +9,6 @@ obj-$(CONFIG_SND_SOC_HSYNTHDMA) += snd-soc-hsynthdma.o
 
 snd-soc-hsynth-midi-objs := hsynth-midi.o
 obj-$(CONFIG_SND_SOC_HSYNTH_MIDI) += snd-soc-hsynth-midi.o
+
+snd-pcm5102-hsynth-objs := pcm5102-hsynth.o
+obj-$(CONFIG_SND_SOC_PCM5102_HSYNTH) += snd-pcm5102-hsynth.o
diff --git a/sound/soc/socsynth/pcm5102-hsynth.c b/sound/soc/socsynth/pcm5102-hsynth.c
new file mode 100644
index 000000000000..2d56f0b83f5a
--- /dev/null
+++ b/sound/soc/socsynth/pcm5102-hsynth.c
@@ -0,0 +1,438 @@
+/*
+* de1-soc-wm8731 -- SoC audio for Terasic DE1-SoC board
+* Author: B. Steinsbo <bsteinsbo@gmail.com>
+*
+* Based on sam9g20_wm8731 by
+* Sedji Gaouaou <sedji.gaouaou@atmel.com>
+*
+* Licensed under the GPL-2.
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/uaccess.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+// #include <sound/seq_kernel.h>
+// #include <sound/rawmidi.h>
+#include <sound/initval.h>
+
+// #define SOCSYNTHMIDI_LOG_PREFIX "socsynthmidi: "
+// #define midi_ins 0
+// #define midi_outs 1
+//
+// #define MIDIREG_BASE 0xff200000
+// #define MIDIREG_SIZE PAGE_SIZE
+// #define MIDIREG_OFFSET 0x50000
+
+//#define WM8731_SYSCLK_XTAL 1
+//#define WM8731_SYSCLK_MCLK 2
+#define MCLK_RATE_48K 12288000 /* fs*256 */
+#define MCLK_RATE_44K 16934400 /* fs*384 */
+
+// #define printe(...) pr_err(SOCSYNTHMIDI_LOG_PREFIX __VA_ARGS__)
+//
+// static int snd_socmidi_open(struct snd_rawmidi_substream *substream);
+// static int snd_socmidi_close(struct snd_rawmidi_substream *substream);
+// static int hmidi_card_probe(struct snd_soc_card *card);
+// static int hmidi_card_remove(struct snd_soc_card *card);
+// static void snd_socmidi_transmit(unsigned char data);
+// static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int);
+// static int hsound_midi_init(struct snd_card *card);
+//
+// void *midireg_mem;
+//
+// static int snd_socmidi_open(struct snd_rawmidi_substream *substream)
+// {
+//     return 0;
+// }
+//
+// static int snd_socmidi_close(struct snd_rawmidi_substream *substream)
+// {
+//     return 0;
+// }
+//
+// static int hmidi_card_probe(struct snd_soc_card *card)
+// {
+//     int err;
+//
+//     err = hsound_midi_init(card->snd_card);
+//
+//     if (err < 0) {
+//         //		dev_dbg(&pdev->dev,"hsound_midi_init failed: %d\n", err);
+//         return err;
+//     }
+//
+//     return 0;
+// }
+//
+// static int hmidi_card_remove(struct snd_soc_card *card)
+// {
+//     return 0;
+// }
+//
+// static void snd_socmidi_transmit(unsigned char data){
+//
+//     iowrite8(data, midireg_mem);
+//
+// }
+//
+// static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int up) {
+//
+//     if (!up)
+//         return;
+//
+//     while (1) {
+//         unsigned char data;
+//         if (snd_rawmidi_transmit(substream, &data, 1) != 1)
+//             break; /* no more data */
+//         snd_socmidi_transmit(data);
+//     }
+// }
+//
+// static struct snd_rawmidi *g_rmidi;
+//
+// static struct snd_rawmidi_ops snd_socmidi_output_ops = {
+//     .open = snd_socmidi_open,
+//     .close = snd_socmidi_close,
+//     .trigger = snd_socmidi_output_trigger,
+// };
+//
+// static void pisnd_get_port_info(struct snd_rawmidi *rmidi, int number, struct snd_seq_port_info *seq_port_info)
+// {
+//     seq_port_info->type =
+//     SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
+//     SNDRV_SEQ_PORT_TYPE_HARDWARE |
+//     SNDRV_SEQ_PORT_TYPE_PORT;
+//     seq_port_info->midi_voices = 0;
+// }
+//
+// static struct snd_rawmidi_global_ops hsnd_global_ops = {.get_port_info = pisnd_get_port_info, };
+//
+// static int hsound_midi_init(struct snd_card *card)
+// {
+//     int err;
+//     struct resource *res;
+//
+//     err = snd_rawmidi_new(card, "SocMIDI", 0, midi_outs, midi_ins, &g_rmidi);
+//
+//     if (err < 0) {
+//         printe("snd_rawmidi_new failed: %d\n", err);
+//         return err;
+//     }
+//
+//     strcpy(g_rmidi->name, "Holosynth MIDI ");
+//
+//     g_rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT;
+//     // rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
+//     //                     SNDRV_RAWMIDI_INFO_INPUT |
+//     //                     SNDRV_RAWMIDI_INFO_DUPLEX;
+//
+//     g_rmidi->ops = &hsnd_global_ops;
+//
+//     g_rmidi->private_data = (void *)0;
+//
+//     snd_rawmidi_set_ops(g_rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_socmidi_output_ops);
+//     //    snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_socmidi_input_ops);
+//
+//     res = request_mem_region((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE, "MIDIREG");
+//     if (res == NULL) {
+//         return -EBUSY;
+//     }
+//
+//     midireg_mem = ioremap((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE);
+//     if (midireg_mem == NULL) {
+//         release_mem_region(MIDIREG_BASE, MIDIREG_SIZE);
+//         return -EFAULT;
+//     }
+//
+//     return 0;
+// }
+
+static unsigned int i2c_mux_gpio;
+
+static int de10soc_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+//    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct device *dev = rtd->card->dev;
+    unsigned int mclk_freq;
+//    int ret;
+
+    if ((params_rate(params) % 44100) == 0) {
+        mclk_freq = MCLK_RATE_44K;
+    } else if ((params_rate(params) % 48000) == 0) {
+        mclk_freq = MCLK_RATE_48K;
+    } else
+        return -EINVAL;
+
+    /* set codec mclk configuration */
+//     ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+//         mclk_freq, SND_SOC_CLOCK_OUT);
+//     if (ret < 0)
+//         return ret;
+
+    dev_dbg(dev, "hw_params: mclk_freq=%d\n", mclk_freq);
+    return 0;
+}
+
+// static void de10soc_shutdown(struct snd_pcm_substream *substream)
+// {
+//     struct snd_soc_pcm_runtime *rtd = substream->private_data;
+//     struct snd_soc_dai *codec_dai = rtd->codec_dai;
+//     struct device *dev = rtd->card->dev;
+//     int ret;
+//
+//     dev_dbg(dev, "shutdown\n");
+//     ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+//         0, SND_SOC_CLOCK_OUT);
+//     if (ret < 0) {
+//         dev_err(dev, "Failed to reset WM8731 SYSCLK: %d\n", ret);
+//     }
+// }
+
+static struct snd_soc_ops de10soc_ops = {
+    // .startup
+//    .shutdown = de10soc_shutdown,
+    .hw_params = de10soc_hw_params,
+    // .hw_free
+    // .prepare
+    // .trigger
+};
+
+static const struct snd_soc_dapm_widget de10soc_dapm_widgets[] = {
+    SND_SOC_DAPM_LINE("Line Out", NULL),
+    SND_SOC_DAPM_LINE("Hsynth in", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+    {"Line Out", NULL, "PCMOUT"},
+    {"HSYNTH", NULL, "Hsynth in"},
+};
+
+static int de10soc_hsynthpcm5102_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct device *dev = rtd->card->dev;
+    unsigned int fmt;
+    int ret;
+
+    dev_dbg(dev, "init\n");
+
+    fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+        SND_SOC_DAIFMT_CBS_CFS;
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    /* Don't let codec constraints interfere */
+//     ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+//         0, SND_SOC_CLOCK_OUT);
+//     if (ret < 0) {
+//         dev_err(dev, "Failed to set WM8731 SYSCLK: %d\n", ret);
+//         return ret;
+//     }
+
+    return 0;
+}
+
+// static int soc_hsynth_init(struct snd_soc_pcm_runtime *rtd)
+// {
+//     struct snd_soc_dai *codec_dai = rtd->codec_dai;
+//     struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+//     struct device *dev = rtd->card->dev;
+//     unsigned int fmt;
+//     int ret;
+//
+//     dev_dbg(dev, "init\n");
+//
+//     fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+//     SND_SOC_DAIFMT_CBS_CFS;
+//
+//     /* set cpu DAI configuration */
+//     ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+//     if (ret < 0)
+//         return ret;
+//
+//     /* set codec DAI configuration */
+//     ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+//     if (ret < 0)
+//         return ret;
+//
+//     return 0;
+// }
+
+static struct snd_soc_dai_link de10soc_dai = {
+//	{ /* Primary DAI i/f */
+    .name = "SSND0",
+    .stream_name = "HSYNTH PCM5102",
+    .cpu_dai_name = "ff200000.i2s",
+    .codec_dai_name = "hsynthpcm5102-hifi",
+    .init = de10soc_hsynthpcm5102_init,
+    .platform_name = "de10soc",
+    .codec_name = "hsynthpcm5102.hsynth",
+    .ops = &de10soc_ops,
+// 	}, { /* Sec_Fifo Playback i/f */
+//     .name = "SSND1",
+//     .stream_name = "HSYNTH PCM",
+//     .cpu_dai_name = "ff200000.dmalink",
+//     .codec_dai_name = "hsynth7002-hifi",
+//     .init = soc_hsynth_init,
+//     .platform_name = "de10soc",
+//     .codec_name = "hsynth7002.hsynth",
+//	},
+};
+
+static struct snd_soc_card snd_soc_de10soc = {
+    .name = "DE10SND",
+    .owner = THIS_MODULE,
+    .dai_link = &de10soc_dai,
+//    .num_links = ARRAY_SIZE(de10soc_dai),
+    .num_links = 1,
+
+//     .probe        = hmidi_card_probe,
+//     .remove       = hmidi_card_remove,
+
+    .dapm_widgets = de10soc_dapm_widgets,
+    .num_dapm_widgets = ARRAY_SIZE(de10soc_dapm_widgets),
+    .dapm_routes = intercon,
+    .num_dapm_routes = ARRAY_SIZE(intercon),
+};
+
+static int de10soc_audio_probe(struct platform_device *pdev)
+{
+    struct device_node *np = pdev->dev.of_node;
+    struct device_node *codec_np, *cpu_np;
+    struct snd_soc_card *card = &snd_soc_de10soc;
+    int ret;
+
+    if (!np) {
+        return -ENODEV;
+    }
+
+    card->dev = &pdev->dev;
+
+    /* I2C bus is muxed between HPS and FPGA. Set mux to HPS */
+//     i2c_mux_gpio = of_get_named_gpio(np, "i2c-mux-gpio", 0);
+//     if (gpio_is_valid(i2c_mux_gpio)) {
+//         ret = devm_gpio_request_one(&pdev->dev,
+//             i2c_mux_gpio, GPIOF_OUT_INIT_LOW, "I2C_MUX");
+//         if (ret) {
+//             dev_err(&pdev->dev,
+//                 "Failed to request GPIO_%d for i2c_mux: %d\n",
+//                 i2c_mux_gpio, ret);
+//             return ret;
+//         }
+//         gpio_set_value(i2c_mux_gpio, 1);
+//     }
+
+    /* Parse codec1 info */
+    de10soc_dai.codec_name = NULL;
+    codec_np = of_parse_phandle(np, "audio-codec", 0);
+    if (!codec_np) {
+        dev_err(&pdev->dev, "audio-codec info missing\n");
+        return -EINVAL;
+    }
+    de10soc_dai.codec_of_node = codec_np;
+
+    /* Parse dai and platform info */
+    de10soc_dai.cpu_dai_name = NULL;
+    de10soc_dai.platform_name = NULL;
+    cpu_np = of_parse_phandle(np, "i2s-controller", 0);
+    if (!cpu_np) {
+        dev_err(&pdev->dev, "i2s dai1 and pcm info missing\n");
+        return -EINVAL;
+    }
+
+    de10soc_dai.cpu_of_node = cpu_np;
+    de10soc_dai.platform_of_node = cpu_np;
+
+    of_node_put(codec_np);
+    of_node_put(cpu_np);
+
+    /* Parse codec2 info */
+//     de10soc_dai[1].codec_name = NULL;
+//     codec_np = of_parse_phandle(np, "synth-codec", 0);
+//     if (!codec_np) {
+//         dev_err(&pdev->dev, "synth-codec info missing\n");
+//         return -EINVAL;
+//     }
+//     de10soc_dai[1].codec_of_node = codec_np;
+//
+//     /* Parse dai and platform info */
+//     de10soc_dai[1].cpu_dai_name = NULL;
+//     de10soc_dai[1].platform_name = NULL;
+//     cpu_np = of_parse_phandle(np, "dmalink-controller", 0);
+//     if (!cpu_np) {
+//         dev_err(&pdev->dev, "dmalink-controller info missing\n");
+//         return -EINVAL;
+//     }
+//
+//     de10soc_dai[1].cpu_of_node = cpu_np;
+//     de10soc_dai[1].platform_of_node = cpu_np;
+//
+//     of_node_put(codec_np);
+//     of_node_put(cpu_np);
+//
+
+    ret = snd_soc_register_card(card);
+    if (ret) {
+        dev_err(&pdev->dev, "snd_soc_register_card() failed\n");
+    }
+
+    return ret;
+}
+
+static int de10soc_audio_remove(struct platform_device *pdev)
+{
+    struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+    if (gpio_is_valid(i2c_mux_gpio))
+        devm_gpio_free(&pdev->dev, i2c_mux_gpio);
+
+    snd_soc_unregister_card(card);
+
+    return 0;
+}
+
+static const struct of_device_id hsynthpcm5102_dt_ids[] = {
+    { .compatible = "opencores,hsynthpcm5102-audio", },
+    { }
+};
+MODULE_DEVICE_TABLE(of, hsynthpcm5102_dt_ids);
+
+static struct platform_driver de10soc_audio_driver = {
+    .driver = {
+        .name	= "hsynth-audio",
+        .owner	= THIS_MODULE,
+        .of_match_table = of_match_ptr(hsynthpcm5102_dt_ids),
+    },
+    .probe	= de10soc_audio_probe,
+    .remove	= de10soc_audio_remove,
+};
+
+module_platform_driver(de10soc_audio_driver);
+
+/* Module information */
+MODULE_AUTHOR("Bjarne Steinsbo <bsteinsbo@gmail.com>");
+MODULE_DESCRIPTION("ALSA SoC DE10-SoC_PWM5102");
+MODULE_LICENSE("GPL");
-- 
2.17.1


From b39f7a459d4782d0904487bf0d697c2e59c1aecd Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Fri, 4 May 2018 14:32:56 +0200
Subject: [PATCH 16/33] add vipii framebuffer dtb for de1_soc

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/Makefile                    |   1 +
 .../dts/socfpga_cyclone5_de1_soc_fbii.dts     | 285 ++++++++++++++++++
 2 files changed, 286 insertions(+)
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fbii.dts

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index b80aa1c22d5d..748b0684137c 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -705,6 +705,7 @@ dtb-$(CONFIG_ARCH_SOCFPGA) += \
 	socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dtb \
 	socfpga_cyclone5_de10_nano.dtb \
 	socfpga_cyclone5_de1_soc.dtb \
+	socfpga_cyclone5_de1_soc_fbii.dtb \
 	socfpga_cyclone5_sockit.dtb \
 	socfpga_cyclone5_socrates.dtb \
 	socfpga_cyclone5_sodia.dtb \
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fbii.dts b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fbii.dts
new file mode 100644
index 000000000000..225e46161c5c
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fbii.dts
@@ -0,0 +1,285 @@
+/*
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE1-SoC";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	sound {
+		compatible = "opencores,de1soc-wm8731-audio-midi";
+		i2s-controller = <&i2s>;
+		audio-codec = <&wm8731>;
+		i2c-mux-gpio = <&portb 19 0>;
+		dmalink-controller = <&dmalink>;
+		synth-codec = <&hsynth7002_codec>;
+	};
+
+	clk48: clk48 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <24576000>;
+		clock-output-names = "clk48";
+	};
+
+	clk44: clk44 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <33868800>;
+		clock-output-names = "clk44";
+	};
+
+	i2s: i2s@0x0 {
+		#sound-dai-cells = <1>;
+		compatible = "opencores,i2s";
+		reg = <0xff200000 0x20>, <0xff200040 0x20>;
+		clocks = <&clk44>, <&clk48>;
+		clock-names = "clk44", "clk48";
+		dmas = <&pdma 0>, <&pdma 1>, <&pdma 2>;
+		dma-names = "tx", "rx", "rx";
+	};
+
+	dmalink: dmalink@0x20 {
+		#sound-dai-cells = <1>;
+		compatible = "holotr,dmalink";
+		reg = <0xff200020 0x20>, <0xff200060 0x20>;
+		clocks = <&clk44>;
+		clock-names = "clk44";
+		dmas = <&pdma 2>;
+		dma-names = "rx";
+	};
+
+	hsynth7002_codec: hsynth7002-codec {
+	#sound-dai-cells = <0>;
+		compatible = "holotr,hsynth7002";
+/*     IOVDD-supply = <&supply>;*/
+		status = "okay";
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		bridge-enable = <1>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00020000 0xff220000 0x00000008>,
+			<0x00000001 0x00010000 0xff210000 0x00000008>,
+			<0x00000001 0x000100c0 0xff2100c0 0x00000010>,
+			<0x00000001 0x00010080 0xff210080 0x00000010>,
+			<0x00000001 0x00010040 0xff210040 0x00000010>,
+			<0x00000001 0x00031000 0xff231000 0x00000080>,
+			<0x00000001 0x00040000 0xff240000 0x00010000>,
+			<0x00000001 0x00050000 0xff250000 0x00010000>;
+
+		serial@0x100020000 {
+			compatible = "altr,juart-17.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00020000 0x00000008>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 40 4>;
+			clocks = <0x2>;
+		}; //end serial@0x100020000 (jtag_uart)
+
+		sysid@0x100010000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00010000 0x00000008>;
+			id = <2899645186>;
+			timestamp = <1524157570>;
+		};
+
+		gpio@0x1000100c0 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x000100c0 0x00000010>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 41 1>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <2>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			altr,interrupt-type = <2>;	/* embeddedsw.dts.params.altr,interrupt-type type NUMBER */
+			altr,interrupt_type = <2>;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
+			edge_type = <1>;	/* embeddedsw.dts.params.edge_type type NUMBER */
+			level_trigger = <0>;	/* embeddedsw.dts.params.level_trigger type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x1000100c0 (button_pio)
+
+		gpio@0x100010080 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00010080 0x00000010>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 42 1>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			altr,interrupt-type = <3>;	/* embeddedsw.dts.params.altr,interrupt-type type NUMBER */
+			altr,interrupt_type = <3>;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
+			edge_type = <2>;	/* embeddedsw.dts.params.edge_type type NUMBER */
+			level_trigger = <0>;	/* embeddedsw.dts.params.level_trigger type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x100010080 (dipsw_pio)
+
+		gpio@0x100010040 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00010040 0x00000010>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x100010040 (led_pio)
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-buffer-ii-2.0";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <1366>;
+			max-height = <768>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+
+		uio-socfpg0@0x100040000 {
+			compatible = "generic-uio,ui_pdrv";
+			reg = <0x00000001 0x00040000 0x00010000>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 43 4>;
+			address_width = <14>;
+			data_width = <32>;
+		};
+
+		socmidi@0x100050000 {
+			compatible = "holotr,socsynth-midi";
+			reg = <0x00000001 0x00050000 0x00010000>;
+			interrupt-parent = <0x2>;
+/*			interrupts = <0 44 4>;*/
+			address_width = <3>;   /* embeddedsw.dts.params.address_width type NUMBER */
+			data_width = <8>;      /* embeddedsw.dts.params.data_width type NUMBER */
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	wm8731: wm8731@34 {
+		#sound-dai-cells = <0>;
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+	};
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl345";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&i2c1 {
+	status = "okay";
+	speed-mode = <0>;
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
-- 
2.17.1


From 35c8d2ff12a366f5979580810751004e93c13924 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Thu, 24 May 2018 12:18:18 +0200
Subject: [PATCH 17/33] div codec mods

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 sound/soc/codecs/hsynth7002.c       |  5 ++--
 sound/soc/codecs/hsynthpcm5102.c    | 38 ++++++++++++++---------------
 sound/soc/socsynth/pcm5102-hsynth.c | 16 ++++++------
 3 files changed, 28 insertions(+), 31 deletions(-)

diff --git a/sound/soc/codecs/hsynth7002.c b/sound/soc/codecs/hsynth7002.c
index b1898b3a5379..6a7fd5ab23f1 100644
--- a/sound/soc/codecs/hsynth7002.c
+++ b/sound/soc/codecs/hsynth7002.c
@@ -63,9 +63,8 @@ static struct snd_soc_dai_driver hsynth7002_dai = {
 		.channels_min = 2,
 		.channels_max = 2,
 		.rates = SNDRV_PCM_RATE_8000_96000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S18_3LE |
-			SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |
-			SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |
+		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,
 		.sig_bits = 20,
 	},
 	.ops = &hsynth7002_dai_ops,
diff --git a/sound/soc/codecs/hsynthpcm5102.c b/sound/soc/codecs/hsynthpcm5102.c
index dd97160ac437..9791ae3c9608 100644
--- a/sound/soc/codecs/hsynthpcm5102.c
+++ b/sound/soc/codecs/hsynthpcm5102.c
@@ -57,27 +57,25 @@ static const struct snd_soc_dai_ops hsynthpcm5102_dai_ops = {
 };
 
 static struct snd_soc_dai_driver hsynthpcm5102_dai = {
-    .name = "hsynthpcm5102-hifi",
-    .playback = {
-        .stream_name = "Playback",
-        .channels_min = 2,
-        .channels_max = 2,
-        .rates = SNDRV_PCM_RATE_8000_192000,
-        .formats = SNDRV_PCM_FMTBIT_S16_LE |
-            SNDRV_PCM_FMTBIT_S24_LE |
-            SNDRV_PCM_FMTBIT_S32_LE,
-    },
+	.name = "hsynthpcm5102-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_96000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |
+			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,
+	},
     .capture = {
-        .stream_name = "Capture",
-        .channels_min = 2,
-        .channels_max = 2,
-        .rates = SNDRV_PCM_RATE_8000_192000,
-        .formats = SNDRV_PCM_FMTBIT_S16_LE |
-            SNDRV_PCM_FMTBIT_S24_LE |
-            SNDRV_PCM_FMTBIT_S32_LE,
-        .sig_bits = 20,
-    },
-    .ops = &hsynthpcm5102_dai_ops,
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_96000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,
+		.sig_bits = 20,
+	},
+	.ops = &hsynthpcm5102_dai_ops,
 };
 
 static const struct snd_soc_codec_driver hsynthpcm5102_codec_driver = {
diff --git a/sound/soc/socsynth/pcm5102-hsynth.c b/sound/soc/socsynth/pcm5102-hsynth.c
index 2d56f0b83f5a..3011c2b42579 100644
--- a/sound/soc/socsynth/pcm5102-hsynth.c
+++ b/sound/soc/socsynth/pcm5102-hsynth.c
@@ -158,7 +158,7 @@
 //
 //     return 0;
 // }
-
+/*
 static unsigned int i2c_mux_gpio;
 
 static int de10soc_hw_params(struct snd_pcm_substream *substream,
@@ -177,7 +177,7 @@ static int de10soc_hw_params(struct snd_pcm_substream *substream,
     } else
         return -EINVAL;
 
-    /* set codec mclk configuration */
+    // set codec mclk configuration
 //     ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
 //         mclk_freq, SND_SOC_CLOCK_OUT);
 //     if (ret < 0)
@@ -186,7 +186,7 @@ static int de10soc_hw_params(struct snd_pcm_substream *substream,
     dev_dbg(dev, "hw_params: mclk_freq=%d\n", mclk_freq);
     return 0;
 }
-
+*/
 // static void de10soc_shutdown(struct snd_pcm_substream *substream)
 // {
 //     struct snd_soc_pcm_runtime *rtd = substream->private_data;
@@ -201,7 +201,7 @@ static int de10soc_hw_params(struct snd_pcm_substream *substream,
 //         dev_err(dev, "Failed to reset WM8731 SYSCLK: %d\n", ret);
 //     }
 // }
-
+/*
 static struct snd_soc_ops de10soc_ops = {
     // .startup
 //    .shutdown = de10soc_shutdown,
@@ -210,7 +210,7 @@ static struct snd_soc_ops de10soc_ops = {
     // .prepare
     // .trigger
 };
-
+*/
 static const struct snd_soc_dapm_widget de10soc_dapm_widgets[] = {
     SND_SOC_DAPM_LINE("Line Out", NULL),
     SND_SOC_DAPM_LINE("Hsynth in", NULL),
@@ -290,7 +290,7 @@ static struct snd_soc_dai_link de10soc_dai = {
     .init = de10soc_hsynthpcm5102_init,
     .platform_name = "de10soc",
     .codec_name = "hsynthpcm5102.hsynth",
-    .ops = &de10soc_ops,
+//    .ops = &de10soc_ops,
 // 	}, { /* Sec_Fifo Playback i/f */
 //     .name = "SSND1",
 //     .stream_name = "HSYNTH PCM",
@@ -405,10 +405,10 @@ static int de10soc_audio_probe(struct platform_device *pdev)
 static int de10soc_audio_remove(struct platform_device *pdev)
 {
     struct snd_soc_card *card = platform_get_drvdata(pdev);
-
+/*
     if (gpio_is_valid(i2c_mux_gpio))
         devm_gpio_free(&pdev->dev, i2c_mux_gpio);
-
+*/
     snd_soc_unregister_card(card);
 
     return 0;
-- 
2.17.1


From 7c25073265887c4d237e9b17352e332e614362c6 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sat, 26 May 2018 21:36:55 +0200
Subject: [PATCH 18/33] Change uio port name Fix: for machinekit use

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts    | 2 +-
 arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
index 074a58924fa6..be476a1031fd 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
@@ -144,7 +144,7 @@
 			mem-word-width = <0x80>;
 		};
 
-		uio-socfpg0@0x100040000 {
+		hm2-socfpga0@0x100040000 {
 			compatible = "generic-uio,ui_pdrv";
 			reg = <0x00000001 0x00040000 0x00010000>;
 			interrupt-parent = <0x2>;
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
index bfb289855be1..f6ba2c68e527 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
@@ -144,7 +144,7 @@
 			mem-word-width = <0x80>;
 		};
 
-		uio-socfpg0@0x100040000 {
+		hm2-socfpga0@0x100040000 {
 			compatible = "generic-uio,ui_pdrv";
 			reg = <0x00000001 0x00040000 0x00010000>;
 			interrupt-parent = <0x2>;
-- 
2.17.1


From 74c3cd1db05238daa22597ee604f34b2a91cfbac Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Wed, 30 May 2018 12:33:08 +0200
Subject: [PATCH 19/33] Terasic dev boards: Make core addresses in qsys
 devicetrees consistant

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 ...pga_cyclone5_de10_nano_uio_aud_fbii_hd.dts | 16 ++---
 .../dts/socfpga_cyclone5_de10_nano_uio_fb.dts | 14 ++--
 .../socfpga_cyclone5_de10_nano_uio_fb_hd.dts  | 14 ++--
 .../arm/boot/dts/socfpga_cyclone5_de1_soc.dts | 71 +++++++++++--------
 .../dts/socfpga_cyclone5_de1_soc_fbii.dts     | 40 +++++------
 5 files changed, 82 insertions(+), 73 deletions(-)

diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
index 7e1acf94ba6b..1bf089216f35 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
@@ -103,14 +103,14 @@
 		#address-cells = <0x2>;
 		#size-cells = <0x1>;
 		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
-				<0x00000001 0x00002000 0xff202000 0x00000008>,
-				<0x00000001 0x00003000 0xff203000 0x00000010>,
-				<0x00000001 0x00004000 0xff204000 0x00000010>,
-				<0x00000001 0x00005000 0xff205000 0x00000010>,
-				<0x00000001 0x00030000 0xff230000 0x00000100>,
-				<0x00000001 0x00031000 0xff231000 0x00000080>,
-				<0x00000001 0x00040000 0xff240000 0x00010000>,
-				<0x00000001 0x00050000 0xff250000 0x00010000>;
+			<0x00000001 0x00002000 0xff202000 0x00000008>,
+			<0x00000001 0x00003000 0xff203000 0x00000010>,
+			<0x00000001 0x00004000 0xff204000 0x00000010>,
+			<0x00000001 0x00005000 0xff205000 0x00000010>,
+			<0x00000001 0x00030000 0xff230000 0x00000100>,
+			<0x00000001 0x00031000 0xff231000 0x00000080>,
+			<0x00000001 0x00040000 0xff240000 0x00010000>,
+			<0x00000001 0x00050000 0xff250000 0x00010000>;
 
 		sysid@0x100001000 {
 			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
index be476a1031fd..c05a7f799d5b 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
@@ -67,13 +67,13 @@
 		#address-cells = <0x2>;
 		#size-cells = <0x1>;
 		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
-				<0x00000001 0x00002000 0xff202000 0x00000008>,
-				<0x00000001 0x00003000 0xff203000 0x00000010>,
-				<0x00000001 0x00004000 0xff204000 0x00000010>,
-				<0x00000001 0x00005000 0xff205000 0x00000010>,
-				<0x00000001 0x00030000 0xff230000 0x00000100>,
-				<0x00000001 0x00031000 0xff231000 0x00000080>,
-				<0x00000001 0x00040000 0xff240000 0x00010000>;
+			<0x00000001 0x00002000 0xff202000 0x00000008>,
+			<0x00000001 0x00003000 0xff203000 0x00000010>,
+			<0x00000001 0x00004000 0xff204000 0x00000010>,
+			<0x00000001 0x00005000 0xff205000 0x00000010>,
+			<0x00000001 0x00030000 0xff230000 0x00000100>,
+			<0x00000001 0x00031000 0xff231000 0x00000080>,
+			<0x00000001 0x00040000 0xff240000 0x00010000>;
 
 		sysid@0x100001000 {
 			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
index f6ba2c68e527..ce568a0efbfd 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
@@ -67,13 +67,13 @@
 		#address-cells = <0x2>;
 		#size-cells = <0x1>;
 		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
-				<0x00000001 0x00002000 0xff202000 0x00000008>,
-				<0x00000001 0x00003000 0xff203000 0x00000010>,
-				<0x00000001 0x00004000 0xff204000 0x00000010>,
-				<0x00000001 0x00005000 0xff205000 0x00000010>,
-				<0x00000001 0x00030000 0xff230000 0x00000100>,
-				<0x00000001 0x00031000 0xff231000 0x00000080>,
-				<0x00000001 0x00040000 0xff240000 0x00010000>;
+			<0x00000001 0x00002000 0xff202000 0x00000008>,
+			<0x00000001 0x00003000 0xff203000 0x00000010>,
+			<0x00000001 0x00004000 0xff204000 0x00000010>,
+			<0x00000001 0x00005000 0xff205000 0x00000010>,
+			<0x00000001 0x00030000 0xff230000 0x00000100>,
+			<0x00000001 0x00031000 0xff231000 0x00000080>,
+			<0x00000001 0x00040000 0xff240000 0x00010000>;
 
 		sysid@0x100001000 {
 			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
index d2b80e6d9044..4925f44d0043 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
@@ -117,44 +117,34 @@
 		bridge-enable = <1>;
 		#address-cells = <0x2>;
 		#size-cells = <0x1>;
-		ranges = <0x00000001 0x00020000 0xff220000 0x00000008>,
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+			<0x00000001 0x00002000 0xff202000 0x00000008>,
+			<0x00000001 0x00003000 0xff203000 0x00000010>,
+			<0x00000001 0x00004000 0xff204000 0x00000010>,
+			<0x00000001 0x00005000 0xff205000 0x00000010>,
+			<0x00000001 0x00030000 0xff230000 0x00000100>,
 			<0x00000001 0x00031000 0xff231000 0x00000080>,
-			<0x00000001 0x00010000 0xff210000 0x00000008>,
-			<0x00000001 0x000100c0 0xff2100c0 0x00000010>,
-			<0x00000001 0x00010080 0xff210080 0x00000010>,
-			<0x00000001 0x00010040 0xff210040 0x00000010>,
 			<0x00000001 0x00040000 0xff240000 0x00010000>,
 			<0x00000001 0x00050000 0xff250000 0x00010000>;
 
-		serial@0x100020000 {
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <2899645186>;
+			timestamp = <1524157570>;
+		};
+
+		serial@0x100002000 {
 			compatible = "altr,juart-17.1", "altr,juart-1.0";
-			reg = <0x00000001 0x00020000 0x00000008>;
+			reg = <0x00000001 0x00002000 0x00000008>;
 			interrupt-parent = <0x2>;
 			interrupts = <0 40 4>;
 			clocks = <0x2>;
 		}; //end serial@0x100020000 (jtag_uart)
 
-		vip@0x100031000 {
-			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-14.0";
-			reg = <0x00000001 0x00031000 0x00000080>;
-			max-width = <0x556>;
-			max-height = <0x300>;
-			bits-per-color = <0x8>;
-			colors-per-beat = <0x4>;
-			beats-per-pixel = <0x1>;
-			mem-word-width = <0x80>;
-		};
-
-		sysid@0x100010000 {
-			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
-			reg = <0x00000001 0x00010000 0x00000008>;
-			id = <2899645186>;
-			timestamp = <1524157570>;
-		};
-
-		gpio@0x1000100c0 {
+		gpio@0x100003000 {
 			compatible = "altr,pio-17.1", "altr,pio-1.0";
-			reg = <0x00000001 0x000100c0 0x00000010>;
+			reg = <0x00000001 0x00003000 0x00000010>;
 			interrupt-parent = <0x2>;
 			interrupts = <0 41 1>;
 			clocks = <0x2>;
@@ -168,9 +158,9 @@
 			gpio-controller;
 		}; //end gpio@0x1000100c0 (button_pio)
 
-		gpio@0x100010080 {
+		gpio@0x100004000 {
 			compatible = "altr,pio-17.1", "altr,pio-1.0";
-			reg = <0x00000001 0x00010080 0x00000010>;
+			reg = <0x00000001 0x00004000 0x00000010>;
 			interrupt-parent = <0x2>;
 			interrupts = <0 42 1>;
 			clocks = <0x2>;
@@ -184,9 +174,9 @@
 			gpio-controller;
 		}; //end gpio@0x100010080 (dipsw_pio)
 
-		gpio@0x100010040 {
+		gpio@0x100005000 {
 			compatible = "altr,pio-17.1", "altr,pio-1.0";
-			reg = <0x00000001 0x00010040 0x00000010>;
+			reg = <0x00000001 0x00005000 0x00000010>;
 			clocks = <0x2>;
 			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
 			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
@@ -194,6 +184,25 @@
 			gpio-controller;
 		}; //end gpio@0x100010040 (led_pio)
 
+		ilc@0x100030000 {
+			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
+			reg = <0x00000001 0x00030000 0x00000100>;
+			interrupt-controller;
+			#interrupt-cells = <0x1>;
+			altr,sw-fifo-depth = <0x20>;
+		};
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-14.0";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <0x556>;
+			max-height = <0x300>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+
 		uio-socfpg0@0x100040000 {
 			compatible = "generic-uio,ui_pdrv";
 			reg = <0x00000001 0x00040000 0x00010000>;
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fbii.dts b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fbii.dts
index 225e46161c5c..c6aaacc3496e 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fbii.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fbii.dts
@@ -117,33 +117,33 @@
 		bridge-enable = <1>;
 		#address-cells = <0x2>;
 		#size-cells = <0x1>;
-		ranges = <0x00000001 0x00020000 0xff220000 0x00000008>,
-			<0x00000001 0x00010000 0xff210000 0x00000008>,
-			<0x00000001 0x000100c0 0xff2100c0 0x00000010>,
-			<0x00000001 0x00010080 0xff210080 0x00000010>,
-			<0x00000001 0x00010040 0xff210040 0x00000010>,
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+			<0x00000001 0x00002000 0xff202000 0x00000008>,
+			<0x00000001 0x00003000 0xff203000 0x00000010>,
+			<0x00000001 0x00004000 0xff204000 0x00000010>,
+			<0x00000001 0x00005000 0xff205000 0x00000010>,
 			<0x00000001 0x00031000 0xff231000 0x00000080>,
 			<0x00000001 0x00040000 0xff240000 0x00010000>,
 			<0x00000001 0x00050000 0xff250000 0x00010000>;
 
-		serial@0x100020000 {
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <2899645186>;
+			timestamp = <1524157570>;
+		};
+
+		serial@0x100002000 {
 			compatible = "altr,juart-17.1", "altr,juart-1.0";
-			reg = <0x00000001 0x00020000 0x00000008>;
+			reg = <0x00000001 0x00002000 0x00000008>;
 			interrupt-parent = <0x2>;
 			interrupts = <0 40 4>;
 			clocks = <0x2>;
 		}; //end serial@0x100020000 (jtag_uart)
 
-		sysid@0x100010000 {
-			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
-			reg = <0x00000001 0x00010000 0x00000008>;
-			id = <2899645186>;
-			timestamp = <1524157570>;
-		};
-
-		gpio@0x1000100c0 {
+		gpio@0x100003000 {
 			compatible = "altr,pio-17.1", "altr,pio-1.0";
-			reg = <0x00000001 0x000100c0 0x00000010>;
+			reg = <0x00000001 0x00003000 0x00000010>;
 			interrupt-parent = <0x2>;
 			interrupts = <0 41 1>;
 			clocks = <0x2>;
@@ -157,9 +157,9 @@
 			gpio-controller;
 		}; //end gpio@0x1000100c0 (button_pio)
 
-		gpio@0x100010080 {
+		gpio@0x100004000 {
 			compatible = "altr,pio-17.1", "altr,pio-1.0";
-			reg = <0x00000001 0x00010080 0x00000010>;
+			reg = <0x00000001 0x00004000 0x00000010>;
 			interrupt-parent = <0x2>;
 			interrupts = <0 42 1>;
 			clocks = <0x2>;
@@ -173,9 +173,9 @@
 			gpio-controller;
 		}; //end gpio@0x100010080 (dipsw_pio)
 
-		gpio@0x100010040 {
+		gpio@0x100005000 {
 			compatible = "altr,pio-17.1", "altr,pio-1.0";
-			reg = <0x00000001 0x00010040 0x00000010>;
+			reg = <0x00000001 0x00005000 0x00000010>;
 			clocks = <0x2>;
 			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
 			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
-- 
2.17.1


From 9776ba79f2d0f4ee79aa07c32fcd4e7b076df6e0 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Thu, 31 May 2018 13:46:11 +0200
Subject: [PATCH 20/33] Test Improve dtb

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 ...pga_cyclone5_de10_nano_uio_aud_fbii_hd.dts | 22 ++++++++++++-------
 1 file changed, 14 insertions(+), 8 deletions(-)

diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
index 1bf089216f35..65d1a56a8a23 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
@@ -122,9 +122,8 @@
 		serial@0x100002000 {
 			compatible = "altr,juart-15.1", "altr,juart-1.0";
 			reg = <0x00000001 0x00002000 0x00000008>;
-			interrupt-parent = <0x3>;
-			interrupts = <0x0 0x2a 0x4>;
-			clocks = <0x2>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 40 4>;
 		};
 
 		gpio@0x100003000 {
@@ -139,6 +138,8 @@
 		gpio@0x100004000 {
 			compatible = "altr,pio-15.1", "altr,pio-1.0";
 			reg = <0x00000001 0x00004000 0x00000010>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 41 1>;
 			altr,gpio-bank-width = <0x4>;
 			altr,interrupt-type = <0x3>;
 			altr,interrupt_type = <0x3>;
@@ -152,6 +153,8 @@
 		gpio@0x100005000 {
 			compatible = "altr,pio-15.1", "altr,pio-1.0";
 			reg = <0x00000001 0x00005000 0x00000010>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 42 1>;
 			altr,gpio-bank-width = <0x2>;
 			altr,interrupt-type = <0x2>;
 			altr,interrupt_type = <0x2>;
@@ -165,6 +168,9 @@
 		ilc@0x100030000 {
 			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
 			reg = <0x00000001 0x00030000 0x00000100>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 0 4 0 2 1 0 1 1 0 3 4 0 4 4>;
+			interrupt-names = "jtag_uart", "button_pio", "dipsw_pio", "uioreg_io_0", "socmidi_0";
 			interrupt-controller;
 			#interrupt-cells = <0x1>;
 			altr,sw-fifo-depth = <0x20>;
@@ -184,8 +190,8 @@
 		uio-socfpg0@0x100040000 {
 			compatible = "generic-uio,ui_pdrv";
 			reg = <0x00000001 0x00040000 0x00010000>;
-			interrupt-parent = <0x2>;
-			interrupts = <0 43 1>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 43 4>;
 			address_width = <14>;
 			data_width = <32>;
 		};
@@ -193,8 +199,8 @@
 		socmidi@0x100050000 {
 			compatible = "holotr,socsynth-midi";
 			reg = <0x00000001 0x00050000 0x00010000>;
-			interrupt-parent = <0x2>;
-/*			interrupts = <0 44 4>;*/
+			interrupt-parent = <&intc>;
+			interrupts = <0 44 4>;
 			address_width = <3>;   /* embeddedsw.dts.params.address_width type NUMBER */
 			data_width = <8>;      /* embeddedsw.dts.params.data_width type NUMBER */
 		};
@@ -241,7 +247,7 @@
 		compatible = "adi,adxl34x";
 		reg = <0x53>;
 
-		interrupt-parent = <&portc>;
+		interrupt-parent = <&intc>;
 		interrupts = <3 2>;
 	};
 };
-- 
2.17.1


From ee48f50922a05404fa95eba93abe0c8594311123 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Thu, 31 May 2018 18:08:43 +0200
Subject: [PATCH 21/33] Add missing .ops to synthpcm5102 codec

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 sound/soc/codecs/hsynthpcm5102.c | 93 ++++++++++++++++++++++++--------
 1 file changed, 72 insertions(+), 21 deletions(-)

diff --git a/sound/soc/codecs/hsynthpcm5102.c b/sound/soc/codecs/hsynthpcm5102.c
index 9791ae3c9608..414414670f15 100644
--- a/sound/soc/codecs/hsynthpcm5102.c
+++ b/sound/soc/codecs/hsynthpcm5102.c
@@ -27,32 +27,83 @@ static const struct snd_soc_dapm_route hsynthpcm5102_routes[] = {
 
 static int hsynthpcm5102_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-    switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-    case SND_SOC_DAIFMT_CBS_CFS:
-        break;
-    default:
-        return -EINVAL;
-    }
-
-    switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-    case SND_SOC_DAIFMT_NB_NF:
-        break;
-    default:
-        return -EINVAL;
-    }
-
-    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-    case SND_SOC_DAIFMT_I2S:
-    case SND_SOC_DAIFMT_DSP_A:
-        break;
-    default:
-        return -EINVAL;
-    }
+//     switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+//     case SND_SOC_DAIFMT_CBS_CFS:
+//         break;
+//     default:
+//         return -EINVAL;
+//     }
+//
+//     switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+//     case SND_SOC_DAIFMT_NB_NF:
+//         break;
+//     default:
+//         return -EINVAL;
+//     }
+//
+//     switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+//     case SND_SOC_DAIFMT_I2S:
+//     case SND_SOC_DAIFMT_DSP_A:
+//         break;
+//     default:
+//         return -EINVAL;
+//     }
 
     return 0;
 }
 
+static int hsynthpcm5102_hw_params(struct snd_pcm_substream *substream,
+                            struct snd_pcm_hw_params *params,
+                            struct snd_soc_dai *dai)
+{
+//     struct snd_soc_codec *codec = dai->codec;
+//     struct wm8731_priv *wm8731 = snd_soc_codec_get_drvdata(codec);
+//     u16 iface = snd_soc_read(codec, WM8731_IFACE) & 0xfff3;
+//     int i = get_coeff(wm8731->sysclk, params_rate(params));
+//     u16 srate = (coeff_div[i].sr << 2) |
+//     (coeff_div[i].bosr << 1) | coeff_div[i].usb;
+//
+//     wm8731->playback_fs = params_rate(params);
+//
+//     snd_soc_write(codec, WM8731_SRATE, srate);
+//
+//     /* bit size */
+//     switch (params_width(params)) {
+//         case 16:
+//             break;
+//         case 20:
+//             iface |= 0x0004;
+//             break;
+//         case 24:
+//             iface |= 0x0008;
+//             break;
+//         case 32:
+//             iface |= 0x000c;
+//             break;
+//     }
+//
+//     wm8731_set_deemph(codec);
+//
+//     snd_soc_write(codec, WM8731_IFACE, iface);
+    return 0;
+}
+
+static int hsynthpcm5102_startup(struct snd_pcm_substream *substream,
+                           struct snd_soc_dai *dai)
+{
+//     struct wm8731_priv *wm8731 = snd_soc_codec_get_drvdata(dai->codec);
+//
+//     if (wm8731->constraints)
+//         snd_pcm_hw_constraint_list(substream->runtime, 0,
+//                                    SNDRV_PCM_HW_PARAM_RATE,
+//                                    wm8731->constraints);
+
+        return 0;
+}
+
 static const struct snd_soc_dai_ops hsynthpcm5102_dai_ops = {
+    .startup	= hsynthpcm5102_startup,
+    .hw_params	= hsynthpcm5102_hw_params,
     .set_fmt = hsynthpcm5102_set_dai_fmt,
 };
 
-- 
2.17.1


From b7a59ad103030d02ce9970912e3a92a5ee73c682 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Fri, 1 Jun 2018 12:52:57 +0200
Subject: [PATCH 22/33] Make DE1x Devicetree qsys core addresses consistant

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 ...pga_cyclone5_de10_nano_uio_aud_fbii_hd.dts |  6 +-
 .../dts/socfpga_cyclone5_de10_nano_uio_fb.dts | 22 +++---
 .../socfpga_cyclone5_de10_nano_uio_fb_hd.dts  | 26 +++----
 .../arm/boot/dts/socfpga_cyclone5_de1_soc.dts | 70 +++++++++----------
 4 files changed, 58 insertions(+), 66 deletions(-)

diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
index 65d1a56a8a23..4b8b81316cf6 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
@@ -133,7 +133,7 @@
 			resetvalue = <0xff>;
 			#gpio-cells = <0x2>;
 			gpio-controller;
-		};
+		};// (led_pio)
 
 		gpio@0x100004000 {
 			compatible = "altr,pio-15.1", "altr,pio-1.0";
@@ -148,7 +148,7 @@
 			resetvalue = <0x0>;
 			#gpio-cells = <0x2>;
 			gpio-controller;
-		};
+		};// (dipsw_pio)
 
 		gpio@0x100005000 {
 			compatible = "altr,pio-15.1", "altr,pio-1.0";
@@ -163,7 +163,7 @@
 			resetvalue = <0x0>;
 			#gpio-cells = <0x2>;
 			gpio-controller;
-		};
+		};// (button_pio)
 
 		ilc@0x100030000 {
 			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
index c05a7f799d5b..cc62324122c7 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
@@ -85,8 +85,8 @@
 		serial@0x100002000 {
 			compatible = "altr,juart-15.1", "altr,juart-1.0";
 			reg = <0x00000001 0x00002000 0x00000008>;
-			interrupt-parent = <0x3>;
-			interrupts = <0x0 0x2a 0x4>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 40 4>;
 			clocks = <0x2>;
 		};
 
@@ -103,6 +103,8 @@
 			compatible = "altr,pio-15.1", "altr,pio-1.0";
 			reg = <0x00000001 0x00004000 0x00000010>;
 			altr,gpio-bank-width = <0x4>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 41 1>;
 			altr,interrupt-type = <0x3>;
 			altr,interrupt_type = <0x3>;
 			edge_type = <0x2>;
@@ -115,6 +117,8 @@
 		gpio@0x100005000 {
 			compatible = "altr,pio-15.1", "altr,pio-1.0";
 			reg = <0x00000001 0x00005000 0x00000010>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 42 1>;
 			altr,gpio-bank-width = <0x2>;
 			altr,interrupt-type = <0x2>;
 			altr,interrupt_type = <0x2>;
@@ -125,14 +129,6 @@
 			gpio-controller;
 		};
 
-		ilc@0x100030000 {
-			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
-			reg = <0x00000001 0x00030000 0x00000100>;
-			interrupt-controller;
-			#interrupt-cells = <0x1>;
-			altr,sw-fifo-depth = <0x20>;
-		};
-
 		vip@0x100031000 {
 			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-9.1";
 			reg = <0x00000001 0x00031000 0x00000080>;
@@ -147,8 +143,8 @@
 		hm2-socfpga0@0x100040000 {
 			compatible = "generic-uio,ui_pdrv";
 			reg = <0x00000001 0x00040000 0x00010000>;
-			interrupt-parent = <0x2>;
-			interrupts = <0 43 1>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 43 4>;
 			address_width = <14>;
 			data_width = <32>;
 		};
@@ -195,7 +191,7 @@
 		compatible = "adi,adxl34x";
 		reg = <0x53>;
 
-		interrupt-parent = <&portc>;
+		interrupt-parent = <&intc>;
 		interrupts = <3 2>;
 	};
 };
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
index ce568a0efbfd..67bf19fc5f08 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
@@ -71,8 +71,8 @@
 			<0x00000001 0x00003000 0xff203000 0x00000010>,
 			<0x00000001 0x00004000 0xff204000 0x00000010>,
 			<0x00000001 0x00005000 0xff205000 0x00000010>,
-			<0x00000001 0x00030000 0xff230000 0x00000100>,
-			<0x00000001 0x00031000 0xff231000 0x00000080>,
+            <0x00000000 0x00010000 0xc0010000 0x00010000>,
+            <0x00000001 0x00031000 0xff231000 0x00000080>,
 			<0x00000001 0x00040000 0xff240000 0x00010000>;
 
 		sysid@0x100001000 {
@@ -85,8 +85,8 @@
 		serial@0x100002000 {
 			compatible = "altr,juart-15.1", "altr,juart-1.0";
 			reg = <0x00000001 0x00002000 0x00000008>;
-			interrupt-parent = <0x3>;
-			interrupts = <0x0 0x2a 0x4>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 40 4>;
 			clocks = <0x2>;
 		};
 
@@ -102,6 +102,8 @@
 		gpio@0x100004000 {
 			compatible = "altr,pio-15.1", "altr,pio-1.0";
 			reg = <0x00000001 0x00004000 0x00000010>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 41 1>;
 			altr,gpio-bank-width = <0x4>;
 			altr,interrupt-type = <0x3>;
 			altr,interrupt_type = <0x3>;
@@ -115,6 +117,8 @@
 		gpio@0x100005000 {
 			compatible = "altr,pio-15.1", "altr,pio-1.0";
 			reg = <0x00000001 0x00005000 0x00000010>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 42 1>;
 			altr,gpio-bank-width = <0x2>;
 			altr,interrupt-type = <0x2>;
 			altr,interrupt_type = <0x2>;
@@ -125,14 +129,6 @@
 			gpio-controller;
 		};
 
-		ilc@0x100030000 {
-			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
-			reg = <0x00000001 0x00030000 0x00000100>;
-			interrupt-controller;
-			#interrupt-cells = <0x1>;
-			altr,sw-fifo-depth = <0x20>;
-		};
-
 		vip@0x100031000 {
 			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-9.1";
 			reg = <0x00000001 0x00031000 0x00000080>;
@@ -147,8 +143,8 @@
 		hm2-socfpga0@0x100040000 {
 			compatible = "generic-uio,ui_pdrv";
 			reg = <0x00000001 0x00040000 0x00010000>;
-			interrupt-parent = <0x2>;
-			interrupts = <0 43 1>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 43 4>;
 			address_width = <14>;
 			data_width = <32>;
 		};
@@ -195,7 +191,7 @@
 		compatible = "adi,adxl34x";
 		reg = <0x53>;
 
-		interrupt-parent = <&portc>;
+		interrupt-parent = <&intc>;
 		interrupts = <3 2>;
 	};
 };
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
index 4925f44d0043..11f0a9cd94db 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
@@ -137,56 +137,56 @@
 		serial@0x100002000 {
 			compatible = "altr,juart-17.1", "altr,juart-1.0";
 			reg = <0x00000001 0x00002000 0x00000008>;
-			interrupt-parent = <0x2>;
+			interrupt-parent = <&intc>;
 			interrupts = <0 40 4>;
 			clocks = <0x2>;
 		}; //end serial@0x100020000 (jtag_uart)
 
 		gpio@0x100003000 {
-			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
 			reg = <0x00000001 0x00003000 0x00000010>;
-			interrupt-parent = <0x2>;
-			interrupts = <0 41 1>;
-			clocks = <0x2>;
-			altr,gpio-bank-width = <2>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
-			altr,interrupt-type = <2>;	/* embeddedsw.dts.params.altr,interrupt-type type NUMBER */
-			altr,interrupt_type = <2>;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
-			edge_type = <1>;	/* embeddedsw.dts.params.edge_type type NUMBER */
-			level_trigger = <0>;	/* embeddedsw.dts.params.level_trigger type NUMBER */
-			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
-			#gpio-cells = <2>;
+			altr,gpio-bank-width = <0x8>;
+			resetvalue = <0xff>;
+			#gpio-cells = <0x2>;
 			gpio-controller;
-		}; //end gpio@0x1000100c0 (button_pio)
+		};// (led_pio)
 
 		gpio@0x100004000 {
-			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
 			reg = <0x00000001 0x00004000 0x00000010>;
-			interrupt-parent = <0x2>;
-			interrupts = <0 42 1>;
-			clocks = <0x2>;
-			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
-			altr,interrupt-type = <3>;	/* embeddedsw.dts.params.altr,interrupt-type type NUMBER */
-			altr,interrupt_type = <3>;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
-			edge_type = <2>;	/* embeddedsw.dts.params.edge_type type NUMBER */
-			level_trigger = <0>;	/* embeddedsw.dts.params.level_trigger type NUMBER */
-			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
-			#gpio-cells = <2>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 41 1>;
+			altr,gpio-bank-width = <0x4>;
+			altr,interrupt-type = <0x3>;
+			altr,interrupt_type = <0x3>;
+			edge_type = <0x2>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
 			gpio-controller;
-		}; //end gpio@0x100010080 (dipsw_pio)
+		};// (dipsw_pio)
 
 		gpio@0x100005000 {
-			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
 			reg = <0x00000001 0x00005000 0x00000010>;
-			clocks = <0x2>;
-			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
-			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
-			#gpio-cells = <2>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 42 1>;
+			altr,gpio-bank-width = <0x2>;
+			altr,interrupt-type = <0x2>;
+			altr,interrupt_type = <0x2>;
+			edge_type = <0x1>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
 			gpio-controller;
-		}; //end gpio@0x100010040 (led_pio)
+		};// (button_pio)
 
 		ilc@0x100030000 {
 			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
 			reg = <0x00000001 0x00030000 0x00000100>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 0 4 0 2 1 0 1 1 0 3 4 0 4 4>;
+			interrupt-names = "jtag_uart", "button_pio", "dipsw_pio", "uioreg_io_0", "socmidi_0";
 			interrupt-controller;
 			#interrupt-cells = <0x1>;
 			altr,sw-fifo-depth = <0x20>;
@@ -206,7 +206,7 @@
 		uio-socfpg0@0x100040000 {
 			compatible = "generic-uio,ui_pdrv";
 			reg = <0x00000001 0x00040000 0x00010000>;
-			interrupt-parent = <0x2>;
+			interrupt-parent = <&intc>;
 			interrupts = <0 43 4>;
 			address_width = <14>;
 			data_width = <32>;
@@ -215,8 +215,8 @@
 		socmidi@0x100050000 {
 			compatible = "holotr,socsynth-midi";
 			reg = <0x00000001 0x00050000 0x00010000>;
-			interrupt-parent = <0x2>;
-/*			interrupts = <0 44 4>;*/
+			interrupt-parent = <&intc>;
+			interrupts = <0 44 4>;
 			address_width = <3>;   /* embeddedsw.dts.params.address_width type NUMBER */
 			data_width = <8>;      /* embeddedsw.dts.params.data_width type NUMBER */
 		};
@@ -269,7 +269,7 @@
 		compatible = "adi,adxl345";
 		reg = <0x53>;
 
-		interrupt-parent = <&portc>;
+		interrupt-parent = <&intc>;
 		interrupts = <3 2>;
 	};
 };
-- 
2.17.1


From 02badf3c0e1871d245637a1e17fe5f9fd61b0e90 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sat, 2 Jun 2018 22:56:31 +0200
Subject: [PATCH 23/33] Add builtin audio codec driver for DE1/DE10 SoC
 (wm8731) Add Audio and framebuffer Supporting device trees xga and hd
 versions

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/Makefile                    |   2 +
 .../dts/socfpga_cyclone5_de1_soc_aud_fb.dts   | 194 ++++++++++++++
 .../socfpga_cyclone5_de1_soc_aud_fb_hd.dts    | 194 ++++++++++++++
 arch/arm/configs/socfpga_defconfig            |   3 +-
 sound/soc/socsynth/Kconfig                    |   9 +-
 sound/soc/socsynth/Makefile                   |   5 +-
 sound/soc/socsynth/de1x-soc-wm8731.c          | 251 ++++++++++++++++++
 7 files changed, 655 insertions(+), 3 deletions(-)
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de1_soc_aud_fb.dts
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de1_soc_aud_fb_hd.dts
 create mode 100644 sound/soc/socsynth/de1x-soc-wm8731.c

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 748b0684137c..cd54d8e8f8fe 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -705,6 +705,8 @@ dtb-$(CONFIG_ARCH_SOCFPGA) += \
 	socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dtb \
 	socfpga_cyclone5_de10_nano.dtb \
 	socfpga_cyclone5_de1_soc.dtb \
+	socfpga_cyclone5_de1_soc_aud_fb.dtb \
+	socfpga_cyclone5_de1_soc_aud_fb_hd.dtb \
 	socfpga_cyclone5_de1_soc_fbii.dtb \
 	socfpga_cyclone5_sockit.dtb \
 	socfpga_cyclone5_socrates.dtb \
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_aud_fb.dts b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_aud_fb.dts
new file mode 100644
index 000000000000..4fb724a505c7
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_aud_fb.dts
@@ -0,0 +1,194 @@
+/*
+ *  Copyright (C) 2013 Steffen Trumtrar <s.trumtrar@pengutronix.de>
+ *  Copyright (C) 2016 Stephen Arnold <nerdboy@gentoo.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE1-SoC";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	sound {
+		compatible = "opencores,de1soc-wm8731-audio";
+		i2s-controller = <&i2s>;
+		audio-codec = <&wm8731>;
+		i2c-mux-gpio = <&portb 19 0>;
+	};
+
+	clk48: clk48 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <24576000>;
+		clock-output-names = "clk48";
+	};
+
+	clk44: clk44 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <33868800>;
+		clock-output-names = "clk44";
+	};
+
+	i2s: i2s@0x0 {
+		#sound-dai-cells = <1>;
+		compatible = "opencores,i2s";
+		reg = <0xff200000 0x20>, <0xff200020 0x20>;
+		clocks = <&clk44>, <&clk48>;
+		clock-names = "clk44", "clk48";
+		dmas = <&pdma 0>, <&pdma 1>;
+		dma-names = "tx", "rx";
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		bridge-enable = <1>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+			<0x00000001 0x00031000 0xff231000 0x00000080>;
+
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <2899645186>;
+			timestamp = <1524157570>;
+		};
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-14.0";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <1024>;
+			max-height = <768>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	wm8731: wm8731@34 {
+		#sound-dai-cells = <0>;
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+	};
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl345";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&i2c1 {
+	status = "okay";
+	speed-mode = <0>;
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_aud_fb_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_aud_fb_hd.dts
new file mode 100644
index 000000000000..ecebb6e9cd19
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_aud_fb_hd.dts
@@ -0,0 +1,194 @@
+/*
+ *  Copyright (C) 2013 Steffen Trumtrar <s.trumtrar@pengutronix.de>
+ *  Copyright (C) 2016 Stephen Arnold <nerdboy@gentoo.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE1-SoC";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	sound {
+		compatible = "opencores,de1soc-wm8731-audio";
+		i2s-controller = <&i2s>;
+		audio-codec = <&wm8731>;
+		i2c-mux-gpio = <&portb 19 0>;
+	};
+
+	clk48: clk48 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <24576000>;
+		clock-output-names = "clk48";
+	};
+
+	clk44: clk44 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <33868800>;
+		clock-output-names = "clk44";
+	};
+
+	i2s: i2s@0x0 {
+		#sound-dai-cells = <1>;
+		compatible = "opencores,i2s";
+		reg = <0xff200000 0x20>, <0xff200020 0x20>;
+		clocks = <&clk44>, <&clk48>;
+		clock-names = "clk44", "clk48";
+		dmas = <&pdma 0>, <&pdma 1>;
+		dma-names = "tx", "rx";
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		bridge-enable = <1>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+			<0x00000001 0x00031000 0xff231000 0x00000080>;
+
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <2899645186>;
+			timestamp = <1524157570>;
+		};
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-14.0";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <1920>;
+			max-height = <1080>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	wm8731: wm8731@34 {
+		#sound-dai-cells = <0>;
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+	};
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl345";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&i2c1 {
+	status = "okay";
+	speed-mode = <0>;
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 25f92bd18920..4917bafcd7ae 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -308,7 +308,8 @@ CONFIG_SND_SOC_SSM2602=m
 CONFIG_SND_SOC_SSM2602_I2C=m
 CONFIG_SND_ALOOP=m
 CONFIG_SND_VIRMIDI=m
-CONFIG_SND_SOC_DE1_WM8731_HSYNTH=m
+CONFIG_SND_SOC_DE1x_WM8731=m
+CONFIG_SND_SOC_DE1x_WM8731_HSYNTH=m
 CONFIG_SND_SOC_HSYNTH_MIDI=m
 CONFIG_SND_SOC_PCM5102A=m
 CONFIG_SND_SOC_PCM5102_HSYNTH=m
diff --git a/sound/soc/socsynth/Kconfig b/sound/soc/socsynth/Kconfig
index 5d71a4ee1f62..b6b7dec7364c 100644
--- a/sound/soc/socsynth/Kconfig
+++ b/sound/soc/socsynth/Kconfig
@@ -16,7 +16,7 @@ config SND_SOC_HSYNTHDMA
          This driver can also be built as a module.  If so, the module
          will be called hsynthdma.
 
-config SND_SOC_DE1_WM8731_HSYNTH
+config SND_SOC_DE1x_WM8731_HSYNTH
        tristate "DE1-Audio MIDI support"
        select SND_SOC_WM8731
        select SND_SOC_OC_I2S
@@ -34,3 +34,10 @@ config SND_SOC_PCM5102_HSYNTH
        select SND_SOC_OC_I2S
        select SND_SOC_GENERIC_DMAENGINE_PCM
        select REGMAP_MMIO
+
+config SND_SOC_DE1x_WM8731
+       tristate "DE1x-Builtin-Audio support"
+       select SND_SOC_WM8731
+       select SND_SOC_OC_I2S
+       select SND_SOC_GENERIC_DMAENGINE_PCM
+       select REGMAP_MMIO
diff --git a/sound/soc/socsynth/Makefile b/sound/soc/socsynth/Makefile
index 2043f43d0400..69fb2aa3b284 100644
--- a/sound/soc/socsynth/Makefile
+++ b/sound/soc/socsynth/Makefile
@@ -2,7 +2,7 @@ snd-soc-opencores_i2s-objs := opencores_i2s.o
 obj-$(CONFIG_SND_SOC_OC_I2S) += snd-soc-opencores_i2s.o
 
 snd-de1-soc-wm8731-hsynth-objs := de1-soc-wm8731-hsynth.o
-obj-$(CONFIG_SND_SOC_DE1_WM8731_HSYNTH) += snd-de1-soc-wm8731-hsynth.o
+obj-$(CONFIG_SND_SOC_DE1x_WM8731_HSYNTH) += snd-de1-soc-wm8731-hsynth.o
 
 snd-soc-hsynthdma-objs := hsynthdma.o
 obj-$(CONFIG_SND_SOC_HSYNTHDMA) += snd-soc-hsynthdma.o
@@ -12,3 +12,6 @@ obj-$(CONFIG_SND_SOC_HSYNTH_MIDI) += snd-soc-hsynth-midi.o
 
 snd-pcm5102-hsynth-objs := pcm5102-hsynth.o
 obj-$(CONFIG_SND_SOC_PCM5102_HSYNTH) += snd-pcm5102-hsynth.o
+
+snd-soc-de1x-soc-wm8731-objs := de1x-soc-wm8731.o
+obj-$(CONFIG_SND_SOC_DE1x_WM8731) += snd-soc-de1x-soc-wm8731.o
diff --git a/sound/soc/socsynth/de1x-soc-wm8731.c b/sound/soc/socsynth/de1x-soc-wm8731.c
new file mode 100644
index 000000000000..e297ef4b0c0c
--- /dev/null
+++ b/sound/soc/socsynth/de1x-soc-wm8731.c
@@ -0,0 +1,251 @@
+/*
+ * de1-soc-wm8731 -- SoC audio for Terasic DE1-SoC board
+ * Author: B. Steinsbo <bsteinsbo@gmail.com>
+ *
+ * Based on sam9g20_wm8731 by
+ * Sedji Gaouaou <sedji.gaouaou@atmel.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/uaccess.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+
+#define WM8731_SYSCLK_XTAL 1
+#define WM8731_SYSCLK_MCLK 2
+#define MCLK_RATE_48K 12288000 /* fs*256 */
+#define MCLK_RATE_44K 16934400 /* fs*384 */
+
+static unsigned int i2c_mux_gpio;
+
+static int de1soc_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct device *dev = rtd->card->dev;
+	unsigned int mclk_freq;
+	int ret;
+
+	if ((params_rate(params) % 44100) == 0) {
+		mclk_freq = MCLK_RATE_44K;
+	} else if ((params_rate(params) % 48000) == 0) {
+		mclk_freq = MCLK_RATE_48K;
+	} else
+		return -EINVAL;
+
+	/* set codec mclk configuration */
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+		mclk_freq, SND_SOC_CLOCK_OUT);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(dev, "hw_params: mclk_freq=%d\n", mclk_freq);
+	return 0;
+}
+
+static void de1soc_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct device *dev = rtd->card->dev;
+	int ret;
+
+	dev_dbg(dev, "shutdown\n");
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+		0, SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		dev_err(dev, "Failed to reset WM8731 SYSCLK: %d\n", ret);
+	}
+}
+
+static struct snd_soc_ops de1soc_ops = {
+	// .startup
+	.shutdown = de1soc_shutdown,
+	.hw_params = de1soc_hw_params,
+	// .hw_free
+	// .prepare
+	// .trigger
+};
+
+static const struct snd_soc_dapm_widget de1soc_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_MIC("Microphone Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+	SND_SOC_DAPM_LINE("Line Out Jack", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	{"MICIN", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Microphone Jack"},
+	{"LLINEIN", NULL, "Line In Jack"},
+	{"RLINEIN", NULL, "Line In Jack"},
+	{"Line Out Jack", NULL, "LOUT"},
+	{"Line Out Jack", NULL, "ROUT"},
+	{"Headphone Jack", NULL, "LHPOUT"},
+	{"Headphone Jack", NULL, "RHPOUT"},
+};
+
+static int de1soc_wm8731_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct device *dev = rtd->card->dev;
+	unsigned int fmt;
+	int ret;
+
+	dev_dbg(dev, "init\n");
+
+	fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	      SND_SOC_DAIFMT_CBS_CFS;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+	if (ret < 0)
+		return ret;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0)
+		return ret;
+
+	/* Don't let codec constraints interfere */
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+		0, SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set WM8731 SYSCLK: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_dai_link de1soc_dai = {
+	.name = "WM8731",
+	.stream_name = "WM8731 PCM",
+	.cpu_dai_name = "ff200000.i2s",
+	.codec_dai_name = "wm8731-hifi",
+	.init = de1soc_wm8731_init,
+	.platform_name = "de1soc",
+	.codec_name = "wm8731.0-001a",
+	.ops = &de1soc_ops,
+};
+
+static struct snd_soc_card snd_soc_de1soc = {
+	.name = "DE1SOC-WM8731",
+	.owner = THIS_MODULE,
+	.dai_link = &de1soc_dai,
+	.num_links = 1,
+
+	.dapm_widgets = de1soc_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(de1soc_dapm_widgets),
+	.dapm_routes = intercon,
+	.num_dapm_routes = ARRAY_SIZE(intercon),
+};
+
+static int de1soc_audio_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *codec_np, *cpu_np;
+	struct snd_soc_card *card = &snd_soc_de1soc;
+	int ret;
+
+	if (!np) {
+		return -ENODEV;
+	}
+
+	card->dev = &pdev->dev;
+
+	/* I2C bus is muxed between HPS and FPGA. Set mux to HPS */
+	i2c_mux_gpio = of_get_named_gpio(np, "i2c-mux-gpio", 0);
+	if (gpio_is_valid(i2c_mux_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev,
+			i2c_mux_gpio, GPIOF_OUT_INIT_LOW, "I2C_MUX");
+		if (ret) {
+			dev_err(&pdev->dev,
+				"Failed to request GPIO_%d for i2c_mux: %d\n",
+				i2c_mux_gpio, ret);
+			return ret;
+		}
+		gpio_set_value(i2c_mux_gpio, 1);
+	}
+
+	/* Parse codec info */
+	de1soc_dai.codec_name = NULL;
+	codec_np = of_parse_phandle(np, "audio-codec", 0);
+	if (!codec_np) {
+		dev_err(&pdev->dev, "codec info missing\n");
+		return -EINVAL;
+	}
+	de1soc_dai.codec_of_node = codec_np;
+
+	/* Parse dai and platform info */
+	de1soc_dai.cpu_dai_name = NULL;
+	de1soc_dai.platform_name = NULL;
+	cpu_np = of_parse_phandle(np, "i2s-controller", 0);
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "dai and pcm info missing\n");
+		return -EINVAL;
+	}
+	de1soc_dai.cpu_of_node = cpu_np;
+	de1soc_dai.platform_of_node = cpu_np;
+
+	of_node_put(codec_np);
+	of_node_put(cpu_np);
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card() failed\n");
+	}
+
+	return ret;
+}
+
+static int de1soc_audio_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	if (gpio_is_valid(i2c_mux_gpio))
+		devm_gpio_free(&pdev->dev, i2c_mux_gpio);
+
+	snd_soc_unregister_card(card);
+
+	return 0;
+}
+
+static const struct of_device_id de1soc_wm8731_dt_ids[] = {
+	{ .compatible = "opencores,de1soc-wm8731-audio", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, de1soc_wm8731_dt_ids);
+
+static struct platform_driver de1soc_audio_driver = {
+	.driver = {
+		.name	= "de1soc-audio",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(de1soc_wm8731_dt_ids),
+	},
+	.probe	= de1soc_audio_probe,
+	.remove	= de1soc_audio_remove,
+};
+
+module_platform_driver(de1soc_audio_driver);
+
+/* Module information */
+MODULE_AUTHOR("Bjarne Steinsbo <bsteinsbo@gmail.com>");
+MODULE_DESCRIPTION("ALSA SoC DE1-SoC_WM8731");
+MODULE_LICENSE("GPL");
-- 
2.17.1


From 97226c1c1f665b00e88d98ea10c1becdc3fef3c3 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Fri, 8 Jun 2018 16:50:10 +0200
Subject: [PATCH 24/33] Rename Hsynth stream names

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 sound/soc/codecs/hsynthpcm5102.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/sound/soc/codecs/hsynthpcm5102.c b/sound/soc/codecs/hsynthpcm5102.c
index 414414670f15..bf40ad2dd911 100644
--- a/sound/soc/codecs/hsynthpcm5102.c
+++ b/sound/soc/codecs/hsynthpcm5102.c
@@ -21,8 +21,8 @@ static const struct snd_soc_dapm_widget hsynthpcm5102_widgets[] = {
 };
 
 static const struct snd_soc_dapm_route hsynthpcm5102_routes[] = {
-	{ "Playback", NULL, "PCMOUT" },
-    { "Capture", NULL, "HSYNTH" },
+	{ "PcmOut", NULL, "PCMOUT" },
+    { "HSynth", NULL, "HSYNTH" },
 };
 
 static int hsynthpcm5102_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
@@ -110,7 +110,7 @@ static const struct snd_soc_dai_ops hsynthpcm5102_dai_ops = {
 static struct snd_soc_dai_driver hsynthpcm5102_dai = {
 	.name = "hsynthpcm5102-hifi",
 	.playback = {
-		.stream_name = "Playback",
+		.stream_name = "PcmOut",
 		.channels_min = 2,
 		.channels_max = 2,
 		.rates = SNDRV_PCM_RATE_8000_96000,
@@ -118,7 +118,7 @@ static struct snd_soc_dai_driver hsynthpcm5102_dai = {
 			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,
 	},
     .capture = {
-		.stream_name = "Capture",
+		.stream_name = "HSynth",
 		.channels_min = 2,
 		.channels_max = 2,
 		.rates = SNDRV_PCM_RATE_8000_96000,
-- 
2.17.1


From b0fffbf455ee8c67488074cc5f6b318bfed11314 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sun, 10 Jun 2018 17:24:54 +0200
Subject: [PATCH 25/33] Add irq to De10 Nano vipii fb

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 .../boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
index 4b8b81316cf6..723f2a38e136 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
@@ -169,8 +169,8 @@
 			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
 			reg = <0x00000001 0x00030000 0x00000100>;
 			interrupt-parent = <&intc>;
-			interrupts = <0 0 4 0 2 1 0 1 1 0 3 4 0 4 4>;
-			interrupt-names = "jtag_uart", "button_pio", "dipsw_pio", "uioreg_io_0", "socmidi_0";
+			interrupts = <0 0 4 0 2 1 0 1 1 0 3 4 0 4 4 0 5 4>;
+			interrupt-names = "jtag_uart", "button_pio", "dipsw_pio", "uioreg_io_0", "socmidi_0", "alt_vip_cl_vfb_0";
 			interrupt-controller;
 			#interrupt-cells = <0x1>;
 			altr,sw-fifo-depth = <0x20>;
@@ -179,6 +179,8 @@
 		vip@0x100031000 {
 			compatible = "altr,vip-frame-buffer-ii-2.0";
 			reg = <0x00000001 0x00031000 0x00000080>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 45 4>;
 			max-width = <1920>;
 			max-height = <1080>;
 			bits-per-color = <0x8>;
-- 
2.17.1


From 3f90dc965076274ea97a1af587e1fec1dc5be781 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sun, 10 Jun 2018 18:13:46 +0200
Subject: [PATCH 26/33] Usb core fixes

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 ...pga_cyclone5_de10_nano_uio_aud_fbii_hd.dts |  2 ++
 drivers/usb/dwc2/core.h                       |  1 +
 drivers/usb/dwc2/platform.c                   | 24 ++++++++++++++++++-
 3 files changed, 26 insertions(+), 1 deletion(-)

diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
index 723f2a38e136..317c9c5a97c3 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
@@ -265,5 +265,7 @@
 };
 
 &usb1 {
+	disable-over-current;
+	dr_mode = "host";
 	status = "okay";
 };
diff --git a/drivers/usb/dwc2/core.h b/drivers/usb/dwc2/core.h
index 5095263482e5..98b35ada5238 100644
--- a/drivers/usb/dwc2/core.h
+++ b/drivers/usb/dwc2/core.h
@@ -873,6 +873,7 @@ struct dwc2_hsotg {
 	int     irq;
 	struct clk *clk;
 	struct reset_control *reset;
+	struct reset_control *reset_ecc;
 
 	unsigned int queuing_high_bandwidth:1;
 	unsigned int srp_success:1;
diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index fe2fc57bbc90..2de69d5df962 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -388,6 +388,23 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 	if (hsotg->reset)
 		reset_control_deassert(hsotg->reset);
 
+	hsotg->reset_ecc = devm_reset_control_get_optional(hsotg->dev, "dwc2-ecc");
+	if (IS_ERR(hsotg->reset_ecc)) {
+		ret = PTR_ERR(hsotg->reset_ecc);
+		switch (ret) {
+		case -ENOENT:
+		case -ENOTSUPP:
+			hsotg->reset_ecc = NULL;
+			break;
+		default:
+			dev_err(hsotg->dev, "error getting reset control for ecc %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (hsotg->reset_ecc)
+		reset_control_deassert(hsotg->reset_ecc);
+
 	/* Set default UTMI width */
 	hsotg->phyif = GUSBCFG_PHYIF16;
 
@@ -487,6 +504,8 @@ static int dwc2_driver_remove(struct platform_device *dev)
 
 	if (hsotg->reset)
 		reset_control_assert(hsotg->reset);
+	if (hsotg->reset_ecc)
+		reset_control_assert(hsotg->reset_ecc);
 
 	return 0;
 }
@@ -634,8 +653,11 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	/* Validate parameter values */
 	dwc2_set_parameters(hsotg, params);
 
-	if (of_find_property(hsotg->dev->of_node, "disable-over-current", NULL)) 
+	if (of_find_property(hsotg->dev->of_node, "disable-over-current", NULL))
+	{
 		hsotg->core_params->oc_disable = true;
+		dev_info(hsotg->dev, "disabling over-current protection\n");
+	}
 
 	dwc2_force_dr_mode(hsotg);
 
-- 
2.17.1


From 6be9c2f317a20a112cd05a08d2fbcaa2ad66c900 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sun, 10 Jun 2018 23:18:17 +0200
Subject: [PATCH 27/33] Add kernel debug stuff

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 4917bafcd7ae..4ca99129e968 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -181,7 +181,8 @@ CONFIG_NFSD_V4=y
 CONFIG_NLS_CODEPAGE_437=y
 CONFIG_NLS_ISO8859_1=y
 CONFIG_PRINTK_TIME=y
-CONFIG_DEBUG_INFO=n
+CONFIG_DEBUG_INFO=y
+CONFIG_PROC_KCORE=y
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_DETECT_HUNG_TASK=y
 # CONFIG_SCHED_DEBUG is not set
-- 
2.17.1


From 2865d74a0981310f1ad2cda34b9943cdb0e60e8e Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Mon, 11 Jun 2018 16:18:22 +0200
Subject: [PATCH 28/33] Sounddriver mods

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 ...pga_cyclone5_de10_nano_uio_aud_fbii_hd.dts |  4 +-
 arch/arm/configs/socfpga_defconfig            |  4 +-
 sound/soc/socsynth/Kconfig                    |  4 +-
 sound/soc/socsynth/Makefile                   |  8 +-
 .../{pcm5102-hsynth.c => hsynth-phdac.c}      | 78 +++++++++----------
 5 files changed, 49 insertions(+), 49 deletions(-)
 rename sound/soc/socsynth/{pcm5102-hsynth.c => hsynth-phdac.c} (85%)

diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
index 317c9c5a97c3..75a9d7a94c78 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
@@ -62,7 +62,7 @@
 	};
 
 	sound {
-		compatible = "opencores,hsynthpcm5102-audio";
+		compatible = "holotr,hsynthpcm5102-audio";
 		i2s-controller = <&i2s>;
 		audio-codec = <&hsynthpcm5102_codec>;
 	};
@@ -91,7 +91,7 @@
 		dma-names = "tx", "rx";
 	};
 
-	hsynthpcm5102_codec: hsynthpcm5102-codec {
+	hsynthpcm5102_codec: hsynthpcm5102-codec@34 {
 	#sound-dai-cells = <0>;
 		compatible = "holotr,hsynthpcm5102";
 		status = "okay";
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 4ca99129e968..14cf5aad9574 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -263,7 +263,7 @@ CONFIG_USB_GSPCA_SQ905C=y
 CONFIG_USB_GSPCA_SQ930X=y
 CONFIG_USB_GSPCA_STK014=y
 CONFIG_USB_GSPCA_STK1135=y
-+CONFIG_USB_GSPCA_STV0680=y
+CONFIG_USB_GSPCA_STV0680=y
 CONFIG_USB_GSPCA_SUNPLUS=y
 CONFIG_USB_GSPCA_T613=y
 CONFIG_USB_GSPCA_TOPRO=y
@@ -313,7 +313,7 @@ CONFIG_SND_SOC_DE1x_WM8731=m
 CONFIG_SND_SOC_DE1x_WM8731_HSYNTH=m
 CONFIG_SND_SOC_HSYNTH_MIDI=m
 CONFIG_SND_SOC_PCM5102A=m
-CONFIG_SND_SOC_PCM5102_HSYNTH=m
+CONFIG_SND_SOC_HSYNTH_PHDAC=m
 CONFIG_FPGADMA=m
 CONFIG_REGMAP_I2C=y
 CONFIG_REGMAP_SPI=y
diff --git a/sound/soc/socsynth/Kconfig b/sound/soc/socsynth/Kconfig
index b6b7dec7364c..9a0516c7f60f 100644
--- a/sound/soc/socsynth/Kconfig
+++ b/sound/soc/socsynth/Kconfig
@@ -16,7 +16,7 @@ config SND_SOC_HSYNTHDMA
          This driver can also be built as a module.  If so, the module
          will be called hsynthdma.
 
-config SND_SOC_DE1x_WM8731_HSYNTH
+config SND_SOC_DE1_WM8731_HSYNTH
        tristate "DE1-Audio MIDI support"
        select SND_SOC_WM8731
        select SND_SOC_OC_I2S
@@ -28,7 +28,7 @@ config SND_SOC_DE1x_WM8731_HSYNTH
 config SND_SOC_HSYNTH_MIDI
        tristate "Holosynth MIDI support"
 
-config SND_SOC_PCM5102_HSYNTH
+config SND_SOC_HSYNTH_PHDAC
        tristate "DE10-Nano-PiDac/Holosynth audio support"
        select SND_SOC_HSYNTHPCM5102
        select SND_SOC_OC_I2S
diff --git a/sound/soc/socsynth/Makefile b/sound/soc/socsynth/Makefile
index 69fb2aa3b284..caac9d6e9318 100644
--- a/sound/soc/socsynth/Makefile
+++ b/sound/soc/socsynth/Makefile
@@ -1,8 +1,8 @@
 snd-soc-opencores_i2s-objs := opencores_i2s.o
 obj-$(CONFIG_SND_SOC_OC_I2S) += snd-soc-opencores_i2s.o
 
-snd-de1-soc-wm8731-hsynth-objs := de1-soc-wm8731-hsynth.o
-obj-$(CONFIG_SND_SOC_DE1x_WM8731_HSYNTH) += snd-de1-soc-wm8731-hsynth.o
+snd-soc-de1-soc-wm8731-hsynth-objs := de1-soc-wm8731-hsynth.o
+obj-$(CONFIG_SND_SOC_DE1_WM8731_HSYNTH) += snd-soc-de1-soc-wm8731-hsynth.o
 
 snd-soc-hsynthdma-objs := hsynthdma.o
 obj-$(CONFIG_SND_SOC_HSYNTHDMA) += snd-soc-hsynthdma.o
@@ -10,8 +10,8 @@ obj-$(CONFIG_SND_SOC_HSYNTHDMA) += snd-soc-hsynthdma.o
 snd-soc-hsynth-midi-objs := hsynth-midi.o
 obj-$(CONFIG_SND_SOC_HSYNTH_MIDI) += snd-soc-hsynth-midi.o
 
-snd-pcm5102-hsynth-objs := pcm5102-hsynth.o
-obj-$(CONFIG_SND_SOC_PCM5102_HSYNTH) += snd-pcm5102-hsynth.o
+snd-soc-hsynth-phdac-objs := hsynth-phdac.o
+obj-$(CONFIG_SND_SOC_HSYNTH_PHDAC) += snd-soc-hsynth-phdac.o
 
 snd-soc-de1x-soc-wm8731-objs := de1x-soc-wm8731.o
 obj-$(CONFIG_SND_SOC_DE1x_WM8731) += snd-soc-de1x-soc-wm8731.o
diff --git a/sound/soc/socsynth/pcm5102-hsynth.c b/sound/soc/socsynth/hsynth-phdac.c
similarity index 85%
rename from sound/soc/socsynth/pcm5102-hsynth.c
rename to sound/soc/socsynth/hsynth-phdac.c
index 3011c2b42579..c99a5b485fee 100644
--- a/sound/soc/socsynth/pcm5102-hsynth.c
+++ b/sound/soc/socsynth/hsynth-phdac.c
@@ -161,7 +161,7 @@
 /*
 static unsigned int i2c_mux_gpio;
 
-static int de10soc_hw_params(struct snd_pcm_substream *substream,
+static int hspdac_hw_params(struct snd_pcm_substream *substream,
     struct snd_pcm_hw_params *params)
 {
     struct snd_soc_pcm_runtime *rtd = substream->private_data;
@@ -187,7 +187,7 @@ static int de10soc_hw_params(struct snd_pcm_substream *substream,
     return 0;
 }
 */
-// static void de10soc_shutdown(struct snd_pcm_substream *substream)
+// static void hspdac_shutdown(struct snd_pcm_substream *substream)
 // {
 //     struct snd_soc_pcm_runtime *rtd = substream->private_data;
 //     struct snd_soc_dai *codec_dai = rtd->codec_dai;
@@ -202,16 +202,16 @@ static int de10soc_hw_params(struct snd_pcm_substream *substream,
 //     }
 // }
 /*
-static struct snd_soc_ops de10soc_ops = {
+static struct snd_soc_ops hspdac_ops = {
     // .startup
-//    .shutdown = de10soc_shutdown,
-    .hw_params = de10soc_hw_params,
+//    .shutdown = hspdac_shutdown,
+    .hw_params = hspdac_hw_params,
     // .hw_free
     // .prepare
     // .trigger
 };
 */
-static const struct snd_soc_dapm_widget de10soc_dapm_widgets[] = {
+static const struct snd_soc_dapm_widget hspdac_dapm_widgets[] = {
     SND_SOC_DAPM_LINE("Line Out", NULL),
     SND_SOC_DAPM_LINE("Hsynth in", NULL),
 };
@@ -221,7 +221,7 @@ static const struct snd_soc_dapm_route intercon[] = {
     {"HSYNTH", NULL, "Hsynth in"},
 };
 
-static int de10soc_hsynthpcm5102_init(struct snd_soc_pcm_runtime *rtd)
+static int hspdac_init(struct snd_soc_pcm_runtime *rtd)
 {
     struct snd_soc_dai *codec_dai = rtd->codec_dai;
     struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
@@ -281,48 +281,48 @@ static int de10soc_hsynthpcm5102_init(struct snd_soc_pcm_runtime *rtd)
 //     return 0;
 // }
 
-static struct snd_soc_dai_link de10soc_dai = {
+static struct snd_soc_dai_link hspdac_dai = {
 //	{ /* Primary DAI i/f */
     .name = "SSND0",
     .stream_name = "HSYNTH PCM5102",
     .cpu_dai_name = "ff200000.i2s",
     .codec_dai_name = "hsynthpcm5102-hifi",
-    .init = de10soc_hsynthpcm5102_init,
-    .platform_name = "de10soc",
-    .codec_name = "hsynthpcm5102.hsynth",
-//    .ops = &de10soc_ops,
+    .init = hspdac_init,
+    .platform_name = "hspdac",
+    .codec_name = "hsynthpcm5102.0-001b",
+//    .ops = &hspdac_ops,
 // 	}, { /* Sec_Fifo Playback i/f */
 //     .name = "SSND1",
 //     .stream_name = "HSYNTH PCM",
 //     .cpu_dai_name = "ff200000.dmalink",
 //     .codec_dai_name = "hsynth7002-hifi",
 //     .init = soc_hsynth_init,
-//     .platform_name = "de10soc",
+//     .platform_name = "hspdac",
 //     .codec_name = "hsynth7002.hsynth",
 //	},
 };
 
-static struct snd_soc_card snd_soc_de10soc = {
+static struct snd_soc_card snd_soc_hspdac = {
     .name = "DE10SND",
     .owner = THIS_MODULE,
-    .dai_link = &de10soc_dai,
-//    .num_links = ARRAY_SIZE(de10soc_dai),
+    .dai_link = &hspdac_dai,
+//    .num_links = ARRAY_SIZE(hspdac_dai),
     .num_links = 1,
 
 //     .probe        = hmidi_card_probe,
 //     .remove       = hmidi_card_remove,
 
-    .dapm_widgets = de10soc_dapm_widgets,
-    .num_dapm_widgets = ARRAY_SIZE(de10soc_dapm_widgets),
+    .dapm_widgets = hspdac_dapm_widgets,
+    .num_dapm_widgets = ARRAY_SIZE(hspdac_dapm_widgets),
     .dapm_routes = intercon,
     .num_dapm_routes = ARRAY_SIZE(intercon),
 };
 
-static int de10soc_audio_probe(struct platform_device *pdev)
+static int hspdac_audio_probe(struct platform_device *pdev)
 {
     struct device_node *np = pdev->dev.of_node;
     struct device_node *codec_np, *cpu_np;
-    struct snd_soc_card *card = &snd_soc_de10soc;
+    struct snd_soc_card *card = &snd_soc_hspdac;
     int ret;
 
     if (!np) {
@@ -346,49 +346,49 @@ static int de10soc_audio_probe(struct platform_device *pdev)
 //     }
 
     /* Parse codec1 info */
-    de10soc_dai.codec_name = NULL;
+    hspdac_dai.codec_name = NULL;
     codec_np = of_parse_phandle(np, "audio-codec", 0);
     if (!codec_np) {
         dev_err(&pdev->dev, "audio-codec info missing\n");
         return -EINVAL;
     }
-    de10soc_dai.codec_of_node = codec_np;
+    hspdac_dai.codec_of_node = codec_np;
 
     /* Parse dai and platform info */
-    de10soc_dai.cpu_dai_name = NULL;
-    de10soc_dai.platform_name = NULL;
+    hspdac_dai.cpu_dai_name = NULL;
+    hspdac_dai.platform_name = NULL;
     cpu_np = of_parse_phandle(np, "i2s-controller", 0);
     if (!cpu_np) {
         dev_err(&pdev->dev, "i2s dai1 and pcm info missing\n");
         return -EINVAL;
     }
 
-    de10soc_dai.cpu_of_node = cpu_np;
-    de10soc_dai.platform_of_node = cpu_np;
+    hspdac_dai.cpu_of_node = cpu_np;
+    hspdac_dai.platform_of_node = cpu_np;
 
     of_node_put(codec_np);
     of_node_put(cpu_np);
 
     /* Parse codec2 info */
-//     de10soc_dai[1].codec_name = NULL;
+//     hspdac_dai[1].codec_name = NULL;
 //     codec_np = of_parse_phandle(np, "synth-codec", 0);
 //     if (!codec_np) {
 //         dev_err(&pdev->dev, "synth-codec info missing\n");
 //         return -EINVAL;
 //     }
-//     de10soc_dai[1].codec_of_node = codec_np;
+//     hspdac_dai[1].codec_of_node = codec_np;
 //
 //     /* Parse dai and platform info */
-//     de10soc_dai[1].cpu_dai_name = NULL;
-//     de10soc_dai[1].platform_name = NULL;
+//     hspdac_dai[1].cpu_dai_name = NULL;
+//     hspdac_dai[1].platform_name = NULL;
 //     cpu_np = of_parse_phandle(np, "dmalink-controller", 0);
 //     if (!cpu_np) {
 //         dev_err(&pdev->dev, "dmalink-controller info missing\n");
 //         return -EINVAL;
 //     }
 //
-//     de10soc_dai[1].cpu_of_node = cpu_np;
-//     de10soc_dai[1].platform_of_node = cpu_np;
+//     hspdac_dai[1].cpu_of_node = cpu_np;
+//     hspdac_dai[1].platform_of_node = cpu_np;
 //
 //     of_node_put(codec_np);
 //     of_node_put(cpu_np);
@@ -402,7 +402,7 @@ static int de10soc_audio_probe(struct platform_device *pdev)
     return ret;
 }
 
-static int de10soc_audio_remove(struct platform_device *pdev)
+static int hspdac_audio_remove(struct platform_device *pdev)
 {
     struct snd_soc_card *card = platform_get_drvdata(pdev);
 /*
@@ -415,22 +415,22 @@ static int de10soc_audio_remove(struct platform_device *pdev)
 }
 
 static const struct of_device_id hsynthpcm5102_dt_ids[] = {
-    { .compatible = "opencores,hsynthpcm5102-audio", },
+    { .compatible = "holotr,hsynthpcm5102-audio", },
     { }
 };
 MODULE_DEVICE_TABLE(of, hsynthpcm5102_dt_ids);
 
-static struct platform_driver de10soc_audio_driver = {
+static struct platform_driver hspdac_audio_driver = {
     .driver = {
-        .name	= "hsynth-audio",
+        .name	= "hsphdac-audio",
         .owner	= THIS_MODULE,
         .of_match_table = of_match_ptr(hsynthpcm5102_dt_ids),
     },
-    .probe	= de10soc_audio_probe,
-    .remove	= de10soc_audio_remove,
+    .probe	= hspdac_audio_probe,
+    .remove	= hspdac_audio_remove,
 };
 
-module_platform_driver(de10soc_audio_driver);
+module_platform_driver(hspdac_audio_driver);
 
 /* Module information */
 MODULE_AUTHOR("Bjarne Steinsbo <bsteinsbo@gmail.com>");
-- 
2.17.1


From 14ffd12bd41f1042156c1c701870808ea14d4865 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Fri, 15 Jun 2018 02:48:57 +0200
Subject: [PATCH 29/33] update DE10 devicetrees

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 .../boot/dts/socfpga_cyclone5_de10_nano.dts   | 113 +++++++++++++++---
 .../dts/socfpga_cyclone5_de10_nano_uio_fb.dts |   4 +-
 2 files changed, 97 insertions(+), 20 deletions(-)

diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts
index 7645340f9787..a767457e4354 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts
@@ -1,18 +1,18 @@
 /*
- * Copyright Intel Corporation (C) 2017. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
- */
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
 
 #include "socfpga_cyclone5.dtsi"
 
@@ -25,7 +25,7 @@
 		stdout-path = "serial0:115200n8";
 	};
 
-	memory@0 {
+	memory {
 		name = "memory";
 		device_type = "memory";
 		reg = <0x0 0x40000000>; /* 1GB */
@@ -50,6 +50,83 @@
 			linux,default-trigger = "heartbeat";
 		};
 	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+			<0x00000001 0x00002000 0xff202000 0x00000008>,
+			<0x00000001 0x00003000 0xff203000 0x00000010>,
+			<0x00000001 0x00004000 0xff204000 0x00000010>,
+			<0x00000001 0x00005000 0xff205000 0x00000010>,
+			<0x00000001 0x00030000 0xff230000 0x00000100>;
+
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <0xacd51302>;
+			timestamp = <0x5929e204>;
+		};
+
+		serial@0x100002000 {
+			compatible = "altr,juart-15.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00002000 0x00000008>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 40 0>;
+			clocks = <0x2>;
+		};
+
+		gpio@0x100003000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00003000 0x00000010>;
+			altr,gpio-bank-width = <0x8>;
+			resetvalue = <0xff>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100004000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00004000 0x00000010>;
+			altr,gpio-bank-width = <0x4>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 41 1>;
+			altr,interrupt-type = <0x3>;
+			altr,interrupt_type = <0x3>;
+			edge_type = <0x2>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100005000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00005000 0x00000010>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 42 2>;
+			altr,gpio-bank-width = <0x2>;
+			altr,interrupt-type = <0x2>;
+			altr,interrupt_type = <0x2>;
+			edge_type = <0x1>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+	};
 };
 
 &gmac1 {
@@ -86,13 +163,13 @@
 
 &i2c0 {
 	status = "okay";
-	clock-frequency = <100000>;
+	speed-mode = <0>;
 
 	adxl345: adxl345@0 {
-		compatible = "adi,adxl345";
+		compatible = "adi,adxl34x";
 		reg = <0x53>;
 
-		interrupt-parent = <&portc>;
+		interrupt-parent = <&intc>;
 		interrupts = <3 2>;
 	};
 };
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
index cc62324122c7..ac06b3c2f5cb 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
@@ -86,7 +86,7 @@
 			compatible = "altr,juart-15.1", "altr,juart-1.0";
 			reg = <0x00000001 0x00002000 0x00000008>;
 			interrupt-parent = <&intc>;
-			interrupts = <0 40 4>;
+			interrupts = <0 40 0>;
 			clocks = <0x2>;
 		};
 
@@ -118,7 +118,7 @@
 			compatible = "altr,pio-15.1", "altr,pio-1.0";
 			reg = <0x00000001 0x00005000 0x00000010>;
 			interrupt-parent = <&intc>;
-			interrupts = <0 42 1>;
+			interrupts = <0 42 2>;
 			altr,gpio-bank-width = <0x2>;
 			altr,interrupt-type = <0x2>;
 			altr,interrupt_type = <0x2>;
-- 
2.17.1


From 358ace9b9f5cead2ceb5934d80e989fc85e71a4c Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Fri, 12 Oct 2018 20:51:17 +0200
Subject: [PATCH 30/33] Add devicetree for DE10 Nano Touch screen Quartus
 project

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/Makefile                    |   1 +
 ...pga_cyclone5_de10_nano_uio_aud_fbii_ts.dts | 271 ++++++++++++++++++
 2 files changed, 272 insertions(+)
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_ts.dts

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index cd54d8e8f8fe..9f43fb195c1a 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -703,6 +703,7 @@ dtb-$(CONFIG_ARCH_SOCFPGA) += \
 	socfpga_cyclone5_de10_nano_uio_fb.dtb \
 	socfpga_cyclone5_de10_nano_uio_fb_hd.dtb \
 	socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dtb \
+	socfpga_cyclone5_de10_nano_uio_aud_fbii_ts.dtb \
 	socfpga_cyclone5_de10_nano.dtb \
 	socfpga_cyclone5_de1_soc.dtb \
 	socfpga_cyclone5_de1_soc_aud_fb.dtb \
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_ts.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_ts.dts
new file mode 100644
index 000000000000..d18c9bea582c
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_ts.dts
@@ -0,0 +1,271 @@
+/*
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE10-Nano";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	sound {
+		compatible = "holotr,hsynthpcm5102-audio";
+		i2s-controller = <&i2s>;
+		audio-codec = <&hsynthpcm5102_codec>;
+	};
+
+	clk48: clk48 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <24576000>;
+		clock-output-names = "clk48";
+	};
+
+	clk44: clk44 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <33868800>;
+		clock-output-names = "clk44";
+	};
+
+	i2s: i2s@0x0 {
+		#sound-dai-cells = <1>;
+		compatible = "opencores,i2s";
+		reg = <0xff200000 0x20>, <0xff200020 0x20>;
+		clocks = <&clk44>, <&clk48>;
+		clock-names = "clk44", "clk48";
+		dmas = <&pdma 0>, <&pdma 1>;
+		dma-names = "tx", "rx";
+	};
+
+	hsynthpcm5102_codec: hsynthpcm5102-codec@34 {
+	#sound-dai-cells = <0>;
+		compatible = "holotr,hsynthpcm5102";
+		status = "okay";
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+			<0x00000001 0x00002000 0xff202000 0x00000008>,
+			<0x00000001 0x00003000 0xff203000 0x00000010>,
+			<0x00000001 0x00004000 0xff204000 0x00000010>,
+			<0x00000001 0x00005000 0xff205000 0x00000010>,
+			<0x00000001 0x00030000 0xff230000 0x00000100>,
+			<0x00000001 0x00031000 0xff231000 0x00000040>,
+			<0x00000001 0x00040000 0xff240000 0x00010000>,
+			<0x00000001 0x00050000 0xff250000 0x00010000>;
+
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <0xacd51302>;
+			timestamp = <0x5929e204>;
+		};
+
+		serial@0x100002000 {
+			compatible = "altr,juart-15.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00002000 0x00000008>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 40 4>;
+		};
+
+		gpio@0x100003000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00003000 0x00000010>;
+			altr,gpio-bank-width = <0x8>;
+			resetvalue = <0xff>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};// (led_pio)
+
+		gpio@0x100004000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00004000 0x00000010>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 41 1>;
+			altr,gpio-bank-width = <0x4>;
+			altr,interrupt-type = <0x3>;
+			altr,interrupt_type = <0x3>;
+			edge_type = <0x2>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};// (dipsw_pio)
+
+		gpio@0x100005000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00005000 0x00000010>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 42 1>;
+			altr,gpio-bank-width = <0x2>;
+			altr,interrupt-type = <0x2>;
+			altr,interrupt_type = <0x2>;
+			edge_type = <0x1>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};// (button_pio)
+
+		ilc@0x100030000 {
+			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
+			reg = <0x00000001 0x00030000 0x00000100>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 0 4 0 2 1 0 1 1 0 3 4 0 4 4 0 5 4>;
+			interrupt-names = "jtag_uart", "button_pio", "dipsw_pio", "uioreg_io_0", "socmidi_0", "alt_vip_cl_vfb_0";
+			interrupt-controller;
+			#interrupt-cells = <0x1>;
+			altr,sw-fifo-depth = <0x20>;
+		};
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-buffer-ii-2.0";
+			reg = <0x00000001 0x00031000 0x00000040>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 45 4>;
+			max-width = <1366>;
+			max-height = <768>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+
+		uio-socfpg0@0x100040000 {
+			compatible = "generic-uio,ui_pdrv";
+			reg = <0x00000001 0x00040000 0x00010000>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 43 4>;
+			address_width = <14>;
+			data_width = <32>;
+		};
+
+		socmidi@0x100050000 {
+			compatible = "holotr,socsynth-midi";
+			reg = <0x00000001 0x00050000 0x00010000>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 44 4>;
+			address_width = <3>;   /* embeddedsw.dts.params.address_width type NUMBER */
+			data_width = <8>;      /* embeddedsw.dts.params.data_width type NUMBER */
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl34x";
+		reg = <0x53>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <3 2>;
+	};
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	disable-over-current;
+	dr_mode = "host";
+	status = "okay";
+};
-- 
2.17.1


From 31e08fcf6ab6b9407b2ef98d57f5b426aa0ff85f Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Tue, 16 Oct 2018 12:46:21 +0200
Subject: [PATCH 31/33] Add devicetree for DE1 Nano Touch screen Quartus
 project

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/Makefile                    |   1 +
 .../dts/socfpga_cyclone5_de1_soc_fb_ts.dts    | 285 ++++++++++++++++++
 2 files changed, 286 insertions(+)
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fb_ts.dts

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 9f43fb195c1a..3c6d56869ff2 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -709,6 +709,7 @@ dtb-$(CONFIG_ARCH_SOCFPGA) += \
 	socfpga_cyclone5_de1_soc_aud_fb.dtb \
 	socfpga_cyclone5_de1_soc_aud_fb_hd.dtb \
 	socfpga_cyclone5_de1_soc_fbii.dtb \
+	socfpga_cyclone5_de1_soc_fb_ts.dtb \
 	socfpga_cyclone5_sockit.dtb \
 	socfpga_cyclone5_socrates.dtb \
 	socfpga_cyclone5_sodia.dtb \
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fb_ts.dts b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fb_ts.dts
new file mode 100644
index 000000000000..5d39b86b2caa
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fb_ts.dts
@@ -0,0 +1,285 @@
+/*
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE1-SoC";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	sound {
+		compatible = "opencores,de1soc-wm8731-audio-midi";
+		i2s-controller = <&i2s>;
+		audio-codec = <&wm8731>;
+		i2c-mux-gpio = <&portb 19 0>;
+		dmalink-controller = <&dmalink>;
+		synth-codec = <&hsynth7002_codec>;
+	};
+
+	clk48: clk48 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <24576000>;
+		clock-output-names = "clk48";
+	};
+
+	clk44: clk44 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <33868800>;
+		clock-output-names = "clk44";
+	};
+
+	i2s: i2s@0x0 {
+		#sound-dai-cells = <1>;
+		compatible = "opencores,i2s";
+		reg = <0xff200000 0x20>, <0xff200040 0x20>;
+		clocks = <&clk44>, <&clk48>;
+		clock-names = "clk44", "clk48";
+		dmas = <&pdma 0>, <&pdma 1>, <&pdma 2>;
+		dma-names = "tx", "rx", "rx";
+	};
+
+	dmalink: dmalink@0x20 {
+		#sound-dai-cells = <1>;
+		compatible = "holotr,dmalink";
+		reg = <0xff200020 0x20>, <0xff200060 0x20>;
+		clocks = <&clk44>;
+		clock-names = "clk44";
+		dmas = <&pdma 2>;
+		dma-names = "rx";
+	};
+
+	hsynth7002_codec: hsynth7002-codec {
+	#sound-dai-cells = <0>;
+		compatible = "holotr,hsynth7002";
+/*     IOVDD-supply = <&supply>;*/
+		status = "okay";
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		bridge-enable = <1>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+			<0x00000001 0x00002000 0xff202000 0x00000008>,
+			<0x00000001 0x00003000 0xff203000 0x00000010>,
+			<0x00000001 0x00004000 0xff204000 0x00000010>,
+			<0x00000001 0x00005000 0xff205000 0x00000010>,
+			<0x00000001 0x00031000 0xff231000 0x00000080>,
+			<0x00000001 0x00040000 0xff240000 0x00010000>,
+			<0x00000001 0x00050000 0xff250000 0x00010000>;
+
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <2899645186>;
+			timestamp = <1524157570>;
+		};
+
+		serial@0x100002000 {
+			compatible = "altr,juart-17.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00002000 0x00000008>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 40 4>;
+			clocks = <0x2>;
+		}; //end serial@0x100020000 (jtag_uart)
+
+		gpio@0x100003000 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00003000 0x00000010>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 41 1>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <2>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			altr,interrupt-type = <2>;	/* embeddedsw.dts.params.altr,interrupt-type type NUMBER */
+			altr,interrupt_type = <2>;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
+			edge_type = <1>;	/* embeddedsw.dts.params.edge_type type NUMBER */
+			level_trigger = <0>;	/* embeddedsw.dts.params.level_trigger type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x1000100c0 (button_pio)
+
+		gpio@0x100004000 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00004000 0x00000010>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 42 1>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			altr,interrupt-type = <3>;	/* embeddedsw.dts.params.altr,interrupt-type type NUMBER */
+			altr,interrupt_type = <3>;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
+			edge_type = <2>;	/* embeddedsw.dts.params.edge_type type NUMBER */
+			level_trigger = <0>;	/* embeddedsw.dts.params.level_trigger type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x100010080 (dipsw_pio)
+
+		gpio@0x100005000 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00005000 0x00000010>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x100010040 (led_pio)
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-14.0";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <1366>;
+			max-height = <768>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+
+		uio-socfpg0@0x100040000 {
+			compatible = "generic-uio,ui_pdrv";
+			reg = <0x00000001 0x00040000 0x00010000>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 43 4>;
+			address_width = <14>;
+			data_width = <32>;
+		};
+
+		socmidi@0x100050000 {
+			compatible = "holotr,socsynth-midi";
+			reg = <0x00000001 0x00050000 0x00010000>;
+			interrupt-parent = <0x2>;
+/*			interrupts = <0 44 4>;*/
+			address_width = <3>;   /* embeddedsw.dts.params.address_width type NUMBER */
+			data_width = <8>;      /* embeddedsw.dts.params.data_width type NUMBER */
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	wm8731: wm8731@34 {
+		#sound-dai-cells = <0>;
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+	};
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl345";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&i2c1 {
+	status = "okay";
+	speed-mode = <0>;
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
-- 
2.17.1


From 1c853e0937106e4c3bdfce33dc804f19fa2fdde4 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sat, 12 Jan 2019 19:36:51 +0100
Subject: [PATCH 32/33] DE0_Nano_soc: Added devicetree entry for SPI Qsys core

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 .../boot/dts/socfpga_cyclone5_de0_sockit.dts  | 27 +++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de0_sockit.dts b/arch/arm/boot/dts/socfpga_cyclone5_de0_sockit.dts
index b280e6494193..b245fa4ad585 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de0_sockit.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de0_sockit.dts
@@ -50,6 +50,33 @@
 			linux,default-trigger = "heartbeat";
 		};
 	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00000000 0xff200000 0x00000020>;
+
+		spi_3: spi@0x100000000 {
+			compatible = "altr,spi-17.1", "altr,spi-1.0";
+			reg = <0x00000001 0x00000000 0x00000020>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 44 4>;
+			clocks = <&osc1>;
+		    #address-cells = <1>;
+			#size-cells = <0>;
+			bus-num = <0>;
+			num-chipselect = <1>;
+			status = "okay";
+		}; //end spi@0x100000000 (spi_3)
+
+		spidev3_fpga: spidev@0 {
+			compatible =  "rohm,dh2228fv";   /* appended from boardinfo */
+			reg = <0>;  /* appended from boardinfo */
+			spi-max-frequency = <2500000>;  /* appended from boardinfo */
+		};//end spidev@0
+	};
 };
 
 &gmac1 {
-- 
2.17.1


From c92e4ab68b372ea21aad9408374a33e18019c9f7 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sat, 12 Jan 2019 20:48:14 +0100
Subject: [PATCH 33/33] De0_Nano_Soc: Add hps spi0 device (on mux=0)

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/socfpga.dtsi | 15 ++++++++++++---
 1 file changed, 12 insertions(+), 3 deletions(-)

diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index dce11432fcbd..ddbd5a180eaa 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -786,15 +786,24 @@
 			interrupts = <0 39 4>;
 		};
 
-		spi0: spi@fff00000 {
+        spi0: spi@fff00000 {
 			compatible = "snps,dw-apb-ssi";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0xfff00000 0x1000>;
 			interrupts = <0 154 4>;
-			num-cs = <4>;
+			num-chipselect = <4>;
+			tx-dma-channel = <&pdma 16>;
+			rx-dma-channel = <&pdma 17>;
 			clocks = <&spi_m_clk>;
-			status = "disabled";
+			status = "okay";
+
+            spidev0: spidev@0 {
+                compatible = "rohm,dh2228fv";
+                reg = <0>;
+                spi-max-frequency = <100000000>;
+                enable-dma = <1>;
+            };
 		};
 
 		spi1: spi@fff01000 {
-- 
2.17.1

