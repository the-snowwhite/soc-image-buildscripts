From 2c901dd120fccc8a101e59a8ae1ccb48c832edb7 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Wed, 7 Mar 2018 14:14:18 +0100
Subject: [PATCH 01/16] disable debug package gen

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 98b007e..efc9ed9 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -166,7 +166,7 @@ CONFIG_NFSD_V4=y
 CONFIG_NLS_CODEPAGE_437=y
 CONFIG_NLS_ISO8859_1=y
 CONFIG_PRINTK_TIME=y
-CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO=n
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_DETECT_HUNG_TASK=y
 # CONFIG_SCHED_DEBUG is not set
-- 
2.7.4


From 4baf9c807b6ccfd97b414fe7020d334a73d1229e Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Tue, 1 May 2018 16:02:19 +0200
Subject: [PATCH 02/16] Remove gittag from kernel (file) name(s)

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index efc9ed9..f2b597b 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -1,3 +1,4 @@
+CONFIG_LOCALVERSION_AUTO=n
 CONFIG_SYSVIPC=y
 CONFIG_HIGH_RES_TIMERS=y
 CONFIG_IKCONFIG=y
-- 
2.7.4


From e50ba19829888a22eca3c3bcc732d4a4650ea58d Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Wed, 7 Mar 2018 14:21:56 +0100
Subject: [PATCH 03/16] add ext4 root fs support and autofs4 module

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index f2b597b..b167ffa7 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -13,7 +13,7 @@ CONFIG_PROFILING=y
 CONFIG_OPROFILE=y
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
-# CONFIG_LBDAF is not set
+CONFIG_LBDAF=y
 # CONFIG_BLK_DEV_BSG is not set
 # CONFIG_IOSCHED_DEADLINE is not set
 # CONFIG_IOSCHED_CFQ is not set
@@ -151,7 +151,10 @@ CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 CONFIG_EXT3_FS=y
-CONFIG_AUTOFS4_FS=y
+CONFIG_EXT4_FS=y
+# CONFIG_AUTOFS4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
 CONFIG_VFAT_FS=y
 CONFIG_NTFS_FS=y
 CONFIG_NTFS_RW=y
-- 
2.7.4


From 6f38cfeb7984dd52fea2e09dfbf4347cc4ab81d2 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Wed, 7 Mar 2018 14:26:50 +0100
Subject: [PATCH 04/16] add .dtd files to kernel-image .deb

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 scripts/package/builddeb | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/scripts/package/builddeb b/scripts/package/builddeb
index 3c575cd0..d67c791 100755
--- a/scripts/package/builddeb
+++ b/scripts/package/builddeb
@@ -128,7 +128,7 @@ BUILD_DEBUG="$(grep -s '^CONFIG_DEBUG_INFO=y' $KCONFIG_CONFIG || true)"
 # Setup the directory structure
 rm -rf "$tmpdir" "$fwdir" "$kernel_headers_dir" "$libc_headers_dir" "$dbg_dir" $objtree/debian/files
 mkdir -m 755 -p "$tmpdir/DEBIAN"
-mkdir -p "$tmpdir/lib" "$tmpdir/boot"
+mkdir -p "$tmpdir/lib" "$tmpdir/boot/dtb"
 mkdir -p "$fwdir/lib/firmware/$version/"
 mkdir -p "$kernel_headers_dir/lib/modules/$version/"
 
@@ -146,8 +146,10 @@ fi
 # Not all arches include the boot path in KBUILD_IMAGE
 if [ -e $KBUILD_IMAGE ]; then
 	cp $KBUILD_IMAGE "$tmpdir/$installed_image_path"
+	cp dts/*.dtb "$tmpdir/boot/dtb"
 else
 	cp arch/$ARCH/boot/$KBUILD_IMAGE "$tmpdir/$installed_image_path"
+	cp arch/$ARCH/boot/dts/*.dtb "$tmpdir/boot/dtb"
 fi
 
 if grep -q "^CONFIG_OF=y" $KCONFIG_CONFIG ; then
-- 
2.7.4


From 9380decb3207917981171d290f4d4d9eb4008f0e Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Wed, 7 Mar 2018 14:33:44 +0100
Subject: [PATCH 05/16] add generate /boot/extlinux/extlinux.conf and
 /boot/uEnv.txt for uboot boot info

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 scripts/package/builddeb | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/scripts/package/builddeb b/scripts/package/builddeb
index d67c791..d6a4058 100755
--- a/scripts/package/builddeb
+++ b/scripts/package/builddeb
@@ -203,6 +203,27 @@ if grep -q '^CONFIG_BLK_DEV_INITRD=y' $KCONFIG_CONFIG; then
 else
 	want_initrd=No
 fi
+# create uEnv.txt containing current kernelversio in /boot folder (for u-boot probing)
+cat <<EOF > "$tmpdir/boot/uEnv.txt"
+kver=${version}
+initrd_installed=$want_initrd
+hostname=holosynthv
+EOF
+cat <<'EOF' >> "$tmpdir/boot/uEnv.txt"
+fpgaload=mmc rescan;load mmc ${bootpart} ${loadaddr} ${bitimage}; fpga load 0 ${loadaddr} ${filesize}
+loadimage=run fpgaload; bridge enable; mw.b 0xffd05018 0xf0; load mmc ${bootpart} ${loadaddr} ${bootimage}; load mmc ${bootpart} ${fdt_addr} ${fdtimage}
+mmcboot=setenv bootargs console=ttyS0,115200 root=${mmcroot} rootfstype=ext4 rw rootwait fbcon=rotate:2;bootz ${loadaddr} - ${fdt_addr}
+EOF
+
+# create extlinux.conf in /boot folder (for u-boot probing)
+mkdir -p "$tmpdir/boot/extlinux"
+cat <<EOF > "$tmpdir/boot/extlinux/extlinux.conf"
+label Linux ${version}
+    kernel /boot/vmlinuz-$version
+    append  console=ttyS0,115200 root=/dev/mmcblk0p3 rw rootfstype=ext4 rootwait
+    fdtdir /boot/dtb
+EOF
+
 for script in postinst postrm preinst prerm ; do
 	mkdir -p "$tmpdir$debhookdir/$script.d"
 	cat <<EOF > "$tmpdir/DEBIAN/$script"
-- 
2.7.4


From d68a27ccb068f6dfc192c02cb2349cefcc40b7f9 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Wed, 7 Mar 2018 15:43:11 +0100
Subject: [PATCH 06/16] add configfs and fpgacfg dts entities, and dynamic dts
 overlay support

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index b167ffa7..a831d0c 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -62,8 +62,6 @@ CONFIG_MTD_NAND_DENALI_DT=y
 CONFIG_MTD_SPI_NOR=y
 # CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
 CONFIG_SPI_CADENCE_QUADSPI=y
-CONFIG_OF_OVERLAY=y
-CONFIG_OF_CONFIGFS=y
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_COUNT=2
 CONFIG_BLK_DEV_RAM_SIZE=8192
@@ -147,6 +145,11 @@ CONFIG_FPGA_BRIDGE=y
 CONFIG_SOCFPGA_FPGA_BRIDGE=y
 CONFIG_ALTERA_FREEZE_BRIDGE=y
 CONFIG_ALTERA_FREEZE_BRIDGE_PLAT=y
+CONFIG_UIO=m
+CONFIG_UIO_PDRV_GENIRQ=m
+CONFIG_OF_OVERLAY=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_OF_CONFIGFS=y
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
-- 
2.7.4


From 4ece76ab54b7da55f6cf0065726e890ebdb0813b Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sat, 10 Mar 2018 12:55:03 +0100
Subject: [PATCH 07/16] rename kernel package names to *-socfpga-rt-ltsi

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 scripts/package/builddeb | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/scripts/package/builddeb b/scripts/package/builddeb
index d6a4058..ee58811 100755
--- a/scripts/package/builddeb
+++ b/scripts/package/builddeb
@@ -96,9 +96,9 @@ fwdir="$objtree/debian/fwtmp"
 kernel_headers_dir="$objtree/debian/hdrtmp"
 libc_headers_dir="$objtree/debian/headertmp"
 dbg_dir="$objtree/debian/dbgtmp"
-packagename=linux-image-$version
-fwpackagename=linux-firmware-image-$version
-kernel_headers_packagename=linux-headers-$version
+packagename=linux-image-socfpga-rt-ltsi
+fwpackagename=linux-firmware-image-socfpga-rt-ltsi
+kernel_headers_packagename=linux-headers-socfpga-rt-ltsi
 libc_headers_packagename=linux-libc-dev
 dbg_packagename=$packagename-dbg
 debarch=
-- 
2.7.4


From 5276a88e1db02c5641b089a8ae94974b16769cb2 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sat, 10 Mar 2018 13:13:12 +0100
Subject: [PATCH 08/16] add spidev in dts so driver is loaded

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/socfpga.dtsi | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index 595eb4f..6dcff22 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -802,8 +802,17 @@
 			reg = <0xfff01000 0x1000>;
 			interrupts = <0 155 4>;
 			num-cs = <4>;
+			tx-dma-channel = <&pdma 20>;
+			rx-dma-channel = <&pdma 21>;
 			clocks = <&spi_m_clk>;
-			status = "disabled";
+			status = "okay";
+
+            spidev1: spidev@0 {
+                compatible = "rohm,dh2228fv";
+                reg = <0>;
+                spi-max-frequency = <100000000>;
+                enable-dma = <1>;
+            };
 		};
 
 		sysmgr: sysmgr@ffd08000 {
-- 
2.7.4


From bf165bb5a18ff9f15b177624bd5e9cb52b707658 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sun, 11 Mar 2018 22:21:04 +0100
Subject: [PATCH 09/16] Added DE-10 Nano with/without framebuffer 1024x768 and
 1920x1080(hd) dts dtb

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/Makefile                         |   3 +
 arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts   | 112 +++++++++++
 .../boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts | 205 +++++++++++++++++++++
 .../dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts   | 205 +++++++++++++++++++++
 4 files changed, 525 insertions(+)
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index b786f24..24fc153 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -700,6 +700,9 @@ dtb-$(CONFIG_ARCH_SOCFPGA) += \
 	socfpga_cyclone5_mcvevk.dtb \
 	socfpga_cyclone5_socdk.dtb \
 	socfpga_cyclone5_de0_sockit.dtb \
+	socfpga_cyclone5_de10_nano_uio_fb.dtb \
+	socfpga_cyclone5_de10_nano_uio_fb_hd.dtb \
+	socfpga_cyclone5_de10_nano.dtb \
 	socfpga_cyclone5_sockit.dtb \
 	socfpga_cyclone5_socrates.dtb \
 	socfpga_cyclone5_sodia.dtb \
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts
new file mode 100644
index 0000000..7645340
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano.dts
@@ -0,0 +1,112 @@
+/*
+ * Copyright Intel Corporation (C) 2017. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE10-Nano";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@0 {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	clock-frequency = <100000>;
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl345";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
new file mode 100644
index 0000000..51fa8dd
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb.dts
@@ -0,0 +1,205 @@
+/*
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE10-Nano";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+				<0x00000001 0x00002000 0xff202000 0x00000008>,
+				<0x00000001 0x00003000 0xff203000 0x00000010>,
+				<0x00000001 0x00004000 0xff204000 0x00000010>,
+				<0x00000001 0x00005000 0xff205000 0x00000010>,
+				<0x00000001 0x00030000 0xff230000 0x00000100>,
+				<0x00000001 0x00031000 0xff231000 0x00000080>;
+
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <0xacd51302>;
+			timestamp = <0x5929e204>;
+		};
+
+		serial@0x100002000 {
+			compatible = "altr,juart-15.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00002000 0x00000008>;
+			interrupt-parent = <0x3>;
+			interrupts = <0x0 0x2a 0x4>;
+			clocks = <0x2>;
+		};
+
+		gpio@0x100003000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00003000 0x00000010>;
+			altr,gpio-bank-width = <0x8>;
+			resetvalue = <0xff>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100004000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00004000 0x00000010>;
+			altr,gpio-bank-width = <0x4>;
+			altr,interrupt-type = <0x3>;
+			altr,interrupt_type = <0x3>;
+			edge_type = <0x2>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100005000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00005000 0x00000010>;
+			altr,gpio-bank-width = <0x2>;
+			altr,interrupt-type = <0x2>;
+			altr,interrupt_type = <0x2>;
+			edge_type = <0x1>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		ilc@0x100030000 {
+			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
+			reg = <0x00000001 0x00030000 0x00000100>;
+			interrupt-controller;
+			#interrupt-cells = <0x1>;
+			altr,sw-fifo-depth = <0x20>;
+		};
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-9.1";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <1024>;
+			max-height = <768>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl34x";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
new file mode 100644
index 0000000..d6c2df7
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_fb_hd.dts
@@ -0,0 +1,205 @@
+/*
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE10-Nano";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+				<0x00000001 0x00002000 0xff202000 0x00000008>,
+				<0x00000001 0x00003000 0xff203000 0x00000010>,
+				<0x00000001 0x00004000 0xff204000 0x00000010>,
+				<0x00000001 0x00005000 0xff205000 0x00000010>,
+				<0x00000001 0x00030000 0xff230000 0x00000100>,
+				<0x00000001 0x00031000 0xff231000 0x00000080>;
+
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <0xacd51302>;
+			timestamp = <0x5929e204>;
+		};
+
+		serial@0x100002000 {
+			compatible = "altr,juart-15.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00002000 0x00000008>;
+			interrupt-parent = <0x3>;
+			interrupts = <0x0 0x2a 0x4>;
+			clocks = <0x2>;
+		};
+
+		gpio@0x100003000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00003000 0x00000010>;
+			altr,gpio-bank-width = <0x8>;
+			resetvalue = <0xff>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100004000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00004000 0x00000010>;
+			altr,gpio-bank-width = <0x4>;
+			altr,interrupt-type = <0x3>;
+			altr,interrupt_type = <0x3>;
+			edge_type = <0x2>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100005000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00005000 0x00000010>;
+			altr,gpio-bank-width = <0x2>;
+			altr,interrupt-type = <0x2>;
+			altr,interrupt_type = <0x2>;
+			edge_type = <0x1>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		ilc@0x100030000 {
+			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
+			reg = <0x00000001 0x00030000 0x00000100>;
+			interrupt-controller;
+			#interrupt-cells = <0x1>;
+			altr,sw-fifo-depth = <0x20>;
+		};
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-9.1";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <1920>;
+			max-height = <1080>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl34x";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
-- 
2.7.4


From 9d61426c7d3b814b22e00ecd3881d4a2721ffd91 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Mon, 12 Mar 2018 23:41:23 +0100
Subject: [PATCH 10/16] set ACL secutity

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index a831d0c..a6b5b70 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -155,13 +155,17 @@ CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 CONFIG_EXT3_FS=y
 CONFIG_EXT4_FS=y
-# CONFIG_AUTOFS4_FS=y
 CONFIG_EXT4_FS_POSIX_ACL=y
 CONFIG_EXT4_FS_SECURITY=y
+CONFIG_EXT4_FS_XATTR=y
 CONFIG_VFAT_FS=y
 CONFIG_NTFS_FS=y
 CONFIG_NTFS_RW=y
+CONFIG_AUTOFS4_FS=m
 CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_SECURITY=y
+CONFIG_TMPFS_XATTR=y
 CONFIG_JFFS2_FS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3_ACL=y
@@ -179,3 +183,5 @@ CONFIG_DETECT_HUNG_TASK=y
 # CONFIG_SCHED_DEBUG is not set
 CONFIG_FUNCTION_TRACER=y
 CONFIG_DEBUG_USER=y
+CONFIG_ISCSI_TCP=m
+CONFIG_ISCSI_TARGET=m
-- 
2.7.4


From 0d31ff19e7a4e2c112a9ca7d5964df1b5dfb5e4d Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Fri, 30 Mar 2018 20:41:53 +0200
Subject: [PATCH 11/16] Enable altvip framebuffer

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/Kconfig                   |   1 +
 arch/arm/configs/socfpga_defconfig | 111 +++++++++++++++++++++++++++++++++++++
 2 files changed, 112 insertions(+)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 5715844..62f0881 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1737,6 +1737,7 @@ source "mm/Kconfig"
 
 config FORCE_MAX_ZONEORDER
 	int "Maximum zone order"
+	default "13" if ARCH_SOCFPGA
 	default "12" if SOC_AM33XX
 	default "9" if SA1111 || ARCH_EFM32
 	default "11"
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index a6b5b70..05ad8d5 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -185,3 +185,114 @@ CONFIG_FUNCTION_TRACER=y
 CONFIG_DEBUG_USER=y
 CONFIG_ISCSI_TCP=m
 CONFIG_ISCSI_TARGET=m
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_ARM_HEAVY_MB=y
+CONFIG_ARCH_SUPPORTS_BIG_ENDIAN=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_FORCE_MAX_ZONEORDER=13
+CONFIG_CMA=y
+CONFIG_DMA_CMA=y
+CONFIG_MEMORY_ISOLATION=y
+CONFIG_CMA_DEBUG=y
+CONFIG_CMA_DEBUGFS=y
+CONFIG_CMA_AREAS=7
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_FRAME_VECTOR=y
+CONFIG_CMA_SIZE_MBYTES=512
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_MEDIA_CONTROLLER_DVB=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_VMALLOC=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=y
+CONFIG_USB_M5602=y
+CONFIG_USB_STV06XX=y
+CONFIG_USB_GL860=y
+CONFIG_USB_GSPCA_BENQ=y
+CONFIG_USB_GSPCA_CONEX=y
+CONFIG_USB_GSPCA_CPIA1=y
+CONFIG_USB_GSPCA_DTCS033=y
+CONFIG_USB_GSPCA_ETOMS=y
+CONFIG_USB_GSPCA_FINEPIX=y
+CONFIG_USB_GSPCA_JEILINJ=y
+CONFIG_USB_GSPCA_JL2005BCD=y
+CONFIG_USB_GSPCA_KINECT=y
+CONFIG_USB_GSPCA_KONICA=y
+CONFIG_USB_GSPCA_MARS=y
+CONFIG_USB_GSPCA_MR97310A=y
+CONFIG_USB_GSPCA_NW80X=y
+CONFIG_USB_GSPCA_OV519=y
+CONFIG_USB_GSPCA_OV534=y
+CONFIG_USB_GSPCA_OV534_9=y
+CONFIG_USB_GSPCA_PAC207=y
+CONFIG_USB_GSPCA_PAC7302=y
+CONFIG_USB_GSPCA_PAC7311=y
+CONFIG_USB_GSPCA_SE401=y
+CONFIG_USB_GSPCA_SN9C2028=y
+CONFIG_USB_GSPCA_SN9C20X=y
+CONFIG_USB_GSPCA_SONIXB=y
+CONFIG_USB_GSPCA_SONIXJ=y
+CONFIG_USB_GSPCA_SPCA500=y
+CONFIG_USB_GSPCA_SPCA501=y
+CONFIG_USB_GSPCA_SPCA505=y
+CONFIG_USB_GSPCA_SPCA506=y
+CONFIG_USB_GSPCA_SPCA508=y
+CONFIG_USB_GSPCA_SPCA561=y
+CONFIG_USB_GSPCA_SPCA1528=y
+CONFIG_USB_GSPCA_SQ905=y
+CONFIG_USB_GSPCA_SQ905C=y
+CONFIG_USB_GSPCA_SQ930X=y
+CONFIG_USB_GSPCA_STK014=y
+CONFIG_USB_GSPCA_STK1135=y
++CONFIG_USB_GSPCA_STV0680=y
+CONFIG_USB_GSPCA_SUNPLUS=y
+CONFIG_USB_GSPCA_T613=y
+CONFIG_USB_GSPCA_TOPRO=y
+CONFIG_USB_GSPCA_TOUPTEK=y
+CONFIG_USB_GSPCA_TV8532=y
+CONFIG_USB_GSPCA_VC032X=y
+CONFIG_USB_GSPCA_VICAM=y
+CONFIG_USB_GSPCA_XIRLINK_CIT=y
+CONFIG_USB_GSPCA_ZC3XX=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_SOC_CAMERA=y
+CONFIG_SOC_CAMERA_PLATFORM=y
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_ALTERA_VIP=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+CONFIG_LIBCRC32C=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=y
+CONFIG_HID=y
+CONFIG_USB_HID=y
+CONFIG_HID_MULTITOUCH=y
+#CONFIG_ALTERA_PR_IP_CORE=y
+#CONFIG_ALTERA_PR_IP_CORE_PLAT=y
-- 
2.7.4


From 4b3b5eabf373f66bdc145fe1eb12db36d53f8958 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sun, 8 Apr 2018 22:39:54 +0200
Subject: [PATCH 12/16] Add audio and midi drivers for holosynth and builtin
 audio codec on de1 board

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/Makefile                     |   2 +-
 arch/arm/boot/dts/socfpga.dtsi                 |   2 +
 arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts | 266 +++++++++++++++
 arch/arm/configs/socfpga_defconfig             |  59 ++++
 sound/soc/Kconfig                              |   3 +-
 sound/soc/Makefile                             |   1 +
 sound/soc/codecs/Kconfig                       |   5 +
 sound/soc/codecs/Makefile                      |   2 +
 sound/soc/codecs/hsynth7002.c                  | 115 +++++++
 sound/soc/socsynth/Kconfig                     |  33 ++
 sound/soc/socsynth/Makefile                    |  11 +
 sound/soc/socsynth/de1-soc-wm8731.c            | 247 ++++++++++++++
 sound/soc/socsynth/holosynthv.c                | 292 +++++++++++++++++
 sound/soc/socsynth/hsynthdma.c                 | 418 ++++++++++++++++++++++++
 sound/soc/socsynth/opencores_i2s.c             | 436 +++++++++++++++++++++++++
 15 files changed, 1890 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
 create mode 100644 sound/soc/codecs/hsynth7002.c
 create mode 100644 sound/soc/socsynth/Kconfig
 create mode 100644 sound/soc/socsynth/Makefile
 create mode 100644 sound/soc/socsynth/de1-soc-wm8731.c
 create mode 100644 sound/soc/socsynth/holosynthv.c
 create mode 100644 sound/soc/socsynth/hsynthdma.c
 create mode 100644 sound/soc/socsynth/opencores_i2s.c

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 24fc153..b359216 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -702,7 +702,7 @@ dtb-$(CONFIG_ARCH_SOCFPGA) += \
 	socfpga_cyclone5_de0_sockit.dtb \
 	socfpga_cyclone5_de10_nano_uio_fb.dtb \
 	socfpga_cyclone5_de10_nano_uio_fb_hd.dtb \
-	socfpga_cyclone5_de10_nano.dtb \
+	socfpga_cyclone5_de1_soc.dtb \
 	socfpga_cyclone5_sockit.dtb \
 	socfpga_cyclone5_socrates.dtb \
 	socfpga_cyclone5_sodia.dtb \
diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index 6dcff22..dce1143 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -526,6 +526,7 @@
 			reg = <0xff400000 0x100000>;
 			resets = <&rst LWHPS2FPGA_RESET>;
 			clocks = <&l4_main_clk>;
+            bridge-enable = <1>;
 		};
 
 		fpga_bridge1: fpga_bridge@ff500000 {
@@ -533,6 +534,7 @@
 			reg = <0xff500000 0x10000>;
 			resets = <&rst HPS2FPGA_RESET>;
 			clocks = <&l4_main_clk>;
+            bridge-enable = <1>;
 		};
 
 		fpgamgr0: fpgamgr@ff706000 {
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
new file mode 100644
index 0000000..8912581
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
@@ -0,0 +1,266 @@
+/*
+ * Copyright Intel Corporation (C) 2017. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE1-SoC";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+    sound {
+		compatible = "opencores,de1soc-wm8731-audio";
+		i2s-controller = <&i2s>;
+		audio-codec = <&wm8731>;
+		i2c-mux-gpio = <&portb 19 0>;
+    };
+
+	clk48: clk48 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <24576000>;
+		clock-output-names = "clk48";
+	};
+
+	clk44: clk44 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <33868800>;
+		clock-output-names = "clk44";
+	};
+
+	i2s: i2s@0x0 {
+		#sound-dai-cells = <1>;
+		compatible = "opencores,i2s";
+		reg = <0xff200000 0x40>, <0xff200040 0x20>;
+		clocks = <&clk44>, <&clk48>;
+		clock-names = "clk44", "clk48";
+		dmas = <&pdma 0>, <&pdma 1>;
+		dma-names = "tx", "rx";
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		bridge-enable = <1>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00020000 0xff220000 0x00000008>,
+			<0x00000001 0x00031000 0xff231000 0x00000080>,
+			<0x00000001 0x00010000 0xff210000 0x00000008>,
+			<0x00000001 0x000100c0 0xff2100c0 0x00000010>,
+			<0x00000001 0x00010080 0xff210080 0x00000010>,
+			<0x00000001 0x00010040 0xff210040 0x00000010>,
+			<0x00000001 0x00040000 0xff240000 0x00010000>,
+			<0x00000001 0x00050000 0xff250000 0x00010000>;
+
+		serial@0x100020000 {
+			compatible = "altr,juart-17.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00020000 0x00000008>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 40 4>;
+			clocks = <0x2>;
+		}; //end serial@0x100020000 (jtag_uart)
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-reader-1.0", "ALTR,vip-frame-reader-14.0";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <0x556>;
+			max-height = <0x300>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+
+		sysid@0x100010000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00010000 0x00000008>;
+			id = <2899645186>;
+			timestamp = <1524157570>;
+		};
+
+		gpio@0x1000100c0 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x000100c0 0x00000010>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 41 1>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <2>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			altr,interrupt-type = <2>;	/* embeddedsw.dts.params.altr,interrupt-type type NUMBER */
+			altr,interrupt_type = <2>;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
+			edge_type = <1>;	/* embeddedsw.dts.params.edge_type type NUMBER */
+			level_trigger = <0>;	/* embeddedsw.dts.params.level_trigger type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x1000100c0 (button_pio)
+
+		gpio@0x100010080 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00010080 0x00000010>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 42 1>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			altr,interrupt-type = <3>;	/* embeddedsw.dts.params.altr,interrupt-type type NUMBER */
+			altr,interrupt_type = <3>;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
+			edge_type = <2>;	/* embeddedsw.dts.params.edge_type type NUMBER */
+			level_trigger = <0>;	/* embeddedsw.dts.params.level_trigger type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x100010080 (dipsw_pio)
+
+		gpio@0x100010040 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00010040 0x00000010>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x100010040 (led_pio)
+
+		uio-socfpg0@0x100040000 {
+            compatible = "generic-uio,ui_pdrv";
+			reg = <0x00000001 0x00040000 0x00010000>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 43 4>;
+			address_width = <14>;
+			data_width = <32>;
+		};
+
+		socmidi@0x100050000 {
+			compatible = "holotr,socmidi-1.0";
+			reg = <0x00000001 0x00050000 0x00010000>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 44 4>;
+			address_width = <3>;   /* embeddedsw.dts.params.address_width type NUMBER */
+			data_width = <8>;      /* embeddedsw.dts.params.data_width type NUMBER */
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	wm8731: wm8731@34 {
+		#sound-dai-cells = <0>;
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+	};
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl345";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&i2c1 {
+	status = "okay";
+	speed-mode = <0>;
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 05ad8d5..f340c40 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -296,3 +296,62 @@ CONFIG_USB_HID=y
 CONFIG_HID_MULTITOUCH=y
 #CONFIG_ALTERA_PR_IP_CORE=y
 #CONFIG_ALTERA_PR_IP_CORE_PLAT=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+CONFIG_SND_SOC_SIGMADSP=m
+CONFIG_SND_SOC_SIGMADSP_I2C=m
+CONFIG_SND_SOC_SSM2602=m
+CONFIG_SND_SOC_SSM2602_I2C=m
+CONFIG_SND_ALOOP=m
+CONFIG_SND_VIRMIDI=m
+CONFIG_SND_SOC_HOLOSYNTHV=m
+CONFIG_SND_SOC_DE1_WM8731=m
+CONFIG_SND_SOC_PCM5102A=m
+CONFIG_FPGADMA=m
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_RAWMIDI=y
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+CONFIG_SND_SEQUENCER=y
+CONFIG_SND_SEQ_DUMMY=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_SND_VERBOSE_PRINTK=y
+CONFIG_SND_DEBUG=y
+CONFIG_SND_DEBUG_VERBOSE=y
+CONFIG_SND_DMA_SGBUF=y
+CONFIG_SND_DRIVERS=y
+CONFIG_SND_DUMMY=m
+CONFIG_SND_SERIAL_U16550=m
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_DESIGNWARE_CORE=y
+CONFIG_I2C_OCORES=y
+CONFIG_REGULATOR_DEBUG=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_SND_ARM=y
+CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM=y
+CONFIG_SND_ATMEL_SOC=m
+CONFIG_SND_DESIGNWARE_I2S=m
+CONFIG_SND_SOC_FSL_ASRC=m
+CONFIG_SND_SOC_FSL_SAI=m
+CONFIG_SND_SOC_FSL_SSI=m
+CONFIG_SND_SOC_FSL_SPDIF=m
+CONFIG_SND_SOC_FSL_ESAI=m
+CONFIG_SND_SOC_IMX_AUDMUX=m
+CONFIG_SND_SOC_I2C_AND_SPI=y
+CONFIG_HZ_1000=y
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 182d92e..48d18da 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -13,7 +13,7 @@ menuconfig SND_SOC
 
 	  If you want ASoC support, you should say Y here and also to the
 	  specific driver for your SoC platform below.
-	  
+
 	  ASoC provides power efficient ALSA support for embedded battery powered
 	  SoC based systems like PDA's, Phones and Personal Media Players.
 
@@ -62,6 +62,7 @@ source "sound/soc/samsung/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/sirf/Kconfig"
 source "sound/soc/spear/Kconfig"
+source "sound/soc/socsynth/Kconfig"
 source "sound/soc/sti/Kconfig"
 source "sound/soc/sunxi/Kconfig"
 source "sound/soc/tegra/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 9a30f21..c802f47 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_SND_SOC)	+= samsung/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= sirf/
 obj-$(CONFIG_SND_SOC)	+= spear/
+obj-$(CONFIG_SND_SOC)	+= socsynth/
 obj-$(CONFIG_SND_SOC)	+= sti/
 obj-$(CONFIG_SND_SOC)	+= sunxi/
 obj-$(CONFIG_SND_SOC)	+= tegra/
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index c67667b..49e8c24 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -72,6 +72,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_ES8328_I2C if I2C
 	select SND_SOC_GTM601
 	select SND_SOC_HDAC_HDMI
+	select SND_SOC_HSYNTH7002
 	select SND_SOC_ICS43432
 	select SND_SOC_INNO_RK3036
 	select SND_SOC_ISABELLE if I2C
@@ -512,6 +513,10 @@ config SND_SOC_HDMI_CODEC
 	select SND_PCM_IEC958
 	select HDMI
 
+config SND_SOC_HSYNTH7002
+	tristate "Dummy Soc synthesizer codec-driver driver"
+
+
 config SND_SOC_ES8328
 	tristate "Everest Semi ES8328 CODEC"
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 958cd49..be562a4 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -66,6 +66,7 @@ snd-soc-es8328-i2c-objs := es8328-i2c.o
 snd-soc-es8328-spi-objs := es8328-spi.o
 snd-soc-gtm601-objs := gtm601.o
 snd-soc-hdac-hdmi-objs := hdac_hdmi.o
+snd-soc-hsynth7002-objs := hsynth7002.o
 snd-soc-ics43432-objs := ics43432.o
 snd-soc-inno-rk3036-objs := inno_rk3036.o
 snd-soc-isabelle-objs := isabelle.o
@@ -291,6 +292,7 @@ obj-$(CONFIG_SND_SOC_ES8328_I2C)+= snd-soc-es8328-i2c.o
 obj-$(CONFIG_SND_SOC_ES8328_SPI)+= snd-soc-es8328-spi.o
 obj-$(CONFIG_SND_SOC_GTM601)    += snd-soc-gtm601.o
 obj-$(CONFIG_SND_SOC_HDAC_HDMI) += snd-soc-hdac-hdmi.o
+obj-$(CONFIG_SND_SOC_HSYNTH7002)+= snd-soc-hsynth7002.o
 obj-$(CONFIG_SND_SOC_ICS43432)	+= snd-soc-ics43432.o
 obj-$(CONFIG_SND_SOC_INNO_RK3036)	+= snd-soc-inno-rk3036.o
 obj-$(CONFIG_SND_SOC_ISABELLE)	+= snd-soc-isabelle.o
diff --git a/sound/soc/codecs/hsynth7002.c b/sound/soc/codecs/hsynth7002.c
new file mode 100644
index 0000000..1c54d02
--- /dev/null
+++ b/sound/soc/codecs/hsynth7002.c
@@ -0,0 +1,115 @@
+/*
+ * HSYNTH7002 Soc Synthesizer dummy codec driver
+ *
+ * Copyright 2017 Holotronic
+ *  Michael Brown (the-snowwhite) <producer@holotronic.dk>
+ *  based on hsynth7002.c
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include <sound/soc.h>
+
+static const struct snd_soc_dapm_widget hsynth7002_widgets[] = {
+	SND_SOC_DAPM_INPUT("PDM_DAT"),
+	SND_SOC_DAPM_REGULATOR_SUPPLY("IOVDD", 0, 0),
+};
+
+static const struct snd_soc_dapm_route hsynth7002_routes[] = {
+	{ "Capture", NULL, "PDM_DAT" },
+	{ "Capture", NULL, "IOVDD" },
+};
+
+static int hsynth7002_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_DSP_A:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops hsynth7002_dai_ops = {
+	.set_fmt = hsynth7002_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver hsynth7002_dai = {
+	.name = "hsynth7002-hifi",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_96000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S18_3LE |
+			SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |
+			SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE,
+		.sig_bits = 20,
+	},
+	.ops = &hsynth7002_dai_ops,
+};
+
+static const struct snd_soc_codec_driver hsynth7002_codec_driver = {
+	.component_driver = {
+		.dapm_widgets = hsynth7002_widgets,
+		.num_dapm_widgets = ARRAY_SIZE(hsynth7002_widgets),
+		.dapm_routes = hsynth7002_routes,
+		.num_dapm_routes = ARRAY_SIZE(hsynth7002_routes),
+	},
+};
+
+static int hsynth7002_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &hsynth7002_codec_driver,
+			&hsynth7002_dai, 1);
+}
+
+static int hsynth7002_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+//#ifdef CONFIG_OF
+static const struct of_device_id hsynth7002_dt_ids[] = {
+	{ .compatible = "holotr,hsynth7002", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hsynth7002_dt_ids);
+//#endif
+
+static struct platform_driver hsynth7002_driver = {
+	.driver = {
+		.name = "hsynth7002",
+		.of_match_table	= of_match_ptr(hsynth7002_dt_ids),
+	},
+	.probe = hsynth7002_probe,
+	.remove = hsynth7002_remove,
+};
+module_platform_driver(hsynth7002_driver);
+
+MODULE_AUTHOR("Michael Brown <producer@holotronic.dk>");
+MODULE_DESCRIPTION("HSYNTH7002 Dummy Soc synthesizer codec-driver driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/socsynth/Kconfig b/sound/soc/socsynth/Kconfig
new file mode 100644
index 0000000..572c882
--- /dev/null
+++ b/sound/soc/socsynth/Kconfig
@@ -0,0 +1,33 @@
+config SND_SOC_HSYNTHDMA
+       tristate "holosynth DMA Controller"
+       help
+         If you say yes to this option, support will be included for the
+         HSYNTHDMA dma controller. For details see
+
+         This driver can also be built as a module.  If so, the module
+         will be called hsynthdma.
+
+config SND_SOC_OC_I2S
+       tristate "OpenCores I2S Controller"
+       help
+         If you say yes to this option, support will be included for the
+         OpenCores I2S controller. For details see
+
+         This driver can also be built as a module.  If so, the module
+         will be called opencores_i2s.
+
+config SND_SOC_HOLOSYNTHV
+       tristate "SOC-Synthsizer support"
+       select SND_SOC_HSYNTH7002
+       select SND_SOC_HSYNTHDMA
+       select SND_SOC_GENERIC_DMAENGINE_PCM
+       select SND_RAWMIDI
+       select REGMAP_MMIO
+       help
+         ASoC driver for fpga Sound Synthesizer peripheral with pcm / rawmidi support.
+
+config SND_SOC_DE1_WM8731
+       tristate "DE1-Audio support"
+       select SND_SOC_WM8731
+       select SND_SOC_OC_I2S
+       select REGMAP_MMIO
diff --git a/sound/soc/socsynth/Makefile b/sound/soc/socsynth/Makefile
new file mode 100644
index 0000000..d9e999e
--- /dev/null
+++ b/sound/soc/socsynth/Makefile
@@ -0,0 +1,11 @@
+snd-soc-opencores_i2s-objs := opencores_i2s.o
+obj-$(CONFIG_SND_SOC_OC_I2S) += snd-soc-opencores_i2s.o
+
+snd-de1-soc-wm8731-objs := de1-soc-wm8731.o
+obj-$(CONFIG_SND_SOC_DE1_WM8731) += snd-de1-soc-wm8731.o
+
+snd-soc-hsynthdma-objs := hsynthdma.o
+obj-$(CONFIG_SND_SOC_HSYNTHDMA) += snd-soc-hsynthdma.o
+
+snd-soc-holosynthv-objs := holosynthv.o
+obj-$(CONFIG_SND_SOC_HOLOSYNTHV) += snd-soc-holosynthv.o
diff --git a/sound/soc/socsynth/de1-soc-wm8731.c b/sound/soc/socsynth/de1-soc-wm8731.c
new file mode 100644
index 0000000..4e199bb
--- /dev/null
+++ b/sound/soc/socsynth/de1-soc-wm8731.c
@@ -0,0 +1,247 @@
+/*
+ * de1-soc-wm8731 -- SoC audio for Terasic DE1-SoC board
+ * Author: B. Steinsbo <bsteinsbo@gmail.com>
+ *
+ * Based on sam9g20_wm8731 by
+ * Sedji Gaouaou <sedji.gaouaou@atmel.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#define WM8731_SYSCLK_XTAL 1
+#define WM8731_SYSCLK_MCLK 2
+#define MCLK_RATE_48K 12288000 /* fs*256 */
+#define MCLK_RATE_44K 16934400 /* fs*384 */
+
+static unsigned int i2c_mux_gpio;
+
+static int de1soc_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct device *dev = rtd->card->dev;
+	unsigned int mclk_freq;
+	int ret;
+
+	if ((params_rate(params) % 44100) == 0) {
+		mclk_freq = MCLK_RATE_44K;
+	} else if ((params_rate(params) % 48000) == 0) {
+		mclk_freq = MCLK_RATE_48K;
+	} else
+		return -EINVAL;
+
+	/* set codec mclk configuration */
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+		mclk_freq, SND_SOC_CLOCK_OUT);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(dev, "hw_params: mclk_freq=%d\n", mclk_freq);
+	return 0;
+}
+
+static void de1soc_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct device *dev = rtd->card->dev;
+	int ret;
+
+	dev_dbg(dev, "shutdown\n");
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+		0, SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		dev_err(dev, "Failed to reset WM8731 SYSCLK: %d\n", ret);
+	}
+}
+
+static struct snd_soc_ops de1soc_ops = {
+	// .startup
+	.shutdown = de1soc_shutdown,
+	.hw_params = de1soc_hw_params,
+	// .hw_free
+	// .prepare
+	// .trigger
+};
+
+static const struct snd_soc_dapm_widget de1soc_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_MIC("Microphone Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+	SND_SOC_DAPM_LINE("Line Out Jack", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	{"MICIN", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Microphone Jack"},
+	{"LLINEIN", NULL, "Line In Jack"},
+	{"RLINEIN", NULL, "Line In Jack"},
+	{"Line Out Jack", NULL, "LOUT"},
+	{"Line Out Jack", NULL, "ROUT"},
+	{"Headphone Jack", NULL, "LHPOUT"},
+	{"Headphone Jack", NULL, "RHPOUT"},
+};
+
+static int de1soc_wm8731_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct device *dev = rtd->card->dev;
+	unsigned int fmt;
+	int ret;
+
+	dev_dbg(dev, "init\n");
+
+	fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	      SND_SOC_DAIFMT_CBS_CFS;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+	if (ret < 0)
+		return ret;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0)
+		return ret;
+
+	/* Don't let codec constraints interfere */
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+		0, SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set WM8731 SYSCLK: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_dai_link de1soc_dai = {
+	.name = "WM8731",
+	.stream_name = "WM8731 PCM",
+	.cpu_dai_name = "ff200000.i2s",
+	.codec_dai_name = "wm8731-hifi",
+	.init = de1soc_wm8731_init,
+	.platform_name = "de1soc",
+	.codec_name = "wm8731.0-001a",
+	.ops = &de1soc_ops,
+};
+
+static struct snd_soc_card snd_soc_de1soc = {
+	.name = "DE1SOC-WM8731",
+	.owner = THIS_MODULE,
+	.dai_link = &de1soc_dai,
+	.num_links = 1,
+
+	.dapm_widgets = de1soc_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(de1soc_dapm_widgets),
+	.dapm_routes = intercon,
+	.num_dapm_routes = ARRAY_SIZE(intercon),
+};
+
+static int de1soc_audio_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *codec_np, *cpu_np;
+	struct snd_soc_card *card = &snd_soc_de1soc;
+	int ret;
+
+	if (!np) {
+		return -ENODEV;
+	}
+
+	card->dev = &pdev->dev;
+
+	/* I2C bus is muxed between HPS and FPGA. Set mux to HPS */
+	i2c_mux_gpio = of_get_named_gpio(np, "i2c-mux-gpio", 0);
+	if (gpio_is_valid(i2c_mux_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev,
+			i2c_mux_gpio, GPIOF_OUT_INIT_LOW, "I2C_MUX");
+		if (ret) {
+			dev_err(&pdev->dev,
+				"Failed to request GPIO_%d for i2c_mux: %d\n",
+				i2c_mux_gpio, ret);
+			return ret;
+		}
+		gpio_set_value(i2c_mux_gpio, 1);
+	}
+
+	/* Parse codec info */
+	de1soc_dai.codec_name = NULL;
+	codec_np = of_parse_phandle(np, "audio-codec", 0);
+	if (!codec_np) {
+		dev_err(&pdev->dev, "codec info missing\n");
+		return -EINVAL;
+	}
+	de1soc_dai.codec_of_node = codec_np;
+
+	/* Parse dai and platform info */
+	de1soc_dai.cpu_dai_name = NULL;
+	de1soc_dai.platform_name = NULL;
+	cpu_np = of_parse_phandle(np, "i2s-controller", 0);
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "dai and pcm info missing\n");
+		return -EINVAL;
+	}
+	de1soc_dai.cpu_of_node = cpu_np;
+	de1soc_dai.platform_of_node = cpu_np;
+
+	of_node_put(codec_np);
+	of_node_put(cpu_np);
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card() failed\n");
+	}
+
+	return ret;
+}
+
+static int de1soc_audio_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	if (gpio_is_valid(i2c_mux_gpio))
+		devm_gpio_free(&pdev->dev, i2c_mux_gpio);
+
+	snd_soc_unregister_card(card);
+
+	return 0;
+}
+
+static const struct of_device_id de1soc_wm8731_dt_ids[] = {
+	{ .compatible = "opencores,de1soc-wm8731-audio", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, de1soc_wm8731_dt_ids);
+
+static struct platform_driver de1soc_audio_driver = {
+	.driver = {
+		.name	= "de1soc-audio",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(de1soc_wm8731_dt_ids),
+	},
+	.probe	= de1soc_audio_probe,
+	.remove	= de1soc_audio_remove,
+};
+
+module_platform_driver(de1soc_audio_driver);
+
+/* Module information */
+MODULE_AUTHOR("Bjarne Steinsbo <bsteinsbo@gmail.com>");
+MODULE_DESCRIPTION("ALSA SoC DE1-SoC_WM8731");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/socsynth/holosynthv.c b/sound/soc/socsynth/holosynthv.c
new file mode 100644
index 0000000..60104716d
--- /dev/null
+++ b/sound/soc/socsynth/holosynthv.c
@@ -0,0 +1,292 @@
+/*
+ * hsynth-soc -- SoC audio ( midi for Altera SoC boards
+ * Author: Michael Brown the-snowwhite <producer@holotronic.dk>
+ *
+ * Based on de1-soc-wm8731 by
+ *  B. Steinsbo <bsteinsbo@gmail.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/uaccess.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/seq_kernel.h>
+#include <sound/rawmidi.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#define SYNTHSOCSOUND_LOG_PREFIX "synthsound: "
+
+#define HSYNTH_SYSCLK_MCLK 2
+//#define MCLK_RATE_48K 12288000 /* fs*256 */
+#define MCLK_RATE_44K 16934400 /* fs*384 */
+#define midi_ins 0
+#define midi_outs 1
+
+#define MIDIREG_BASE 0xff200000
+#define MIDIREG_SIZE PAGE_SIZE
+#define MIDIREG_OFFSET 0x50000
+
+#define printe(...) pr_err(SYNTHSOCSOUND_LOG_PREFIX __VA_ARGS__)
+
+static int snd_socmidi_open(struct snd_rawmidi_substream *substream);
+static int snd_socmidi_close(struct snd_rawmidi_substream *substream);
+static int hmidi_card_probe(struct snd_soc_card *card);
+static int hmidi_card_remove(struct snd_soc_card *card);
+static void snd_socmidi_transmit(unsigned char data);
+static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int);
+static int hsound_midi_init(struct snd_card *card);
+
+void *midireg_mem;
+
+static int snd_socmidi_open(struct snd_rawmidi_substream *substream)
+{
+    return 0;
+}
+
+static int snd_socmidi_close(struct snd_rawmidi_substream *substream)
+{
+    return 0;
+}
+
+static int hmidi_card_probe(struct snd_soc_card *card)
+{
+    int err;
+
+    err = hsound_midi_init(card->snd_card);
+
+    if (err < 0) {
+        //		dev_dbg(&pdev->dev,"hsound_midi_init failed: %d\n", err);
+        return err;
+    }
+
+    return 0;
+}
+
+static int hmidi_card_remove(struct snd_soc_card *card)
+{
+    return 0;
+}
+
+static void snd_socmidi_transmit(unsigned char data){
+
+    iowrite8(data, midireg_mem);
+
+}
+
+static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int up) {
+
+    if (!up)
+        return;
+
+    while (1) {
+        unsigned char data;
+        if (snd_rawmidi_transmit(substream, &data, 1) != 1)
+            break; /* no more data */
+            snd_socmidi_transmit(data);
+    }
+}
+
+static struct snd_rawmidi *g_rmidi;
+
+static struct snd_rawmidi_ops snd_socmidi_output_ops = {
+    .open = snd_socmidi_open,
+    .close = snd_socmidi_close,
+    .trigger = snd_socmidi_output_trigger,
+};
+
+static void pisnd_get_port_info(struct snd_rawmidi *rmidi, int number, struct snd_seq_port_info *seq_port_info)
+{
+    seq_port_info->type =
+    SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
+    SNDRV_SEQ_PORT_TYPE_HARDWARE |
+    SNDRV_SEQ_PORT_TYPE_PORT;
+    seq_port_info->midi_voices = 0;
+}
+
+static struct snd_rawmidi_global_ops hsnd_global_ops = {.get_port_info = pisnd_get_port_info, };
+
+static int hsound_midi_init(struct snd_card *card)
+{
+    int err;
+    struct resource *res;
+
+    err = snd_rawmidi_new(card, "SocMIDI", 0, midi_outs, midi_ins, &g_rmidi);
+
+    if (err < 0) {
+        printe("snd_rawmidi_new failed: %d\n", err);
+        return err;
+    }
+
+    strcpy(g_rmidi->name, "Holosynth MIDI ");
+
+    g_rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT;
+    // rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
+    //                     SNDRV_RAWMIDI_INFO_INPUT |
+    //                     SNDRV_RAWMIDI_INFO_DUPLEX;
+
+    g_rmidi->ops = &hsnd_global_ops;
+
+    g_rmidi->private_data = (void *)0;
+
+    snd_rawmidi_set_ops(g_rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_socmidi_output_ops);
+    //    snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_socmidi_input_ops);
+
+    res = request_mem_region((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE, "MIDIREG");
+    if (res == NULL) {
+        return -EBUSY;
+    }
+
+    midireg_mem = ioremap((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE);
+    if (midireg_mem == NULL) {
+        release_mem_region(MIDIREG_BASE, MIDIREG_SIZE);
+        return -EFAULT;
+    }
+
+    return 0;
+}
+
+static const struct snd_soc_dapm_widget soc_dapm_widgets[] = {
+    SND_SOC_DAPM_LINE("Hsynth in", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+    {"PDM_DAT", NULL, "Hsynth in"},
+};
+
+static int soc_hsynth_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct device *dev = rtd->card->dev;
+    unsigned int fmt;
+    int ret;
+
+    dev_dbg(dev, "init\n");
+
+    fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+    SND_SOC_DAIFMT_CBS_CFS;
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    return 0;
+}
+
+static struct snd_soc_dai_link hsynth_soc_dai = {
+    .name = "HSYNTH",
+    .stream_name = "HSYNTH PCM",
+    .cpu_dai_name = "ff200000.dmalink",
+    .codec_dai_name = "hsynth7002-hifi",
+    .init = soc_hsynth_init,
+    .platform_name = "socsynth",
+    .codec_name = "hsynth7002.hsynth",
+};
+
+static struct snd_soc_card snd_soc_hsynth_soc = {
+    .name = "HOLOSYNTHV",
+    .owner = THIS_MODULE,
+    .dai_link = &hsynth_soc_dai,
+    .num_links = 1,
+
+    .probe        = hmidi_card_probe,
+    .remove       = hmidi_card_remove,
+
+    .dapm_widgets = soc_dapm_widgets,
+    .num_dapm_widgets = ARRAY_SIZE(soc_dapm_widgets),
+    .dapm_routes = intercon,
+    .num_dapm_routes = ARRAY_SIZE(intercon),
+};
+
+static int hsynth_soc_audio_probe(struct platform_device *pdev)
+{
+    struct device_node *np = pdev->dev.of_node;
+    struct device_node *codec_np, *cpu_np;
+    struct snd_soc_card *card = &snd_soc_hsynth_soc;
+    int ret;
+
+    if (!np) {
+        return -ENODEV;
+    }
+
+    card->dev = &pdev->dev;
+
+    /* Parse codec info */
+    hsynth_soc_dai.codec_name = NULL;
+    codec_np = of_parse_phandle(np, "audio-codec", 0);
+    if (!codec_np) {
+        dev_err(&pdev->dev, "codec info missing\n");
+        return -EINVAL;
+    }
+    hsynth_soc_dai.codec_of_node = codec_np;
+
+    /* Parse dai and platform info */
+    hsynth_soc_dai.cpu_dai_name = NULL;
+    hsynth_soc_dai.platform_name = NULL;
+    cpu_np = of_parse_phandle(np, "dmalink-controller", 0);
+    if (!cpu_np) {
+        dev_err(&pdev->dev, "dai and pcm info missing\n");
+        return -EINVAL;
+    }
+    hsynth_soc_dai.cpu_of_node = cpu_np;
+    hsynth_soc_dai.platform_of_node = cpu_np;
+
+    of_node_put(codec_np);
+    of_node_put(cpu_np);
+
+    ret = snd_soc_register_card(card);
+    if (ret) {
+        dev_err(&pdev->dev, "snd_soc_register_card() failed\n");
+    }
+
+    return ret;
+}
+
+static int soc_audio_remove(struct platform_device *pdev)
+{
+    struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+    snd_soc_unregister_card(card);
+
+    return 0;
+}
+
+static const struct of_device_id soc_hsynth_dt_ids[] = {
+    { .compatible = "holotr,socsynth-audio", },
+    { }
+};
+MODULE_DEVICE_TABLE(of, soc_hsynth_dt_ids);
+
+static struct platform_driver soc_audio_driver = {
+    .driver = {
+        .name	= "soc-synth-audio",
+        .owner	= THIS_MODULE,
+        .of_match_table = of_match_ptr(soc_hsynth_dt_ids),
+    },
+    .probe	= hsynth_soc_audio_probe,
+    .remove	= soc_audio_remove,
+};
+
+module_platform_driver(soc_audio_driver);
+
+/* Module information */
+MODULE_AUTHOR("Michael Brown (the-snowwhite) <producer@holotronic.dk>");
+MODULE_DESCRIPTION("ALSA SoC HOLOSYNTHV");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/socsynth/hsynthdma.c b/sound/soc/socsynth/hsynthdma.c
new file mode 100644
index 0000000..afb4850
--- /dev/null
+++ b/sound/soc/socsynth/hsynthdma.c
@@ -0,0 +1,418 @@
+/*
+* Copyright (C) 2017 Michael Brown (the-snowwhite) <producer@holotronic.dk>
+* Largely based on opencores_i2s.c by Bjarne Steinsbo <bsteinsbo@gmail.com>.
+*
+* Licensed under the GPL-2.
+*/
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+//#define DAC_FIFO_ADDR  0x00
+#define STATUS_ADDR    0x04
+#define CMD_ADDR       0x08
+#define ADC_FIFO_ADDR  0x00
+
+/* Commands to register at CMD_ADDR */
+#define PB_FIFO_CLEAR  BIT(0)
+#define PB_ENABLE      BIT(1)
+#define CAP_FIFO_CLEAR BIT(2)
+#define CAP_ENABLE     BIT(3)
+
+#define CLK_CTRL1      0x00
+#define CLK_CTRL2      0x04
+
+/* Bit-fields of clk control register 1 */
+#define CLK_MASTER_SLAVE  BIT(0)
+#define CLK_SEL_48_44    BIT(1)
+#define MCLK_DIV_SHIFT   (24)
+#define MCLK_DIV_MASK    GENMASK(MCLK_DIV_SHIFT + 7, MCLK_DIV_SHIFT)
+#define BCLK_DIV_SHIFT   (16)
+#define BCLK_DIV_MASK    GENMASK(BCLK_DIV_SHIFT + 7, BCLK_DIV_SHIFT)
+/* Bit-fields of clk control register 2 */
+#define PB_LRC_DIV_SHIFT  (8)
+#define PB_LRC_DIV_MASK          GENMASK(PB_LRC_DIV_SHIFT + 7, PB_LRC_DIV_SHIFT)
+#define CAP_LRC_DIV_SHIFT (0)
+#define CAP_LRC_DIV_MASK  GENMASK(CAP_LRC_DIV_SHIFT + 7, CAP_LRC_DIV_SHIFT)
+
+/* The frame size is not configurable */
+#define BITS_PER_FRAME 64
+
+struct holotr_dmalink {
+    struct regmap *regmap_data;
+    struct regmap *regmap_clk;
+//       struct clk *clk48;
+    struct clk *clk44;
+
+    struct snd_soc_dai_driver dai_driver;
+
+    struct snd_dmaengine_dai_dma_data capture_dma_data;
+//       struct snd_dmaengine_dai_dma_data playback_dma_data;
+
+    struct snd_ratnum ratnum;
+    struct snd_pcm_hw_constraint_ratnums rate_constraints;
+};
+
+static int holotr_dmalink_trigger(struct snd_pcm_substream *substream, int cmd,
+    struct snd_soc_dai *dai)
+{
+    struct holotr_dmalink *dmalink = snd_soc_dai_get_drvdata(dai);
+    unsigned int mask, val;
+
+    if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+            mask = CAP_ENABLE;
+    else
+            mask = PB_ENABLE;
+
+    switch (cmd) {
+    case SNDRV_PCM_TRIGGER_START:
+    case SNDRV_PCM_TRIGGER_RESUME:
+    case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+            val = mask;
+            break;
+    case SNDRV_PCM_TRIGGER_STOP:
+    case SNDRV_PCM_TRIGGER_SUSPEND:
+    case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+            val = 0;
+            break;
+    default:
+            return -EINVAL;
+    }
+
+    regmap_update_bits(dmalink->regmap_data, CMD_ADDR, mask, val);
+//     regmap_write(dmalink->regmap_data, CMD_ADDR, val);
+
+    dev_dbg(dai->dev, "trigger %x\n", val);
+    return 0;
+}
+
+static int divisor_value(unsigned long xtal_rate, unsigned long rate, int shift)
+{
+    return ((xtal_rate / rate / 2) >> shift) - 1;
+}
+
+static int holotr_dmalink_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+    struct holotr_dmalink *dmalink = snd_soc_dai_get_drvdata(dai);
+    unsigned long xtal_rate;
+    int lrclk_div;
+    int mclk_div;
+    int bclk_div;
+    int mask, val;
+    int mask2, val2;
+
+    dev_dbg(dai->dev, "hw_params fmt=0x%x\n", params_format(params));
+    dev_dbg(dai->dev, "hw_params rate=%d\n", params_rate(params));
+    if (params_format(params) != SNDRV_PCM_FORMAT_S32_LE)
+            return -EINVAL;
+
+    if ((params_rate(params) % 44100) == 0) {
+        val = CLK_SEL_48_44;
+        xtal_rate = clk_get_rate(dmalink->clk44);
+        mclk_div = divisor_value(xtal_rate, 16934400, 0); /* fs*384 at 44.1kHz */
+    }
+//    else if ((params_rate(params) % 48000) == 0) {
+//      val = 0;
+//      xtal_rate = clk_get_rate(dmalink->clk48);
+//      mclk_div = divisor_value(xtal_rate, 12288000, 0); /* fs*256 at 48kHz */
+//    }
+    else
+        return -EINVAL;
+
+    mask = CLK_SEL_48_44;
+    mask2 = 0;
+
+    lrclk_div = divisor_value(xtal_rate, params_rate(params), 4);
+    bclk_div = divisor_value(xtal_rate, params_rate(params) * BITS_PER_FRAME, 0);
+    dev_dbg(dai->dev, "hw_params mclk_div=%d\n", mclk_div);
+    dev_dbg(dai->dev, "hw_params lrclk_div=%d\n", lrclk_div);
+    dev_dbg(dai->dev, "hw_params bclk_div=%d\n", bclk_div);
+    val |= mclk_div << MCLK_DIV_SHIFT;
+    mask |= MCLK_DIV_MASK;
+    val |= bclk_div << BCLK_DIV_SHIFT;
+    mask |= BCLK_DIV_MASK;
+    regmap_update_bits(dmalink->regmap_clk, CLK_CTRL1, mask, val);
+    dev_dbg(dai->dev, "hw_params mask=0x%x val=0x%x\n", mask, val);
+    if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+        val2 = lrclk_div << CAP_LRC_DIV_SHIFT;
+        mask2 = CAP_LRC_DIV_MASK;
+    } else {
+        val2 = lrclk_div << PB_LRC_DIV_SHIFT;
+        mask2 = PB_LRC_DIV_MASK;
+    }
+    regmap_update_bits(dmalink->regmap_clk, CLK_CTRL2, mask2, val2);
+    dev_dbg(dai->dev, "hw_params mask2=0x%x val2=0x%x\n", mask2, val2);
+    return 0;
+}
+
+static int holotr_dmalink_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+    struct holotr_dmalink *dmalink = snd_soc_dai_get_drvdata(dai);
+    int val = 0;
+    dev_dbg(dai->dev, "set_fmt 0x%x\n", fmt);
+
+    if ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_I2S)
+        return -EINVAL;
+
+    if ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF)
+        return -EINVAL;
+
+    switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+    case SND_SOC_DAIFMT_CBM_CFM:
+        val = 0;
+        break;
+    case SND_SOC_DAIFMT_CBS_CFS:
+        val = 1;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    dev_dbg(dai->dev, "set_fmt master=%d\n", val);
+    regmap_update_bits(dmalink->regmap_clk, 0, CLK_MASTER_SLAVE, val);
+    return 0;
+}
+
+static int holotr_dmalink_sysclk(struct snd_soc_dai *dai, int clk_id,
+    unsigned int freq, int dir)
+{
+    struct holotr_dmalink *dmalink = snd_soc_dai_get_drvdata(dai);
+    int val = SND_SOC_CLOCK_IN ? 1 : 0;
+    dev_dbg(dai->dev, "sysclk id=%d freq=%d dir=%d\n", clk_id, freq, dir);
+    regmap_update_bits(dmalink->regmap_clk, 0, CLK_MASTER_SLAVE, val);
+    return 0;
+}
+
+static void holotr_dmalink_shutdown(struct snd_pcm_substream *substream,
+    struct snd_soc_dai *dai)
+{
+    struct holotr_dmalink *dmalink = snd_soc_dai_get_drvdata(dai);
+    int mask;
+    int val;
+    dev_dbg(dai->dev, "shutdown\n");
+
+    if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+        mask = CAP_ENABLE | CAP_FIFO_CLEAR;
+    else
+        mask = PB_ENABLE | PB_FIFO_CLEAR;
+
+    val = PB_FIFO_CLEAR | CAP_FIFO_CLEAR;
+    regmap_update_bits(dmalink->regmap_data, CMD_ADDR, mask, val);
+}
+
+static int holotr_dmalink_dai_probe(struct snd_soc_dai *dai)
+{
+    struct holotr_dmalink *dmalink = snd_soc_dai_get_drvdata(dai);
+
+    dev_dbg(dai->dev, "dai_probe\n");
+//       snd_soc_dai_init_dma_data(dai, &dmalink->playback_dma_data,
+    snd_soc_dai_init_dma_data(dai, NULL,
+    &dmalink->capture_dma_data);
+
+    return 0;
+}
+
+static const struct snd_soc_dai_ops holotr_dmalink_dai_ops = {
+    .set_sysclk = holotr_dmalink_sysclk,
+    .set_fmt = holotr_dmalink_set_fmt,
+    .shutdown = holotr_dmalink_shutdown,
+    .hw_params = holotr_dmalink_hw_params,
+    .trigger = holotr_dmalink_trigger,
+};
+
+static struct snd_soc_dai_driver holotr_dmalink_dai = {
+    .probe = holotr_dmalink_dai_probe,
+    .capture = {
+        .channels_min = 2,
+        .channels_max = 2,
+//      .rates = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000
+//      | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000
+//      | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000,
+        .rates = SNDRV_PCM_RATE_44100,
+        .formats = SNDRV_PCM_FMTBIT_S32_LE,
+    },
+    .ops = &holotr_dmalink_dai_ops,
+    .symmetric_rates = 1,
+};
+
+static const struct snd_soc_component_driver holotr_dmalink_component = {
+    .name = "holotr-dmalink",
+};
+
+static const struct regmap_config holotr_dmalink_regmap_data_config = {
+    .name = "holotr_dmalink.data",
+    .reg_bits = 32,
+    .reg_stride = 4,
+    .val_bits = 32,
+    .max_register = CMD_ADDR,
+};
+
+static const struct regmap_config holotr_dmalink_regmap_clk_config = {
+    .name = "holotr_dmalink.clk",
+    .reg_bits = 32,
+    .reg_stride = 4,
+    .val_bits = 32,
+    .max_register = CLK_CTRL2,
+};
+
+static int holotr_dmalink_probe(struct platform_device *pdev)
+{
+    struct resource *res, *res_clk;
+    struct holotr_dmalink *dmalink;
+    void __iomem *base;
+    int signature;
+    int ret;
+
+    dmalink = devm_kzalloc(&pdev->dev, sizeof(*dmalink), GFP_KERNEL);
+    if (!dmalink) {
+            dev_err(&pdev->dev, "Can't allocate holotr_dmalink\n");
+            return -ENOMEM;
+    }
+    platform_set_drvdata(pdev, dmalink);
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res) {
+            dev_err(&pdev->dev, "No memory resource\n");
+            return -ENODEV;
+    }
+    base = devm_ioremap_resource(&pdev->dev, res);
+    if (IS_ERR(base)) {
+            dev_err(&pdev->dev, "No ioremap resource\n");
+            return PTR_ERR(base);
+    }
+    printk(KERN_ALERT "holotr_dmalink at %08x\n", (int)base);
+
+    dmalink->regmap_data = devm_regmap_init_mmio(&pdev->dev, base,
+            &holotr_dmalink_regmap_data_config);
+    if (IS_ERR(dmalink->regmap_data)) {
+            dev_err(&pdev->dev, "No regmap_data\n");
+            return PTR_ERR(dmalink->regmap_data);
+    }
+
+    res_clk = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+    if (!res_clk) {
+            dev_err(&pdev->dev, "No memory resource\n");
+            return -ENODEV;
+    }
+    base = devm_ioremap_resource(&pdev->dev, res_clk);
+    if (IS_ERR(base)) {
+            dev_err(&pdev->dev, "No ioremap resource\n");
+            return PTR_ERR(base);
+    }
+
+    dmalink->regmap_clk = devm_regmap_init_mmio(&pdev->dev, base,
+            &holotr_dmalink_regmap_clk_config);
+    if (IS_ERR(dmalink->regmap_clk)) {
+            dev_err(&pdev->dev, "No regmap_clk\n");
+            return PTR_ERR(dmalink->regmap_clk);
+    }
+/*
+    dmalink->clk48 = devm_clk_get(&pdev->dev, "clk48");
+    if (IS_ERR(dmalink->clk48)) {
+            dev_err(&pdev->dev, "No clk48 clock\n");
+            return PTR_ERR(dmalink->clk48);
+    }
+
+    ret = clk_prepare_enable(dmalink->clk48);
+    if (ret) {
+            dev_err(&pdev->dev, "Cannot enable clock\n");
+            return ret;
+    }
+*/
+    dmalink->clk44 = devm_clk_get(&pdev->dev, "clk44");
+    if (IS_ERR(dmalink->clk44)) {
+            dev_err(&pdev->dev, "No clk44 clock\n");
+            return PTR_ERR(dmalink->clk44);
+    }
+
+    ret = clk_prepare_enable(dmalink->clk44);
+    if (ret) {
+            dev_err(&pdev->dev, "Cannot enable clock\n");
+            return ret;
+    }
+
+//       dmalink->playback_dma_data.addr = res->start + DAC_FIFO_ADDR;
+//       dmalink->playback_dma_data.addr_width = 4;
+//       dmalink->playback_dma_data.maxburst = 1;
+    //dmalink->playback_dma_data.maxburst = 2;
+//       dev_dbg(&pdev->dev, "probe playback dma addr : %8x\n",
+//       dmalink->playback_dma_data.addr);
+
+    dmalink->capture_dma_data.addr = res->start + ADC_FIFO_ADDR;
+    dmalink->capture_dma_data.addr_width = 4;
+    dmalink->capture_dma_data.maxburst = 1;
+    //dmalink->capture_dma_data.maxburst = 2;
+
+/*
+    dmalink->ratnum.num = clk_get_rate(dmalink->clk_ref) / 2 / BITS_PER_FRAME;
+    dmalink->ratnum.den_step = 1;
+    dmalink->ratnum.den_min = 1;
+    dmalink->ratnum.den_max = 64;
+
+    dmalink->rate_constraints.rats = &dmalink->ratnum;
+    dmalink->rate_constraints.nrats = 1;
+*/
+
+    regmap_write(dmalink->regmap_data, CMD_ADDR, PB_FIFO_CLEAR | CAP_FIFO_CLEAR);
+    ret = regmap_read(dmalink->regmap_data, STATUS_ADDR, &signature);
+    if (ret) {
+        dev_err(&pdev->dev, "Cannot read signature\n");
+        printk(KERN_ALERT "holotr_dmalink probe signature : %4x\n", signature);
+        goto err_clk_disable;
+    }
+    dev_dbg(&pdev->dev, "probe signature : %4x\n", signature);
+
+    ret = devm_snd_soc_register_component(&pdev->dev, &holotr_dmalink_component,
+                                        &holotr_dmalink_dai, 1);
+    if (ret) {
+        dev_err(&pdev->dev, "Cannot register component\n");
+        goto err_clk_disable;
+    }
+
+    ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+    if (ret) {
+        dev_err(&pdev->dev, "Cannot register dmaengine\n");
+        goto err_clk_disable;
+    }
+
+    dev_dbg(&pdev->dev, "probe finishing\n");
+    return ret;
+
+err_clk_disable:
+//       clk_disable_unprepare(dmalink->clk48);
+    clk_disable_unprepare(dmalink->clk44);
+    return ret;
+}
+
+static const struct of_device_id holotr_dmalink_of_match[] = {
+    { .compatible = "holotr,dmalink", },
+    {},
+};
+MODULE_DEVICE_TABLE(of, holotr_dmalink_of_match);
+
+static struct platform_driver holotr_dmalink_driver = {
+    .probe = holotr_dmalink_probe,
+    .driver = {
+        .name = "holotr-dmalink",
+//        .owner = THIS_MODULE,
+        .of_match_table = holotr_dmalink_of_match,
+    },
+};
+module_platform_driver(holotr_dmalink_driver);
+
+MODULE_AUTHOR("Michael Brown (the-snowwhite) <producer@holotronic.dk");
+MODULE_DESCRIPTION("DMA sound driver for soc at https://github.com/the-snowwhite");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/socsynth/opencores_i2s.c b/sound/soc/socsynth/opencores_i2s.c
new file mode 100644
index 0000000..1f4268c
--- /dev/null
+++ b/sound/soc/socsynth/opencores_i2s.c
@@ -0,0 +1,436 @@
+/*
+ * Copyright (C) 2014 Bjarne Steinsbo <bsteinsbo@gmail.com>
+ * Largely based on axi-i2s.c by Lars-Peter Clausen.
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+
+#define DAC_FIFO_ADDR	0x00
+#define STATUS_ADDR	0x04
+#define CMD_ADDR	0x08
+#define ADC_FIFO_ADDR	0x00
+
+/* Commands to register at CMD_ADDR */
+#define PB_FIFO_CLEAR	BIT(0)
+#define PB_ENABLE	BIT(1)
+#define CAP_FIFO_CLEAR	BIT(2)
+#define CAP_ENABLE	BIT(3)
+
+#define CLK_CTRL1	0x00
+#define CLK_CTRL2	0x04
+
+/* Bit-fields of clk control register 1 */
+#define CLK_MASTER_SLAVE  BIT(0)
+#define CLK_SEL_48_44	  BIT(1)
+#define MCLK_DIV_SHIFT	  (24)
+#define MCLK_DIV_MASK	  GENMASK(MCLK_DIV_SHIFT + 7, MCLK_DIV_SHIFT)
+#define BCLK_DIV_SHIFT	  (16)
+#define BCLK_DIV_MASK	  GENMASK(BCLK_DIV_SHIFT + 7, BCLK_DIV_SHIFT)
+/* Bit-fields of clk control register 2 */
+#define PB_LRC_DIV_SHIFT  (8)
+#define PB_LRC_DIV_MASK	  GENMASK(PB_LRC_DIV_SHIFT + 7, PB_LRC_DIV_SHIFT)
+#define CAP_LRC_DIV_SHIFT (0)
+#define CAP_LRC_DIV_MASK  GENMASK(CAP_LRC_DIV_SHIFT + 7, CAP_LRC_DIV_SHIFT)
+
+/* The frame size is not configurable */
+#define BITS_PER_FRAME 64
+
+struct opencores_i2s {
+	struct regmap *regmap_data;
+	struct regmap *regmap_clk;
+	struct clk *clk48;
+	struct clk *clk44;
+
+	struct snd_soc_dai_driver dai_driver;
+
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+
+	struct snd_ratnum ratnum;
+	struct snd_pcm_hw_constraint_ratnums rate_constraints;
+};
+
+static int opencores_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+	struct opencores_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	unsigned int mask, val;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		mask = CAP_ENABLE;
+	else
+		mask = PB_ENABLE;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		val = mask;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		val = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(i2s->regmap_data, CMD_ADDR, mask, val);
+//	regmap_write(i2s->regmap_data, CMD_ADDR, val);
+
+	dev_dbg(dai->dev, "trigger %x\n", val);
+	return 0;
+}
+
+static int divisor_value(unsigned long xtal_rate, unsigned long rate, int shift)
+{
+	return ((xtal_rate / rate / 2) >> shift) - 1;
+}
+
+static int opencores_i2s_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct opencores_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	unsigned long xtal_rate;
+	int lrclk_div;
+	int mclk_div;
+	int bclk_div;
+	int mask, val;
+	int mask2, val2;
+
+	dev_dbg(dai->dev, "hw_params fmt=0x%x\n", params_format(params));
+	dev_dbg(dai->dev, "hw_params rate=%d\n", params_rate(params));
+	if (params_format(params) != SNDRV_PCM_FORMAT_S32_LE)
+		return -EINVAL;
+
+	if ((params_rate(params) % 44100) == 0) {
+		val = CLK_SEL_48_44;
+		xtal_rate = clk_get_rate(i2s->clk44);
+		mclk_div = divisor_value(xtal_rate, 16934400, 0); /* fs*384 at 44.1kHz */
+	} else if ((params_rate(params) % 48000) == 0) {
+		val = 0;
+		xtal_rate = clk_get_rate(i2s->clk48);
+		mclk_div = divisor_value(xtal_rate, 12288000, 0); /* fs*256 at 48kHz */
+	} else
+		return -EINVAL;
+	mask = CLK_SEL_48_44;
+	mask2 = 0;
+
+	lrclk_div = divisor_value(xtal_rate, params_rate(params), 4);
+	bclk_div = divisor_value(xtal_rate, params_rate(params) * BITS_PER_FRAME, 0);
+	dev_dbg(dai->dev, "hw_params mclk_div=%d\n", mclk_div);
+	dev_dbg(dai->dev, "hw_params lrclk_div=%d\n", lrclk_div);
+	dev_dbg(dai->dev, "hw_params bclk_div=%d\n", bclk_div);
+	val |= mclk_div << MCLK_DIV_SHIFT;
+	mask |= MCLK_DIV_MASK;
+	val |= bclk_div << BCLK_DIV_SHIFT;
+	mask |= BCLK_DIV_MASK;
+	regmap_update_bits(i2s->regmap_clk, CLK_CTRL1, mask, val);
+	dev_dbg(dai->dev, "hw_params mask=0x%x val=0x%x\n", mask, val);
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		val2 = lrclk_div << CAP_LRC_DIV_SHIFT;
+		mask2 = CAP_LRC_DIV_MASK;
+	} else {
+		val2 = lrclk_div << PB_LRC_DIV_SHIFT;
+		mask2 = PB_LRC_DIV_MASK;
+	}
+	regmap_update_bits(i2s->regmap_clk, CLK_CTRL2, mask2, val2);
+	dev_dbg(dai->dev, "hw_params mask2=0x%x val2=0x%x\n", mask2, val2);
+	return 0;
+}
+
+static int opencores_i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct opencores_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	int val = 0;
+	dev_dbg(dai->dev, "set_fmt 0x%x\n", fmt);
+
+	if ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_I2S)
+		return -EINVAL;
+
+	if ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF)
+		return -EINVAL;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		val = 0;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		val = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dev_dbg(dai->dev, "set_fmt master=%d\n", val);
+	regmap_update_bits(i2s->regmap_clk, 0, CLK_MASTER_SLAVE, val);
+	return 0;
+}
+
+static int opencores_i2s_sysclk(struct snd_soc_dai *dai, int clk_id,
+	unsigned int freq, int dir)
+{
+	struct opencores_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	int val = SND_SOC_CLOCK_IN ? 1 : 0;
+	dev_dbg(dai->dev, "sysclk id=%d freq=%d dir=%d\n", clk_id, freq, dir);
+	regmap_update_bits(i2s->regmap_clk, 0, CLK_MASTER_SLAVE, val);
+	return 0;
+}
+
+static void opencores_i2s_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct opencores_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	int mask;
+	int val;
+	dev_dbg(dai->dev, "shutdown\n");
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		mask = CAP_ENABLE | CAP_FIFO_CLEAR;
+	else
+		mask = PB_ENABLE | PB_FIFO_CLEAR;
+	val = PB_FIFO_CLEAR | CAP_FIFO_CLEAR;
+	regmap_update_bits(i2s->regmap_data, CMD_ADDR, mask, val);
+}
+
+static int opencores_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	struct opencores_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(dai->dev, "dai_probe\n");
+	snd_soc_dai_init_dma_data(dai, &i2s->playback_dma_data,
+		&i2s->capture_dma_data);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops opencores_i2s_dai_ops = {
+	.set_sysclk = opencores_i2s_sysclk,
+	// .set_pll
+	//.set_clkdiv = opencores_i2s_set_clkdiv,
+	// .set_bclk_ratio
+        .set_fmt = opencores_i2s_set_fmt,
+        // .xlate_tdm_slot_mask
+        // .set_tdm_slot
+        // .set_channel_map
+        // .set_tristate
+
+        // .digital_mute
+        // .mute_stream
+
+	//.startup = opencores_i2s_startup,
+	.shutdown = opencores_i2s_shutdown,
+	.hw_params = opencores_i2s_hw_params,
+	// .hw_free
+	// .prepare
+	.trigger = opencores_i2s_trigger,
+	// .bespoke_trigger
+	// .delay
+};
+
+static struct snd_soc_dai_driver opencores_i2s_dai = {
+	.probe = opencores_i2s_dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000
+			| SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000
+			| SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000,
+		.formats = SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000
+			| SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000
+			| SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000,
+		.formats = SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &opencores_i2s_dai_ops,
+	.symmetric_rates = 1,
+};
+
+static const struct snd_soc_component_driver opencores_i2s_component = {
+	.name = "opencores-i2s",
+};
+
+static const struct regmap_config opencores_i2s_regmap_data_config = {
+	.name = "opencores_i2s.data",
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = CMD_ADDR,
+};
+
+static const struct regmap_config opencores_i2s_regmap_clk_config = {
+	.name = "opencores_i2s.clk",
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = CLK_CTRL2,
+};
+
+static int opencores_i2s_probe(struct platform_device *pdev)
+{
+	struct resource *res, *res_clk;
+	struct opencores_i2s *i2s;
+	void __iomem *base;
+	int signature;
+	int ret;
+
+	i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
+	if (!i2s) {
+		dev_err(&pdev->dev, "Can't allocate opencores_i2s\n");
+		return -ENOMEM;
+	}
+	platform_set_drvdata(pdev, i2s);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "No memory resource\n");
+		return -ENODEV;
+	}
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base)) {
+		dev_err(&pdev->dev, "No ioremap resource\n");
+		return PTR_ERR(base);
+	}
+	printk(KERN_ALERT "opencores_i2s at %08x\n", (int)base);
+
+	i2s->regmap_data = devm_regmap_init_mmio(&pdev->dev, base,
+		&opencores_i2s_regmap_data_config);
+	if (IS_ERR(i2s->regmap_data)) {
+		dev_err(&pdev->dev, "No regmap_data\n");
+		return PTR_ERR(i2s->regmap_data);
+	}
+
+	res_clk = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res_clk) {
+		dev_err(&pdev->dev, "No memory resource\n");
+		return -ENODEV;
+	}
+	base = devm_ioremap_resource(&pdev->dev, res_clk);
+	if (IS_ERR(base)) {
+		dev_err(&pdev->dev, "No ioremap resource\n");
+		return PTR_ERR(base);
+	}
+
+	i2s->regmap_clk = devm_regmap_init_mmio(&pdev->dev, base,
+		&opencores_i2s_regmap_clk_config);
+	if (IS_ERR(i2s->regmap_clk)) {
+		dev_err(&pdev->dev, "No regmap_clk\n");
+		return PTR_ERR(i2s->regmap_clk);
+	}
+
+	i2s->clk48 = devm_clk_get(&pdev->dev, "clk48");
+	if (IS_ERR(i2s->clk48)) {
+		dev_err(&pdev->dev, "No clk48 clock\n");
+		return PTR_ERR(i2s->clk48);
+	}
+
+	ret = clk_prepare_enable(i2s->clk48);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot enable clock\n");
+		return ret;
+	}
+
+	i2s->clk44 = devm_clk_get(&pdev->dev, "clk44");
+	if (IS_ERR(i2s->clk44)) {
+		dev_err(&pdev->dev, "No clk44 clock\n");
+		return PTR_ERR(i2s->clk44);
+	}
+
+	ret = clk_prepare_enable(i2s->clk44);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot enable clock\n");
+		return ret;
+	}
+
+	i2s->playback_dma_data.addr = res->start + DAC_FIFO_ADDR;
+	i2s->playback_dma_data.addr_width = 4;
+	i2s->playback_dma_data.maxburst = 1;
+	//i2s->playback_dma_data.maxburst = 2;
+	dev_dbg(&pdev->dev, "probe playback dma addr : %8x\n",
+		i2s->playback_dma_data.addr);
+
+	i2s->capture_dma_data.addr = res->start + ADC_FIFO_ADDR;
+	i2s->capture_dma_data.addr_width = 4;
+	i2s->capture_dma_data.maxburst = 1;
+	//i2s->capture_dma_data.maxburst = 2;
+
+/*
+	i2s->ratnum.num = clk_get_rate(i2s->clk_ref) / 2 / BITS_PER_FRAME;
+	i2s->ratnum.den_step = 1;
+	i2s->ratnum.den_min = 1;
+	i2s->ratnum.den_max = 64;
+
+	i2s->rate_constraints.rats = &i2s->ratnum;
+	i2s->rate_constraints.nrats = 1;
+*/
+
+	regmap_write(i2s->regmap_data, CMD_ADDR, PB_FIFO_CLEAR | CAP_FIFO_CLEAR);
+	ret = regmap_read(i2s->regmap_data, STATUS_ADDR, &signature);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot read signature\n");
+		printk(KERN_ALERT "opencores_i2s probe signature : %4x\n", signature);
+		goto err_clk_disable;
+	}
+	dev_dbg(&pdev->dev, "probe signature : %4x\n", signature);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &opencores_i2s_component,
+					 &opencores_i2s_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot register component\n");
+		goto err_clk_disable;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot register dmaengine\n");
+		goto err_clk_disable;
+	}
+
+	dev_dbg(&pdev->dev, "probe finishing\n");
+	return ret;
+
+err_clk_disable:
+	clk_disable_unprepare(i2s->clk48);
+	clk_disable_unprepare(i2s->clk44);
+	return ret;
+}
+
+static const struct of_device_id opencores_i2s_of_match[] = {
+	{ .compatible = "opencores,i2s", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, opencores_i2s_of_match);
+
+static struct platform_driver opencores_i2s_driver = {
+	.driver = {
+		.name = "opencores-i2s",
+		.owner = THIS_MODULE,
+		.of_match_table = opencores_i2s_of_match,
+	},
+	.probe = opencores_i2s_probe,
+};
+module_platform_driver(opencores_i2s_driver);
+
+MODULE_AUTHOR("Bjarne Steinsbo <bsteinsbo@gmail.com>");
+MODULE_DESCRIPTION("I2S driver for core at https://github.com/bsteinsbo/i2s.git");
+MODULE_LICENSE("GPL");
-- 
2.7.4


From 3731b421d6a32b0851c3976372216cdfd20ca402 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Sun, 29 Apr 2018 02:00:12 +0200
Subject: [PATCH 13/16] Convert de1-soc-wm8731 to de1-soc-wm8731-midi hsynth
 driver remove hsynthdma and holosynth driver

Signed-off-by: Michael Brown <producer@holotronic.dk>

Add hsynth dma audio to de1-soc-wm8731-midi driver

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/Makefile                         |   1 +
 arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts     |  70 ++--
 .../arm/boot/dts/socfpga_cyclone5_de1_soc_fbII.dts | 274 ++++++++++++
 arch/arm/configs/socfpga_defconfig                 |   5 +-
 sound/soc/codecs/hsynth7002.c                      |   8 +-
 sound/soc/socsynth/Kconfig                         |  32 +-
 sound/soc/socsynth/Makefile                        |   7 +-
 sound/soc/socsynth/de1-soc-wm8731-midi.c           | 458 +++++++++++++++++++++
 sound/soc/socsynth/de1-soc-wm8731.c                | 247 -----------
 sound/soc/socsynth/holosynthv.c                    | 292 -------------
 10 files changed, 794 insertions(+), 600 deletions(-)
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fbII.dts
 create mode 100644 sound/soc/socsynth/de1-soc-wm8731-midi.c
 delete mode 100644 sound/soc/socsynth/de1-soc-wm8731.c
 delete mode 100644 sound/soc/socsynth/holosynthv.c

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index b359216..f7f25c2 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -703,6 +703,7 @@ dtb-$(CONFIG_ARCH_SOCFPGA) += \
 	socfpga_cyclone5_de10_nano_uio_fb.dtb \
 	socfpga_cyclone5_de10_nano_uio_fb_hd.dtb \
 	socfpga_cyclone5_de1_soc.dtb \
+	socfpga_cyclone5_de1_soc_fbII.dtb \
 	socfpga_cyclone5_sockit.dtb \
 	socfpga_cyclone5_socrates.dtb \
 	socfpga_cyclone5_sodia.dtb \
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
index 8912581..a366b7b 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc.dts
@@ -1,18 +1,18 @@
 /*
- * Copyright Intel Corporation (C) 2017. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
- */
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
 
 #include "socfpga_cyclone5.dtsi"
 
@@ -61,12 +61,14 @@
 		};
 	};
 
-    sound {
-		compatible = "opencores,de1soc-wm8731-audio";
+	sound {
+		compatible = "opencores,de1soc-wm8731-audio-midi";
 		i2s-controller = <&i2s>;
 		audio-codec = <&wm8731>;
 		i2c-mux-gpio = <&portb 19 0>;
-    };
+		dmalink-controller = <&dmalink>;
+		synth-codec = <&hsynth7002_codec>;
+	};
 
 	clk48: clk48 {
 		compatible = "fixed-clock";
@@ -85,11 +87,28 @@
 	i2s: i2s@0x0 {
 		#sound-dai-cells = <1>;
 		compatible = "opencores,i2s";
-		reg = <0xff200000 0x40>, <0xff200040 0x20>;
+		reg = <0xff200000 0x20>, <0xff200040 0x20>;
 		clocks = <&clk44>, <&clk48>;
 		clock-names = "clk44", "clk48";
-		dmas = <&pdma 0>, <&pdma 1>;
-		dma-names = "tx", "rx";
+		dmas = <&pdma 0>, <&pdma 1>, <&pdma 2>;
+		dma-names = "tx", "rx", "rx";
+	};
+
+	dmalink: dmalink@0x20 {
+		#sound-dai-cells = <1>;
+		compatible = "holotr,dmalink";
+		reg = <0xff200020 0x20>, <0xff200060 0x20>;
+		clocks = <&clk44>;
+		clock-names = "clk44";
+		dmas = <&pdma 2>;
+		dma-names = "rx";
+	};
+
+	hsynth7002_codec: hsynth7002-codec {
+	#sound-dai-cells = <0>;
+		compatible = "holotr,hsynth7002";
+/*     IOVDD-supply = <&supply>;*/
+		status = "okay";
 	};
 
 	bridge@0xc0000000 {
@@ -176,22 +195,13 @@
 		}; //end gpio@0x100010040 (led_pio)
 
 		uio-socfpg0@0x100040000 {
-            compatible = "generic-uio,ui_pdrv";
+			compatible = "generic-uio,ui_pdrv";
 			reg = <0x00000001 0x00040000 0x00010000>;
 			interrupt-parent = <0x2>;
 			interrupts = <0 43 4>;
 			address_width = <14>;
 			data_width = <32>;
 		};
-
-		socmidi@0x100050000 {
-			compatible = "holotr,socmidi-1.0";
-			reg = <0x00000001 0x00050000 0x00010000>;
-			interrupt-parent = <0x2>;
-			interrupts = <0 44 4>;
-			address_width = <3>;   /* embeddedsw.dts.params.address_width type NUMBER */
-			data_width = <8>;      /* embeddedsw.dts.params.data_width type NUMBER */
-		};
 	};
 };
 
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fbII.dts b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fbII.dts
new file mode 100644
index 0000000..558994d
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de1_soc_fbII.dts
@@ -0,0 +1,274 @@
+/*
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE1-SoC";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	sound {
+		compatible = "opencores,de1soc-wm8731-audio-midi";
+		i2s-controller = <&i2s>;
+		audio-codec = <&wm8731>;
+		i2c-mux-gpio = <&portb 19 0>;
+		dmalink-controller = <&dmalink>;
+		synth-codec = <&hsynth7002_codec>;
+	};
+
+	clk48: clk48 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <24576000>;
+		clock-output-names = "clk48";
+	};
+
+	clk44: clk44 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <33868800>;
+		clock-output-names = "clk44";
+	};
+
+	i2s: i2s@0x0 {
+		#sound-dai-cells = <1>;
+		compatible = "opencores,i2s";
+		reg = <0xff200000 0x20>, <0xff200040 0x20>;
+		clocks = <&clk44>, <&clk48>;
+		clock-names = "clk44", "clk48";
+		dmas = <&pdma 0>, <&pdma 1>, <&pdma 2>;
+		dma-names = "tx", "rx", "rx";
+	};
+
+	dmalink: dmalink@0x20 {
+		#sound-dai-cells = <1>;
+		compatible = "holotr,dmalink";
+		reg = <0xff200020 0x20>, <0xff200060 0x20>;
+		clocks = <&clk44>;
+		clock-names = "clk44";
+		dmas = <&pdma 2>;
+		dma-names = "rx";
+	};
+
+	hsynth7002_codec: hsynth7002-codec {
+	#sound-dai-cells = <0>;
+		compatible = "holotr,hsynth7002";
+/*     IOVDD-supply = <&supply>;*/
+		status = "okay";
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		bridge-enable = <1>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00020000 0xff220000 0x00000008>,
+			<0x00000001 0x00000200 0xff200200 0x00000040>,
+			<0x00000001 0x00010000 0xff210000 0x00000008>,
+			<0x00000001 0x000100c0 0xff2100c0 0x00000010>,
+			<0x00000001 0x00010080 0xff210080 0x00000010>,
+			<0x00000001 0x00010040 0xff210040 0x00000010>,
+			<0x00000001 0x00040000 0xff240000 0x00010000>,
+			<0x00000001 0x00050000 0xff250000 0x00010000>;
+
+		serial@0x100020000 {
+			compatible = "altr,juart-17.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00020000 0x00000008>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 40 4>;
+			clocks = <0x2>;
+		}; //end serial@0x100020000 (jtag_uart)
+
+		vip@0x100000200 {
+			compatible = "altr,vip-17.1", "altr,vip-frame-buffer-2.0";
+			reg = <0x00000001 0x00000200 0x00000040>;
+			altr,bits-per-symbol = <8>;
+			altr,max-height = <768>;
+			altr,max-width = <1366>;
+			altr,mem-port-width = <128>;
+		};
+
+		sysid@0x100010000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00010000 0x00000008>;
+			id = <2899645186>;
+			timestamp = <1524157570>;
+		};
+
+		gpio@0x1000100c0 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x000100c0 0x00000010>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 41 1>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <2>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			altr,interrupt-type = <2>;	/* embeddedsw.dts.params.altr,interrupt-type type NUMBER */
+			altr,interrupt_type = <2>;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
+			edge_type = <1>;	/* embeddedsw.dts.params.edge_type type NUMBER */
+			level_trigger = <0>;	/* embeddedsw.dts.params.level_trigger type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x1000100c0 (button_pio)
+
+		gpio@0x100010080 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00010080 0x00000010>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 42 1>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			altr,interrupt-type = <3>;	/* embeddedsw.dts.params.altr,interrupt-type type NUMBER */
+			altr,interrupt_type = <3>;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
+			edge_type = <2>;	/* embeddedsw.dts.params.edge_type type NUMBER */
+			level_trigger = <0>;	/* embeddedsw.dts.params.level_trigger type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x100010080 (dipsw_pio)
+
+		gpio@0x100010040 {
+			compatible = "altr,pio-17.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00010040 0x00000010>;
+			clocks = <0x2>;
+			altr,gpio-bank-width = <10>;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
+			resetvalue = <0>;	/* embeddedsw.dts.params.resetvalue type NUMBER */
+			#gpio-cells = <2>;
+			gpio-controller;
+		}; //end gpio@0x100010040 (led_pio)
+
+		uio-socfpg0@0x100040000 {
+			compatible = "generic-uio,ui_pdrv";
+			reg = <0x00000001 0x00040000 0x00010000>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 43 4>;
+			address_width = <14>;
+			data_width = <32>;
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	wm8731: wm8731@34 {
+		#sound-dai-cells = <0>;
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+	};
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl345";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&i2c1 {
+	status = "okay";
+	speed-mode = <0>;
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index f340c40..eccb192 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -116,6 +116,7 @@ CONFIG_MFD_STMPE=y
 CONFIG_REGULATOR=y
 CONFIG_REGULATOR_FIXED_VOLTAGE=y
 CONFIG_FB=y
+CONFIG_FB_ALTERA_VIP=m
 CONFIG_FB_ALTERA_VIP_FB2_PLAT=m
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
@@ -276,7 +277,6 @@ CONFIG_FB_NOTIFY=y
 CONFIG_FB_CFB_FILLRECT=y
 CONFIG_FB_CFB_COPYAREA=y
 CONFIG_FB_CFB_IMAGEBLIT=y
-CONFIG_FB_ALTERA_VIP=y
 CONFIG_DUMMY_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
@@ -305,8 +305,7 @@ CONFIG_SND_SOC_SSM2602=m
 CONFIG_SND_SOC_SSM2602_I2C=m
 CONFIG_SND_ALOOP=m
 CONFIG_SND_VIRMIDI=m
-CONFIG_SND_SOC_HOLOSYNTHV=m
-CONFIG_SND_SOC_DE1_WM8731=m
+CONFIG_SND_SOC_DE1_WM8731_MIDI=m
 CONFIG_SND_SOC_PCM5102A=m
 CONFIG_FPGADMA=m
 CONFIG_REGMAP_I2C=y
diff --git a/sound/soc/codecs/hsynth7002.c b/sound/soc/codecs/hsynth7002.c
index 1c54d02..b1898b3 100644
--- a/sound/soc/codecs/hsynth7002.c
+++ b/sound/soc/codecs/hsynth7002.c
@@ -16,13 +16,13 @@
 #include <sound/soc.h>
 
 static const struct snd_soc_dapm_widget hsynth7002_widgets[] = {
-	SND_SOC_DAPM_INPUT("PDM_DAT"),
-	SND_SOC_DAPM_REGULATOR_SUPPLY("IOVDD", 0, 0),
+	SND_SOC_DAPM_INPUT("HSYNTH"),
+//	SND_SOC_DAPM_REGULATOR_SUPPLY("IOVDD", 0, 0),
 };
 
 static const struct snd_soc_dapm_route hsynth7002_routes[] = {
-	{ "Capture", NULL, "PDM_DAT" },
-	{ "Capture", NULL, "IOVDD" },
+	{ "Capture", NULL, "HSYNTH" },
+//	{ "Capture", NULL, "IOVDD" },
 };
 
 static int hsynth7002_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
diff --git a/sound/soc/socsynth/Kconfig b/sound/soc/socsynth/Kconfig
index 572c882..5486745 100644
--- a/sound/soc/socsynth/Kconfig
+++ b/sound/soc/socsynth/Kconfig
@@ -1,12 +1,3 @@
-config SND_SOC_HSYNTHDMA
-       tristate "holosynth DMA Controller"
-       help
-         If you say yes to this option, support will be included for the
-         HSYNTHDMA dma controller. For details see
-
-         This driver can also be built as a module.  If so, the module
-         will be called hsynthdma.
-
 config SND_SOC_OC_I2S
        tristate "OpenCores I2S Controller"
        help
@@ -16,18 +7,21 @@ config SND_SOC_OC_I2S
          This driver can also be built as a module.  If so, the module
          will be called opencores_i2s.
 
-config SND_SOC_HOLOSYNTHV
-       tristate "SOC-Synthsizer support"
-       select SND_SOC_HSYNTH7002
-       select SND_SOC_HSYNTHDMA
-       select SND_SOC_GENERIC_DMAENGINE_PCM
-       select SND_RAWMIDI
-       select REGMAP_MMIO
+config SND_SOC_HSYNTHDMA
+       tristate "holosynth DMA Controller"
        help
-         ASoC driver for fpga Sound Synthesizer peripheral with pcm / rawmidi support.
+         If you say yes to this option, support will be included for the
+         HSYNTHDMA dma controller. For details see
+
+         This driver can also be built as a module.  If so, the module
+         will be called hsynthdma.
 
-config SND_SOC_DE1_WM8731
-       tristate "DE1-Audio support"
+config SND_SOC_DE1_WM8731_MIDI
+       tristate "DE1-Audio MIDI support"
        select SND_SOC_WM8731
        select SND_SOC_OC_I2S
+       select SND_SOC_GENERIC_DMAENGINE_PCM
+       select SND_RAWMIDI
        select REGMAP_MMIO
+       select SND_SOC_HSYNTH7002
+       select SND_SOC_HSYNTHDMA
diff --git a/sound/soc/socsynth/Makefile b/sound/soc/socsynth/Makefile
index d9e999e..d0ec5df 100644
--- a/sound/soc/socsynth/Makefile
+++ b/sound/soc/socsynth/Makefile
@@ -1,11 +1,8 @@
 snd-soc-opencores_i2s-objs := opencores_i2s.o
 obj-$(CONFIG_SND_SOC_OC_I2S) += snd-soc-opencores_i2s.o
 
-snd-de1-soc-wm8731-objs := de1-soc-wm8731.o
-obj-$(CONFIG_SND_SOC_DE1_WM8731) += snd-de1-soc-wm8731.o
+snd-de1-soc-wm8731-midi-objs := de1-soc-wm8731-midi.o
+obj-$(CONFIG_SND_SOC_DE1_WM8731_MIDI) += snd-de1-soc-wm8731-midi.o
 
 snd-soc-hsynthdma-objs := hsynthdma.o
 obj-$(CONFIG_SND_SOC_HSYNTHDMA) += snd-soc-hsynthdma.o
-
-snd-soc-holosynthv-objs := holosynthv.o
-obj-$(CONFIG_SND_SOC_HOLOSYNTHV) += snd-soc-holosynthv.o
diff --git a/sound/soc/socsynth/de1-soc-wm8731-midi.c b/sound/soc/socsynth/de1-soc-wm8731-midi.c
new file mode 100644
index 0000000..6203172
--- /dev/null
+++ b/sound/soc/socsynth/de1-soc-wm8731-midi.c
@@ -0,0 +1,458 @@
+/*
+* de1-soc-wm8731 -- SoC audio for Terasic DE1-SoC board
+* Author: B. Steinsbo <bsteinsbo@gmail.com>
+*
+* Based on sam9g20_wm8731 by
+* Sedji Gaouaou <sedji.gaouaou@atmel.com>
+*
+* Licensed under the GPL-2.
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/uaccess.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/seq_kernel.h>
+#include <sound/rawmidi.h>
+#include <sound/initval.h>
+
+#define SOCSYNTHMIDI_LOG_PREFIX "socsynthmidi: "
+#define midi_ins 0
+#define midi_outs 1
+
+#define MIDIREG_BASE 0xff200000
+#define MIDIREG_SIZE PAGE_SIZE
+#define MIDIREG_OFFSET 0x50000
+
+#define WM8731_SYSCLK_XTAL 1
+#define WM8731_SYSCLK_MCLK 2
+#define MCLK_RATE_48K 12288000 /* fs*256 */
+#define MCLK_RATE_44K 16934400 /* fs*384 */
+
+#define printe(...) pr_err(SOCSYNTHMIDI_LOG_PREFIX __VA_ARGS__)
+
+static int snd_socmidi_open(struct snd_rawmidi_substream *substream);
+static int snd_socmidi_close(struct snd_rawmidi_substream *substream);
+static int hmidi_card_probe(struct snd_soc_card *card);
+static int hmidi_card_remove(struct snd_soc_card *card);
+static void snd_socmidi_transmit(unsigned char data);
+static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int);
+static int hsound_midi_init(struct snd_card *card);
+
+void *midireg_mem;
+
+static int snd_socmidi_open(struct snd_rawmidi_substream *substream)
+{
+    return 0;
+}
+
+static int snd_socmidi_close(struct snd_rawmidi_substream *substream)
+{
+    return 0;
+}
+
+static int hmidi_card_probe(struct snd_soc_card *card)
+{
+    int err;
+
+    err = hsound_midi_init(card->snd_card);
+
+    if (err < 0) {
+        //		dev_dbg(&pdev->dev,"hsound_midi_init failed: %d\n", err);
+        return err;
+    }
+
+    return 0;
+}
+
+static int hmidi_card_remove(struct snd_soc_card *card)
+{
+    return 0;
+}
+
+static void snd_socmidi_transmit(unsigned char data){
+
+    iowrite8(data, midireg_mem);
+
+}
+
+static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int up) {
+
+    if (!up)
+        return;
+
+    while (1) {
+        unsigned char data;
+        if (snd_rawmidi_transmit(substream, &data, 1) != 1)
+            break; /* no more data */
+        snd_socmidi_transmit(data);
+    }
+}
+
+static struct snd_rawmidi *g_rmidi;
+
+static struct snd_rawmidi_ops snd_socmidi_output_ops = {
+    .open = snd_socmidi_open,
+    .close = snd_socmidi_close,
+    .trigger = snd_socmidi_output_trigger,
+};
+
+static void pisnd_get_port_info(struct snd_rawmidi *rmidi, int number, struct snd_seq_port_info *seq_port_info)
+{
+    seq_port_info->type =
+    SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
+    SNDRV_SEQ_PORT_TYPE_HARDWARE |
+    SNDRV_SEQ_PORT_TYPE_PORT;
+    seq_port_info->midi_voices = 0;
+}
+
+static struct snd_rawmidi_global_ops hsnd_global_ops = {.get_port_info = pisnd_get_port_info, };
+
+static int hsound_midi_init(struct snd_card *card)
+{
+    int err;
+    struct resource *res;
+
+    err = snd_rawmidi_new(card, "SocMIDI", 0, midi_outs, midi_ins, &g_rmidi);
+
+    if (err < 0) {
+        printe("snd_rawmidi_new failed: %d\n", err);
+        return err;
+    }
+
+    strcpy(g_rmidi->name, "Holosynth MIDI ");
+
+    g_rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT;
+    // rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
+    //                     SNDRV_RAWMIDI_INFO_INPUT |
+    //                     SNDRV_RAWMIDI_INFO_DUPLEX;
+
+    g_rmidi->ops = &hsnd_global_ops;
+
+    g_rmidi->private_data = (void *)0;
+
+    snd_rawmidi_set_ops(g_rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_socmidi_output_ops);
+    //    snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_socmidi_input_ops);
+
+    res = request_mem_region((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE, "MIDIREG");
+    if (res == NULL) {
+        return -EBUSY;
+    }
+
+    midireg_mem = ioremap((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE);
+    if (midireg_mem == NULL) {
+        release_mem_region(MIDIREG_BASE, MIDIREG_SIZE);
+        return -EFAULT;
+    }
+
+    return 0;
+}
+
+static unsigned int i2c_mux_gpio;
+
+static int de1soc_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct device *dev = rtd->card->dev;
+    unsigned int mclk_freq;
+    int ret;
+
+    if ((params_rate(params) % 44100) == 0) {
+        mclk_freq = MCLK_RATE_44K;
+    } else if ((params_rate(params) % 48000) == 0) {
+        mclk_freq = MCLK_RATE_48K;
+    } else
+        return -EINVAL;
+
+    /* set codec mclk configuration */
+    ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+        mclk_freq, SND_SOC_CLOCK_OUT);
+    if (ret < 0)
+        return ret;
+
+    dev_dbg(dev, "hw_params: mclk_freq=%d\n", mclk_freq);
+    return 0;
+}
+
+static void de1soc_shutdown(struct snd_pcm_substream *substream)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct device *dev = rtd->card->dev;
+    int ret;
+
+    dev_dbg(dev, "shutdown\n");
+    ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+        0, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        dev_err(dev, "Failed to reset WM8731 SYSCLK: %d\n", ret);
+    }
+}
+
+static struct snd_soc_ops de1soc_ops = {
+    // .startup
+    .shutdown = de1soc_shutdown,
+    .hw_params = de1soc_hw_params,
+    // .hw_free
+    // .prepare
+    // .trigger
+};
+
+static const struct snd_soc_dapm_widget de1soc_dapm_widgets[] = {
+    SND_SOC_DAPM_HP("Headphone Jack", NULL),
+    SND_SOC_DAPM_MIC("Microphone Jack", NULL),
+    SND_SOC_DAPM_LINE("Line In Jack", NULL),
+    SND_SOC_DAPM_LINE("Line Out Jack", NULL),
+    SND_SOC_DAPM_LINE("Hsynth in", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+    {"MICIN", NULL, "Mic Bias"},
+    {"Mic Bias", NULL, "Microphone Jack"},
+    {"LLINEIN", NULL, "Line In Jack"},
+    {"RLINEIN", NULL, "Line In Jack"},
+    {"Line Out Jack", NULL, "LOUT"},
+    {"Line Out Jack", NULL, "ROUT"},
+    {"Headphone Jack", NULL, "LHPOUT"},
+    {"Headphone Jack", NULL, "RHPOUT"},
+    {"HSYNTH", NULL, "Hsynth in"},
+};
+
+static int de1soc_wm8731_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct device *dev = rtd->card->dev;
+    unsigned int fmt;
+    int ret;
+
+    dev_dbg(dev, "init\n");
+
+    fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+        SND_SOC_DAIFMT_CBS_CFS;
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    /* Don't let codec constraints interfere */
+    ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+        0, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        dev_err(dev, "Failed to set WM8731 SYSCLK: %d\n", ret);
+        return ret;
+    }
+
+    return 0;
+}
+
+static int soc_hsynth_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct device *dev = rtd->card->dev;
+    unsigned int fmt;
+    int ret;
+
+    dev_dbg(dev, "init\n");
+
+    fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+    SND_SOC_DAIFMT_CBS_CFS;
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    return 0;
+}
+
+static struct snd_soc_dai_link de1soc_dai[] = {
+	{ /* Primary DAI i/f */
+    .name = "SSND0",
+    .stream_name = "WM8731 PCM",
+    .cpu_dai_name = "ff200000.i2s",
+    .codec_dai_name = "wm8731-hifi",
+    .init = de1soc_wm8731_init,
+    .platform_name = "de1soc",
+    .codec_name = "wm8731.0-001a",
+    .ops = &de1soc_ops,
+	}, { /* Sec_Fifo Playback i/f */
+    .name = "SSND1",
+    .stream_name = "HSYNTH PCM",
+    .cpu_dai_name = "ff200000.dmalink",
+    .codec_dai_name = "hsynth7002-hifi",
+    .init = soc_hsynth_init,
+    .platform_name = "de1soc",
+    .codec_name = "hsynth7002.hsynth",
+	},
+};
+/*
+static struct snd_soc_dai_link hsynth_soc_dai = {
+    .name = "HSYNTH",
+    .stream_name = "HSYNTH PCM",
+    .cpu_dai_name = "ff200000.dmalink",
+    .codec_dai_name = "hsynth7002-hifi",
+    .init = soc_hsynth_init,
+    .platform_name = "de1soc",
+    .codec_name = "hsynth7002.hsynth",
+};
+*/
+static struct snd_soc_card snd_soc_de1soc = {
+    .name = "DE1SND",
+    .owner = THIS_MODULE,
+    .dai_link = de1soc_dai,
+//    .dai_link = &hsynth_soc_dai,
+    .num_links = ARRAY_SIZE(de1soc_dai),
+
+    .probe        = hmidi_card_probe,
+    .remove       = hmidi_card_remove,
+
+    .dapm_widgets = de1soc_dapm_widgets,
+    .num_dapm_widgets = ARRAY_SIZE(de1soc_dapm_widgets),
+    .dapm_routes = intercon,
+    .num_dapm_routes = ARRAY_SIZE(intercon),
+};
+
+static int de1soc_audio_probe(struct platform_device *pdev)
+{
+    struct device_node *np = pdev->dev.of_node;
+    struct device_node *codec_np, *cpu_np;
+    struct snd_soc_card *card = &snd_soc_de1soc;
+    int ret;
+
+    if (!np) {
+        return -ENODEV;
+    }
+
+    card->dev = &pdev->dev;
+
+    /* I2C bus is muxed between HPS and FPGA. Set mux to HPS */
+    i2c_mux_gpio = of_get_named_gpio(np, "i2c-mux-gpio", 0);
+    if (gpio_is_valid(i2c_mux_gpio)) {
+        ret = devm_gpio_request_one(&pdev->dev,
+            i2c_mux_gpio, GPIOF_OUT_INIT_LOW, "I2C_MUX");
+        if (ret) {
+            dev_err(&pdev->dev,
+                "Failed to request GPIO_%d for i2c_mux: %d\n",
+                i2c_mux_gpio, ret);
+            return ret;
+        }
+        gpio_set_value(i2c_mux_gpio, 1);
+    }
+
+    /* Parse codec1 info */
+    de1soc_dai[0].codec_name = NULL;
+    codec_np = of_parse_phandle(np, "audio-codec", 0);
+    if (!codec_np) {
+        dev_err(&pdev->dev, "audio-codec info missing\n");
+        return -EINVAL;
+    }
+    de1soc_dai[0].codec_of_node = codec_np;
+
+    /* Parse dai and platform info */
+    de1soc_dai[0].cpu_dai_name = NULL;
+    de1soc_dai[0].platform_name = NULL;
+    cpu_np = of_parse_phandle(np, "i2s-controller", 0);
+    if (!cpu_np) {
+        dev_err(&pdev->dev, "i2s dai1 and pcm info missing\n");
+        return -EINVAL;
+    }
+
+    de1soc_dai[0].cpu_of_node = cpu_np;
+    de1soc_dai[0].platform_of_node = cpu_np;
+
+    of_node_put(codec_np);
+    of_node_put(cpu_np);
+
+    /* Parse codec2 info */
+    de1soc_dai[1].codec_name = NULL;
+    codec_np = of_parse_phandle(np, "synth-codec", 0);
+    if (!codec_np) {
+        dev_err(&pdev->dev, "synth-codec info missing\n");
+        return -EINVAL;
+    }
+    de1soc_dai[1].codec_of_node = codec_np;
+
+    /* Parse dai and platform info */
+    de1soc_dai[1].cpu_dai_name = NULL;
+    de1soc_dai[1].platform_name = NULL;
+    cpu_np = of_parse_phandle(np, "dmalink-controller", 0);
+    if (!cpu_np) {
+        dev_err(&pdev->dev, "dmalink-controller info missing\n");
+        return -EINVAL;
+    }
+
+    de1soc_dai[1].cpu_of_node = cpu_np;
+    de1soc_dai[1].platform_of_node = cpu_np;
+
+    of_node_put(codec_np);
+    of_node_put(cpu_np);
+
+
+    ret = snd_soc_register_card(card);
+    if (ret) {
+        dev_err(&pdev->dev, "snd_soc_register_card() failed\n");
+    }
+
+    return ret;
+}
+
+static int de1soc_audio_remove(struct platform_device *pdev)
+{
+    struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+    if (gpio_is_valid(i2c_mux_gpio))
+        devm_gpio_free(&pdev->dev, i2c_mux_gpio);
+
+    snd_soc_unregister_card(card);
+
+    return 0;
+}
+
+static const struct of_device_id de1soc_wm8731_dt_ids[] = {
+    { .compatible = "opencores,de1soc-wm8731-audio-midi", },
+    { }
+};
+MODULE_DEVICE_TABLE(of, de1soc_wm8731_dt_ids);
+
+static struct platform_driver de1soc_audio_driver = {
+    .driver = {
+        .name	= "de1soc-audio",
+        .owner	= THIS_MODULE,
+        .of_match_table = of_match_ptr(de1soc_wm8731_dt_ids),
+    },
+    .probe	= de1soc_audio_probe,
+    .remove	= de1soc_audio_remove,
+};
+
+module_platform_driver(de1soc_audio_driver);
+
+/* Module information */
+MODULE_AUTHOR("Bjarne Steinsbo <bsteinsbo@gmail.com>");
+MODULE_DESCRIPTION("ALSA SoC DE1-SoC_WM8731");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/socsynth/de1-soc-wm8731.c b/sound/soc/socsynth/de1-soc-wm8731.c
deleted file mode 100644
index 4e199bb..0000000
--- a/sound/soc/socsynth/de1-soc-wm8731.c
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
- * de1-soc-wm8731 -- SoC audio for Terasic DE1-SoC board
- * Author: B. Steinsbo <bsteinsbo@gmail.com>
- *
- * Based on sam9g20_wm8731 by
- * Sedji Gaouaou <sedji.gaouaou@atmel.com>
- *
- * Licensed under the GPL-2.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/clk.h>
-#include <linux/platform_device.h>
-#include <linux/of.h>
-#include <linux/gpio.h>
-#include <linux/of_gpio.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-
-#define WM8731_SYSCLK_XTAL 1
-#define WM8731_SYSCLK_MCLK 2
-#define MCLK_RATE_48K 12288000 /* fs*256 */
-#define MCLK_RATE_44K 16934400 /* fs*384 */
-
-static unsigned int i2c_mux_gpio;
-
-static int de1soc_hw_params(struct snd_pcm_substream *substream,
-	struct snd_pcm_hw_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct device *dev = rtd->card->dev;
-	unsigned int mclk_freq;
-	int ret;
-
-	if ((params_rate(params) % 44100) == 0) {
-		mclk_freq = MCLK_RATE_44K;
-	} else if ((params_rate(params) % 48000) == 0) {
-		mclk_freq = MCLK_RATE_48K;
-	} else
-		return -EINVAL;
-
-	/* set codec mclk configuration */
-	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
-		mclk_freq, SND_SOC_CLOCK_OUT);
-	if (ret < 0)
-		return ret;
-
-	dev_dbg(dev, "hw_params: mclk_freq=%d\n", mclk_freq);
-	return 0;
-}
-
-static void de1soc_shutdown(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct device *dev = rtd->card->dev;
-	int ret;
-
-	dev_dbg(dev, "shutdown\n");
-	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
-		0, SND_SOC_CLOCK_OUT);
-	if (ret < 0) {
-		dev_err(dev, "Failed to reset WM8731 SYSCLK: %d\n", ret);
-	}
-}
-
-static struct snd_soc_ops de1soc_ops = {
-	// .startup
-	.shutdown = de1soc_shutdown,
-	.hw_params = de1soc_hw_params,
-	// .hw_free
-	// .prepare
-	// .trigger
-};
-
-static const struct snd_soc_dapm_widget de1soc_dapm_widgets[] = {
-	SND_SOC_DAPM_HP("Headphone Jack", NULL),
-	SND_SOC_DAPM_MIC("Microphone Jack", NULL),
-	SND_SOC_DAPM_LINE("Line In Jack", NULL),
-	SND_SOC_DAPM_LINE("Line Out Jack", NULL),
-};
-
-static const struct snd_soc_dapm_route intercon[] = {
-	{"MICIN", NULL, "Mic Bias"},
-	{"Mic Bias", NULL, "Microphone Jack"},
-	{"LLINEIN", NULL, "Line In Jack"},
-	{"RLINEIN", NULL, "Line In Jack"},
-	{"Line Out Jack", NULL, "LOUT"},
-	{"Line Out Jack", NULL, "ROUT"},
-	{"Headphone Jack", NULL, "LHPOUT"},
-	{"Headphone Jack", NULL, "RHPOUT"},
-};
-
-static int de1soc_wm8731_init(struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct device *dev = rtd->card->dev;
-	unsigned int fmt;
-	int ret;
-
-	dev_dbg(dev, "init\n");
-
-	fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
-	      SND_SOC_DAIFMT_CBS_CFS;
-
-	/* set cpu DAI configuration */
-	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
-	if (ret < 0)
-		return ret;
-
-	/* set codec DAI configuration */
-	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
-	if (ret < 0)
-		return ret;
-
-	/* Don't let codec constraints interfere */
-	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
-		0, SND_SOC_CLOCK_OUT);
-	if (ret < 0) {
-		dev_err(dev, "Failed to set WM8731 SYSCLK: %d\n", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static struct snd_soc_dai_link de1soc_dai = {
-	.name = "WM8731",
-	.stream_name = "WM8731 PCM",
-	.cpu_dai_name = "ff200000.i2s",
-	.codec_dai_name = "wm8731-hifi",
-	.init = de1soc_wm8731_init,
-	.platform_name = "de1soc",
-	.codec_name = "wm8731.0-001a",
-	.ops = &de1soc_ops,
-};
-
-static struct snd_soc_card snd_soc_de1soc = {
-	.name = "DE1SOC-WM8731",
-	.owner = THIS_MODULE,
-	.dai_link = &de1soc_dai,
-	.num_links = 1,
-
-	.dapm_widgets = de1soc_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(de1soc_dapm_widgets),
-	.dapm_routes = intercon,
-	.num_dapm_routes = ARRAY_SIZE(intercon),
-};
-
-static int de1soc_audio_probe(struct platform_device *pdev)
-{
-	struct device_node *np = pdev->dev.of_node;
-	struct device_node *codec_np, *cpu_np;
-	struct snd_soc_card *card = &snd_soc_de1soc;
-	int ret;
-
-	if (!np) {
-		return -ENODEV;
-	}
-
-	card->dev = &pdev->dev;
-
-	/* I2C bus is muxed between HPS and FPGA. Set mux to HPS */
-	i2c_mux_gpio = of_get_named_gpio(np, "i2c-mux-gpio", 0);
-	if (gpio_is_valid(i2c_mux_gpio)) {
-		ret = devm_gpio_request_one(&pdev->dev,
-			i2c_mux_gpio, GPIOF_OUT_INIT_LOW, "I2C_MUX");
-		if (ret) {
-			dev_err(&pdev->dev,
-				"Failed to request GPIO_%d for i2c_mux: %d\n",
-				i2c_mux_gpio, ret);
-			return ret;
-		}
-		gpio_set_value(i2c_mux_gpio, 1);
-	}
-
-	/* Parse codec info */
-	de1soc_dai.codec_name = NULL;
-	codec_np = of_parse_phandle(np, "audio-codec", 0);
-	if (!codec_np) {
-		dev_err(&pdev->dev, "codec info missing\n");
-		return -EINVAL;
-	}
-	de1soc_dai.codec_of_node = codec_np;
-
-	/* Parse dai and platform info */
-	de1soc_dai.cpu_dai_name = NULL;
-	de1soc_dai.platform_name = NULL;
-	cpu_np = of_parse_phandle(np, "i2s-controller", 0);
-	if (!cpu_np) {
-		dev_err(&pdev->dev, "dai and pcm info missing\n");
-		return -EINVAL;
-	}
-	de1soc_dai.cpu_of_node = cpu_np;
-	de1soc_dai.platform_of_node = cpu_np;
-
-	of_node_put(codec_np);
-	of_node_put(cpu_np);
-
-	ret = snd_soc_register_card(card);
-	if (ret) {
-		dev_err(&pdev->dev, "snd_soc_register_card() failed\n");
-	}
-
-	return ret;
-}
-
-static int de1soc_audio_remove(struct platform_device *pdev)
-{
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
-
-	if (gpio_is_valid(i2c_mux_gpio))
-		devm_gpio_free(&pdev->dev, i2c_mux_gpio);
-
-	snd_soc_unregister_card(card);
-
-	return 0;
-}
-
-static const struct of_device_id de1soc_wm8731_dt_ids[] = {
-	{ .compatible = "opencores,de1soc-wm8731-audio", },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, de1soc_wm8731_dt_ids);
-
-static struct platform_driver de1soc_audio_driver = {
-	.driver = {
-		.name	= "de1soc-audio",
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(de1soc_wm8731_dt_ids),
-	},
-	.probe	= de1soc_audio_probe,
-	.remove	= de1soc_audio_remove,
-};
-
-module_platform_driver(de1soc_audio_driver);
-
-/* Module information */
-MODULE_AUTHOR("Bjarne Steinsbo <bsteinsbo@gmail.com>");
-MODULE_DESCRIPTION("ALSA SoC DE1-SoC_WM8731");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/socsynth/holosynthv.c b/sound/soc/socsynth/holosynthv.c
deleted file mode 100644
index 60104716d..0000000
--- a/sound/soc/socsynth/holosynthv.c
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
- * hsynth-soc -- SoC audio ( midi for Altera SoC boards
- * Author: Michael Brown the-snowwhite <producer@holotronic.dk>
- *
- * Based on de1-soc-wm8731 by
- *  B. Steinsbo <bsteinsbo@gmail.com>
- *
- * Licensed under the GPL-2.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/clk.h>
-#include <linux/platform_device.h>
-#include <linux/of.h>
-#include <linux/uaccess.h>
-#include <linux/ioport.h>
-#include <linux/io.h>
-
-#include <sound/core.h>
-#include <sound/seq_kernel.h>
-#include <sound/rawmidi.h>
-#include <sound/initval.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-
-#define SYNTHSOCSOUND_LOG_PREFIX "synthsound: "
-
-#define HSYNTH_SYSCLK_MCLK 2
-//#define MCLK_RATE_48K 12288000 /* fs*256 */
-#define MCLK_RATE_44K 16934400 /* fs*384 */
-#define midi_ins 0
-#define midi_outs 1
-
-#define MIDIREG_BASE 0xff200000
-#define MIDIREG_SIZE PAGE_SIZE
-#define MIDIREG_OFFSET 0x50000
-
-#define printe(...) pr_err(SYNTHSOCSOUND_LOG_PREFIX __VA_ARGS__)
-
-static int snd_socmidi_open(struct snd_rawmidi_substream *substream);
-static int snd_socmidi_close(struct snd_rawmidi_substream *substream);
-static int hmidi_card_probe(struct snd_soc_card *card);
-static int hmidi_card_remove(struct snd_soc_card *card);
-static void snd_socmidi_transmit(unsigned char data);
-static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int);
-static int hsound_midi_init(struct snd_card *card);
-
-void *midireg_mem;
-
-static int snd_socmidi_open(struct snd_rawmidi_substream *substream)
-{
-    return 0;
-}
-
-static int snd_socmidi_close(struct snd_rawmidi_substream *substream)
-{
-    return 0;
-}
-
-static int hmidi_card_probe(struct snd_soc_card *card)
-{
-    int err;
-
-    err = hsound_midi_init(card->snd_card);
-
-    if (err < 0) {
-        //		dev_dbg(&pdev->dev,"hsound_midi_init failed: %d\n", err);
-        return err;
-    }
-
-    return 0;
-}
-
-static int hmidi_card_remove(struct snd_soc_card *card)
-{
-    return 0;
-}
-
-static void snd_socmidi_transmit(unsigned char data){
-
-    iowrite8(data, midireg_mem);
-
-}
-
-static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int up) {
-
-    if (!up)
-        return;
-
-    while (1) {
-        unsigned char data;
-        if (snd_rawmidi_transmit(substream, &data, 1) != 1)
-            break; /* no more data */
-            snd_socmidi_transmit(data);
-    }
-}
-
-static struct snd_rawmidi *g_rmidi;
-
-static struct snd_rawmidi_ops snd_socmidi_output_ops = {
-    .open = snd_socmidi_open,
-    .close = snd_socmidi_close,
-    .trigger = snd_socmidi_output_trigger,
-};
-
-static void pisnd_get_port_info(struct snd_rawmidi *rmidi, int number, struct snd_seq_port_info *seq_port_info)
-{
-    seq_port_info->type =
-    SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
-    SNDRV_SEQ_PORT_TYPE_HARDWARE |
-    SNDRV_SEQ_PORT_TYPE_PORT;
-    seq_port_info->midi_voices = 0;
-}
-
-static struct snd_rawmidi_global_ops hsnd_global_ops = {.get_port_info = pisnd_get_port_info, };
-
-static int hsound_midi_init(struct snd_card *card)
-{
-    int err;
-    struct resource *res;
-
-    err = snd_rawmidi_new(card, "SocMIDI", 0, midi_outs, midi_ins, &g_rmidi);
-
-    if (err < 0) {
-        printe("snd_rawmidi_new failed: %d\n", err);
-        return err;
-    }
-
-    strcpy(g_rmidi->name, "Holosynth MIDI ");
-
-    g_rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT;
-    // rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
-    //                     SNDRV_RAWMIDI_INFO_INPUT |
-    //                     SNDRV_RAWMIDI_INFO_DUPLEX;
-
-    g_rmidi->ops = &hsnd_global_ops;
-
-    g_rmidi->private_data = (void *)0;
-
-    snd_rawmidi_set_ops(g_rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_socmidi_output_ops);
-    //    snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_socmidi_input_ops);
-
-    res = request_mem_region((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE, "MIDIREG");
-    if (res == NULL) {
-        return -EBUSY;
-    }
-
-    midireg_mem = ioremap((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE);
-    if (midireg_mem == NULL) {
-        release_mem_region(MIDIREG_BASE, MIDIREG_SIZE);
-        return -EFAULT;
-    }
-
-    return 0;
-}
-
-static const struct snd_soc_dapm_widget soc_dapm_widgets[] = {
-    SND_SOC_DAPM_LINE("Hsynth in", NULL),
-};
-
-static const struct snd_soc_dapm_route intercon[] = {
-    {"PDM_DAT", NULL, "Hsynth in"},
-};
-
-static int soc_hsynth_init(struct snd_soc_pcm_runtime *rtd)
-{
-    struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-    struct device *dev = rtd->card->dev;
-    unsigned int fmt;
-    int ret;
-
-    dev_dbg(dev, "init\n");
-
-    fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
-    SND_SOC_DAIFMT_CBS_CFS;
-
-    /* set cpu DAI configuration */
-    ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
-    if (ret < 0)
-        return ret;
-
-    /* set codec DAI configuration */
-    ret = snd_soc_dai_set_fmt(codec_dai, fmt);
-    if (ret < 0)
-        return ret;
-
-    return 0;
-}
-
-static struct snd_soc_dai_link hsynth_soc_dai = {
-    .name = "HSYNTH",
-    .stream_name = "HSYNTH PCM",
-    .cpu_dai_name = "ff200000.dmalink",
-    .codec_dai_name = "hsynth7002-hifi",
-    .init = soc_hsynth_init,
-    .platform_name = "socsynth",
-    .codec_name = "hsynth7002.hsynth",
-};
-
-static struct snd_soc_card snd_soc_hsynth_soc = {
-    .name = "HOLOSYNTHV",
-    .owner = THIS_MODULE,
-    .dai_link = &hsynth_soc_dai,
-    .num_links = 1,
-
-    .probe        = hmidi_card_probe,
-    .remove       = hmidi_card_remove,
-
-    .dapm_widgets = soc_dapm_widgets,
-    .num_dapm_widgets = ARRAY_SIZE(soc_dapm_widgets),
-    .dapm_routes = intercon,
-    .num_dapm_routes = ARRAY_SIZE(intercon),
-};
-
-static int hsynth_soc_audio_probe(struct platform_device *pdev)
-{
-    struct device_node *np = pdev->dev.of_node;
-    struct device_node *codec_np, *cpu_np;
-    struct snd_soc_card *card = &snd_soc_hsynth_soc;
-    int ret;
-
-    if (!np) {
-        return -ENODEV;
-    }
-
-    card->dev = &pdev->dev;
-
-    /* Parse codec info */
-    hsynth_soc_dai.codec_name = NULL;
-    codec_np = of_parse_phandle(np, "audio-codec", 0);
-    if (!codec_np) {
-        dev_err(&pdev->dev, "codec info missing\n");
-        return -EINVAL;
-    }
-    hsynth_soc_dai.codec_of_node = codec_np;
-
-    /* Parse dai and platform info */
-    hsynth_soc_dai.cpu_dai_name = NULL;
-    hsynth_soc_dai.platform_name = NULL;
-    cpu_np = of_parse_phandle(np, "dmalink-controller", 0);
-    if (!cpu_np) {
-        dev_err(&pdev->dev, "dai and pcm info missing\n");
-        return -EINVAL;
-    }
-    hsynth_soc_dai.cpu_of_node = cpu_np;
-    hsynth_soc_dai.platform_of_node = cpu_np;
-
-    of_node_put(codec_np);
-    of_node_put(cpu_np);
-
-    ret = snd_soc_register_card(card);
-    if (ret) {
-        dev_err(&pdev->dev, "snd_soc_register_card() failed\n");
-    }
-
-    return ret;
-}
-
-static int soc_audio_remove(struct platform_device *pdev)
-{
-    struct snd_soc_card *card = platform_get_drvdata(pdev);
-
-    snd_soc_unregister_card(card);
-
-    return 0;
-}
-
-static const struct of_device_id soc_hsynth_dt_ids[] = {
-    { .compatible = "holotr,socsynth-audio", },
-    { }
-};
-MODULE_DEVICE_TABLE(of, soc_hsynth_dt_ids);
-
-static struct platform_driver soc_audio_driver = {
-    .driver = {
-        .name	= "soc-synth-audio",
-        .owner	= THIS_MODULE,
-        .of_match_table = of_match_ptr(soc_hsynth_dt_ids),
-    },
-    .probe	= hsynth_soc_audio_probe,
-    .remove	= soc_audio_remove,
-};
-
-module_platform_driver(soc_audio_driver);
-
-/* Module information */
-MODULE_AUTHOR("Michael Brown (the-snowwhite) <producer@holotronic.dk>");
-MODULE_DESCRIPTION("ALSA SoC HOLOSYNTHV");
-MODULE_LICENSE("GPL");
-- 
2.7.4


From f5864421750b65a39a16e592be2d4cfdbf556043 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Fri, 4 May 2018 14:32:56 +0200
Subject: [PATCH 14/16] add vipii fb settings for DE10 Nano HD HDMI

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/boot/dts/Makefile                         |   2 +
 .../socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts | 220 +++++++++++++++++++++
 arch/arm/configs/socfpga_defconfig                 |   5 +-
 drivers/video/fbdev/altvipfb2.c                    |  12 +-
 4 files changed, 231 insertions(+), 8 deletions(-)
 create mode 100644 arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index f7f25c2..10e2e74 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -704,6 +704,8 @@ dtb-$(CONFIG_ARCH_SOCFPGA) += \
 	socfpga_cyclone5_de10_nano_uio_fb_hd.dtb \
 	socfpga_cyclone5_de1_soc.dtb \
 	socfpga_cyclone5_de1_soc_fbII.dtb \
+	socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dtb \
+	socfpga_cyclone5_de10_nano.dtb \
 	socfpga_cyclone5_sockit.dtb \
 	socfpga_cyclone5_socrates.dtb \
 	socfpga_cyclone5_sodia.dtb \
diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
new file mode 100644
index 0000000..96b0df1
--- /dev/null
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
@@ -0,0 +1,220 @@
+/*
+* Copyright Intel Corporation (C) 2017. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms and conditions of the GNU General Public License,
+* version 2, as published by the Free Software Foundation.
+*
+* This program is distributed in the hope it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "socfpga_cyclone5.dtsi"
+
+/ {
+	model = "Terasic DE10-Nano";
+	compatible = "altr,socfpga-cyclone5", "altr,socfpga";
+
+	chosen {
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		hps0 {
+			label = "hps_led0";
+			gpios = <&portb 24 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		hps0 {
+			label = "hps_key0";
+			gpios = <&portb 25 0>;
+			linux,code = <63>;
+			debounce-interval = <50>;
+		};
+	};
+
+	sound {
+		compatible = "ti,pcm5102a";
+	};
+
+	bridge@0xc0000000 {
+		compatible = "altr,bridge-15.1", "simple-bus";
+		reg = <0xc0000000 0x20000000 0xff200000 0x200000>;
+		#address-cells = <0x2>;
+		#size-cells = <0x1>;
+		ranges = <0x00000001 0x00001000 0xff201000 0x00000008>,
+				<0x00000001 0x00002000 0xff202000 0x00000008>,
+				<0x00000001 0x00003000 0xff203000 0x00000010>,
+				<0x00000001 0x00004000 0xff204000 0x00000010>,
+				<0x00000001 0x00005000 0xff205000 0x00000010>,
+				<0x00000001 0x00030000 0xff230000 0x00000100>,
+				<0x00000001 0x00031000 0xff231000 0x00000080>,
+				<0x00000001 0x00040000 0xff240000 0x00010000>,
+				<0x00000001 0x00050000 0xff250000 0x00010000>;
+
+		sysid@0x100001000 {
+			compatible = "altr,sysid-15.1", "altr,sysid-1.0";
+			reg = <0x00000001 0x00001000 0x00000008>;
+			id = <0xacd51302>;
+			timestamp = <0x5929e204>;
+		};
+
+		serial@0x100002000 {
+			compatible = "altr,juart-15.1", "altr,juart-1.0";
+			reg = <0x00000001 0x00002000 0x00000008>;
+			interrupt-parent = <0x3>;
+			interrupts = <0x0 0x2a 0x4>;
+			clocks = <0x2>;
+		};
+
+		gpio@0x100003000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00003000 0x00000010>;
+			altr,gpio-bank-width = <0x8>;
+			resetvalue = <0xff>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100004000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00004000 0x00000010>;
+			altr,gpio-bank-width = <0x4>;
+			altr,interrupt-type = <0x3>;
+			altr,interrupt_type = <0x3>;
+			edge_type = <0x2>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		gpio@0x100005000 {
+			compatible = "altr,pio-15.1", "altr,pio-1.0";
+			reg = <0x00000001 0x00005000 0x00000010>;
+			altr,gpio-bank-width = <0x2>;
+			altr,interrupt-type = <0x2>;
+			altr,interrupt_type = <0x2>;
+			edge_type = <0x1>;
+			level_trigger = <0x0>;
+			resetvalue = <0x0>;
+			#gpio-cells = <0x2>;
+			gpio-controller;
+		};
+
+		ilc@0x100030000 {
+			compatible = "altr,altera_ilc-15.1", "altr,ilc-1.0";
+			reg = <0x00000001 0x00030000 0x00000100>;
+			interrupt-controller;
+			#interrupt-cells = <0x1>;
+			altr,sw-fifo-depth = <0x20>;
+		};
+
+		vip@0x100031000 {
+			compatible = "altr,vip-frame-buffer-ii-2.0";
+			reg = <0x00000001 0x00031000 0x00000080>;
+			max-width = <1920>;
+			max-height = <1080>;
+			bits-per-color = <0x8>;
+			colors-per-beat = <0x4>;
+			beats-per-pixel = <0x1>;
+			mem-word-width = <0x80>;
+		};
+
+		uio-socfpg0@0x100040000 {
+			compatible = "generic-uio,ui_pdrv";
+			reg = <0x00000001 0x00040000 0x00010000>;
+			interrupt-parent = <0x2>;
+			interrupts = <0 43 1>;
+			address_width = <14>;
+			data_width = <32>;
+		};
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	txd0-skew-ps = <0>; /* -420ps */
+	txd1-skew-ps = <0>; /* -420ps */
+	txd2-skew-ps = <0>; /* -420ps */
+	txd3-skew-ps = <0>; /* -420ps */
+	rxd0-skew-ps = <420>; /* 0ps */
+	rxd1-skew-ps = <420>; /* 0ps */
+	rxd2-skew-ps = <420>; /* 0ps */
+	rxd3-skew-ps = <420>; /* 0ps */
+	txen-skew-ps = <0>; /* -420ps */
+	txc-skew-ps = <1860>; /* 960ps */
+	rxdv-skew-ps = <420>; /* 0ps */
+	rxc-skew-ps = <1680>; /* 780ps */
+
+	max-frame-size = <3800>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	speed-mode = <0>;
+
+	adxl345: adxl345@0 {
+		compatible = "adi,adxl34x";
+		reg = <0x53>;
+
+		interrupt-parent = <&portc>;
+		interrupts = <3 2>;
+	};
+};
+
+&mmc0 {
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index eccb192..d383114 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -116,8 +116,8 @@ CONFIG_MFD_STMPE=y
 CONFIG_REGULATOR=y
 CONFIG_REGULATOR_FIXED_VOLTAGE=y
 CONFIG_FB=y
-CONFIG_FB_ALTERA_VIP=m
-CONFIG_FB_ALTERA_VIP_FB2_PLAT=m
+CONFIG_FB_ALTERA_VIP=y
+CONFIG_FB_ALTERA_VIP_FB2_PLAT=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
 CONFIG_USB=y
@@ -354,3 +354,4 @@ CONFIG_SND_SOC_FSL_ESAI=m
 CONFIG_SND_SOC_IMX_AUDMUX=m
 CONFIG_SND_SOC_I2C_AND_SPI=y
 CONFIG_HZ_1000=y
+CONFIG_SND_SOC_PCM5102A=m
diff --git a/drivers/video/fbdev/altvipfb2.c b/drivers/video/fbdev/altvipfb2.c
index e6d3b1c..879b9bd 100644
--- a/drivers/video/fbdev/altvipfb2.c
+++ b/drivers/video/fbdev/altvipfb2.c
@@ -104,13 +104,13 @@ static void altvipfb2_setup_fb_info(struct altvipfb2_priv *fbpriv)
 	info->var.width = -1;
 	info->var.vmode = FB_VMODE_NONINTERLACED;
 
-	info->var.pixclock = 6734;
-	info->var.left_margin = 148;
-	info->var.right_margin = 88;
-	info->var.upper_margin = 36;
+	info->var.pixclock = 6667;
+	info->var.left_margin = 10;
+	info->var.right_margin = 2;
+	info->var.upper_margin = 32;
 	info->var.lower_margin = 4;
-	info->var.hsync_len = 44;
-	info->var.vsync_len = 5;
+	info->var.hsync_len = 36;
+	info->var.vsync_len = 4;
 
 	/* settings for 32bit pixels */
 	info->var.red.offset = 16;
-- 
2.7.4


From 8bd07449b3cbdc10c9b3eb1b90d1dd402dad1b07 Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Thu, 17 May 2018 10:58:21 +0200
Subject: [PATCH 15/16] Add Hsynth midi/audio driver with Phat(pcm5102) audio
 output

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 .../socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts |  34 +-
 arch/arm/configs/socfpga_defconfig                 |   2 +-
 sound/soc/codecs/Kconfig                           |   5 +-
 sound/soc/codecs/Makefile                          |   2 +
 sound/soc/codecs/hsynthpcm5102.c                   | 124 ++++++
 sound/soc/socsynth/Kconfig                         |   8 +
 sound/soc/socsynth/Makefile                        |   3 +
 sound/soc/socsynth/de10-soc-pcm5102-midi.c         | 438 +++++++++++++++++++++
 8 files changed, 613 insertions(+), 3 deletions(-)
 create mode 100644 sound/soc/codecs/hsynthpcm5102.c
 create mode 100644 sound/soc/socsynth/de10-soc-pcm5102-midi.c

diff --git a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
index 96b0df1..e5db1fd 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5_de10_nano_uio_aud_fbii_hd.dts
@@ -62,7 +62,39 @@
 	};
 
 	sound {
-		compatible = "ti,pcm5102a";
+		compatible = "opencores,de10soc-hsynthpcm5102-audio-midi";
+		i2s-controller = <&i2s>;
+		audio-codec = <&hsynthpcm5102_codec>;
+	};
+
+	clk48: clk48 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <24576000>;
+		clock-output-names = "clk48";
+	};
+
+	clk44: clk44 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <33868800>;
+		clock-output-names = "clk44";
+	};
+
+	i2s: i2s@0x0 {
+		#sound-dai-cells = <1>;
+		compatible = "opencores,i2s";
+		reg = <0xff200000 0x20>, <0xff200020 0x20>;
+		clocks = <&clk44>, <&clk48>;
+		clock-names = "clk44", "clk48";
+		dmas = <&pdma 0>, <&pdma 1>;
+		dma-names = "tx", "rx";
+	};
+
+	hsynthpcm5102_codec: hsynthpcm5102-codec {
+	#sound-dai-cells = <0>;
+		compatible = "holotr,hsynthpcm5102";
+		status = "okay";
 	};
 
 	bridge@0xc0000000 {
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index d383114..c74d6ea 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -354,4 +354,4 @@ CONFIG_SND_SOC_FSL_ESAI=m
 CONFIG_SND_SOC_IMX_AUDMUX=m
 CONFIG_SND_SOC_I2C_AND_SPI=y
 CONFIG_HZ_1000=y
-CONFIG_SND_SOC_PCM5102A=m
+CONFIG_SND_SOC_DE10_PCM5102_MIDI=m
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 49e8c24..6162113 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -73,6 +73,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_GTM601
 	select SND_SOC_HDAC_HDMI
 	select SND_SOC_HSYNTH7002
+	select SND_SOC_HSYNTHPCM5102
 	select SND_SOC_ICS43432
 	select SND_SOC_INNO_RK3036
 	select SND_SOC_ISABELLE if I2C
@@ -514,8 +515,10 @@ config SND_SOC_HDMI_CODEC
 	select HDMI
 
 config SND_SOC_HSYNTH7002
-	tristate "Dummy Soc synthesizer codec-driver driver"
+	tristate "Dummy Soc synthesizer codec-driver"
 
+config SND_SOC_HSYNTHPCM5102
+	tristate "Pihat Hsynth Soc synthesizer codec-driver"
 
 config SND_SOC_ES8328
 	tristate "Everest Semi ES8328 CODEC"
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index be562a4..2c4c3f5 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -67,6 +67,7 @@ snd-soc-es8328-spi-objs := es8328-spi.o
 snd-soc-gtm601-objs := gtm601.o
 snd-soc-hdac-hdmi-objs := hdac_hdmi.o
 snd-soc-hsynth7002-objs := hsynth7002.o
+snd-soc-hsynthpcm5102-objs := hsynthpcm5102.o
 snd-soc-ics43432-objs := ics43432.o
 snd-soc-inno-rk3036-objs := inno_rk3036.o
 snd-soc-isabelle-objs := isabelle.o
@@ -293,6 +294,7 @@ obj-$(CONFIG_SND_SOC_ES8328_SPI)+= snd-soc-es8328-spi.o
 obj-$(CONFIG_SND_SOC_GTM601)    += snd-soc-gtm601.o
 obj-$(CONFIG_SND_SOC_HDAC_HDMI) += snd-soc-hdac-hdmi.o
 obj-$(CONFIG_SND_SOC_HSYNTH7002)+= snd-soc-hsynth7002.o
+obj-$(CONFIG_SND_SOC_HSYNTHPCM5102)+= snd-soc-hsynthpcm5102.o
 obj-$(CONFIG_SND_SOC_ICS43432)	+= snd-soc-ics43432.o
 obj-$(CONFIG_SND_SOC_INNO_RK3036)	+= snd-soc-inno-rk3036.o
 obj-$(CONFIG_SND_SOC_ISABELLE)	+= snd-soc-isabelle.o
diff --git a/sound/soc/codecs/hsynthpcm5102.c b/sound/soc/codecs/hsynthpcm5102.c
new file mode 100644
index 0000000..dd97160
--- /dev/null
+++ b/sound/soc/codecs/hsynthpcm5102.c
@@ -0,0 +1,124 @@
+/*
+* HSYNTH7002 Soc Synthesizer dummy codec driver
+*
+* Copyright 2017 Holotronic
+*  Michael Brown (the-snowwhite) <producer@holotronic.dk>
+*  based on hsynth7002.c
+*
+* Licensed under the GPL-2.
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include <sound/soc.h>
+
+static const struct snd_soc_dapm_widget hsynthpcm5102_widgets[] = {
+    SND_SOC_DAPM_OUTPUT("PCMOUT"),
+    SND_SOC_DAPM_INPUT("HSYNTH"),
+};
+
+static const struct snd_soc_dapm_route hsynthpcm5102_routes[] = {
+	{ "Playback", NULL, "PCMOUT" },
+    { "Capture", NULL, "HSYNTH" },
+};
+
+static int hsynthpcm5102_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+    switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+    case SND_SOC_DAIFMT_CBS_CFS:
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+    case SND_SOC_DAIFMT_NB_NF:
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_I2S:
+    case SND_SOC_DAIFMT_DSP_A:
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static const struct snd_soc_dai_ops hsynthpcm5102_dai_ops = {
+    .set_fmt = hsynthpcm5102_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver hsynthpcm5102_dai = {
+    .name = "hsynthpcm5102-hifi",
+    .playback = {
+        .stream_name = "Playback",
+        .channels_min = 2,
+        .channels_max = 2,
+        .rates = SNDRV_PCM_RATE_8000_192000,
+        .formats = SNDRV_PCM_FMTBIT_S16_LE |
+            SNDRV_PCM_FMTBIT_S24_LE |
+            SNDRV_PCM_FMTBIT_S32_LE,
+    },
+    .capture = {
+        .stream_name = "Capture",
+        .channels_min = 2,
+        .channels_max = 2,
+        .rates = SNDRV_PCM_RATE_8000_192000,
+        .formats = SNDRV_PCM_FMTBIT_S16_LE |
+            SNDRV_PCM_FMTBIT_S24_LE |
+            SNDRV_PCM_FMTBIT_S32_LE,
+        .sig_bits = 20,
+    },
+    .ops = &hsynthpcm5102_dai_ops,
+};
+
+static const struct snd_soc_codec_driver hsynthpcm5102_codec_driver = {
+    .component_driver = {
+        .dapm_widgets = hsynthpcm5102_widgets,
+        .num_dapm_widgets = ARRAY_SIZE(hsynthpcm5102_widgets),
+        .dapm_routes = hsynthpcm5102_routes,
+        .num_dapm_routes = ARRAY_SIZE(hsynthpcm5102_routes),
+    },
+};
+
+static int hsynthpcm5102_probe(struct platform_device *pdev)
+{
+    return snd_soc_register_codec(&pdev->dev, &hsynthpcm5102_codec_driver,
+            &hsynthpcm5102_dai, 1);
+}
+
+static int hsynthpcm5102_remove(struct platform_device *pdev)
+{
+    snd_soc_unregister_codec(&pdev->dev);
+    return 0;
+}
+
+//#ifdef CONFIG_OF
+static const struct of_device_id hsynthpcm5102_dt_ids[] = {
+    { .compatible = "holotr,hsynthpcm5102", },
+    { }
+};
+MODULE_DEVICE_TABLE(of, hsynthpcm5102_dt_ids);
+//#endif
+
+static struct platform_driver hsynthpcm5102_driver = {
+    .driver = {
+        .name = "hsynthpcm5102",
+        .of_match_table	= of_match_ptr(hsynthpcm5102_dt_ids),
+    },
+    .probe = hsynthpcm5102_probe,
+    .remove = hsynthpcm5102_remove,
+};
+module_platform_driver(hsynthpcm5102_driver);
+
+MODULE_AUTHOR("Michael Brown <producer@holotronic.dk>");
+MODULE_DESCRIPTION("HSYNTH7002 Dummy Soc synthesizer codec-driver driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/socsynth/Kconfig b/sound/soc/socsynth/Kconfig
index 5486745..ba0f4f6 100644
--- a/sound/soc/socsynth/Kconfig
+++ b/sound/soc/socsynth/Kconfig
@@ -25,3 +25,11 @@ config SND_SOC_DE1_WM8731_MIDI
        select REGMAP_MMIO
        select SND_SOC_HSYNTH7002
        select SND_SOC_HSYNTHDMA
+
+config SND_SOC_DE10_PCM5102_MIDI
+       tristate "DE10-Nano-Audio MIDI support"
+       select SND_SOC_HSYNTHPCM5102
+       select SND_SOC_OC_I2S
+       select SND_SOC_GENERIC_DMAENGINE_PCM
+       select SND_RAWMIDI
+       select REGMAP_MMIO
diff --git a/sound/soc/socsynth/Makefile b/sound/soc/socsynth/Makefile
index d0ec5df..87b0b1e 100644
--- a/sound/soc/socsynth/Makefile
+++ b/sound/soc/socsynth/Makefile
@@ -6,3 +6,6 @@ obj-$(CONFIG_SND_SOC_DE1_WM8731_MIDI) += snd-de1-soc-wm8731-midi.o
 
 snd-soc-hsynthdma-objs := hsynthdma.o
 obj-$(CONFIG_SND_SOC_HSYNTHDMA) += snd-soc-hsynthdma.o
+
+snd-de10-soc-pcm5102-midi-objs := de10-soc-pcm5102-midi.o
+obj-$(CONFIG_SND_SOC_DE1_WM8731_MIDI) += snd-de10-soc-pcm5102-midi.o
diff --git a/sound/soc/socsynth/de10-soc-pcm5102-midi.c b/sound/soc/socsynth/de10-soc-pcm5102-midi.c
new file mode 100644
index 0000000..1ffc0e3
--- /dev/null
+++ b/sound/soc/socsynth/de10-soc-pcm5102-midi.c
@@ -0,0 +1,438 @@
+/*
+* de1-soc-wm8731 -- SoC audio for Terasic DE1-SoC board
+* Author: B. Steinsbo <bsteinsbo@gmail.com>
+*
+* Based on sam9g20_wm8731 by
+* Sedji Gaouaou <sedji.gaouaou@atmel.com>
+*
+* Licensed under the GPL-2.
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/uaccess.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/seq_kernel.h>
+#include <sound/rawmidi.h>
+#include <sound/initval.h>
+
+#define SOCSYNTHMIDI_LOG_PREFIX "socsynthmidi: "
+#define midi_ins 0
+#define midi_outs 1
+
+#define MIDIREG_BASE 0xff200000
+#define MIDIREG_SIZE PAGE_SIZE
+#define MIDIREG_OFFSET 0x50000
+
+//#define WM8731_SYSCLK_XTAL 1
+//#define WM8731_SYSCLK_MCLK 2
+#define MCLK_RATE_48K 12288000 /* fs*256 */
+#define MCLK_RATE_44K 16934400 /* fs*384 */
+
+#define printe(...) pr_err(SOCSYNTHMIDI_LOG_PREFIX __VA_ARGS__)
+
+static int snd_socmidi_open(struct snd_rawmidi_substream *substream);
+static int snd_socmidi_close(struct snd_rawmidi_substream *substream);
+static int hmidi_card_probe(struct snd_soc_card *card);
+static int hmidi_card_remove(struct snd_soc_card *card);
+static void snd_socmidi_transmit(unsigned char data);
+static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int);
+static int hsound_midi_init(struct snd_card *card);
+
+void *midireg_mem;
+
+static int snd_socmidi_open(struct snd_rawmidi_substream *substream)
+{
+    return 0;
+}
+
+static int snd_socmidi_close(struct snd_rawmidi_substream *substream)
+{
+    return 0;
+}
+
+static int hmidi_card_probe(struct snd_soc_card *card)
+{
+    int err;
+
+    err = hsound_midi_init(card->snd_card);
+
+    if (err < 0) {
+        //		dev_dbg(&pdev->dev,"hsound_midi_init failed: %d\n", err);
+        return err;
+    }
+
+    return 0;
+}
+
+static int hmidi_card_remove(struct snd_soc_card *card)
+{
+    return 0;
+}
+
+static void snd_socmidi_transmit(unsigned char data){
+
+    iowrite8(data, midireg_mem);
+
+}
+
+static void snd_socmidi_output_trigger(struct snd_rawmidi_substream *substream, int up) {
+
+    if (!up)
+        return;
+
+    while (1) {
+        unsigned char data;
+        if (snd_rawmidi_transmit(substream, &data, 1) != 1)
+            break; /* no more data */
+        snd_socmidi_transmit(data);
+    }
+}
+
+static struct snd_rawmidi *g_rmidi;
+
+static struct snd_rawmidi_ops snd_socmidi_output_ops = {
+    .open = snd_socmidi_open,
+    .close = snd_socmidi_close,
+    .trigger = snd_socmidi_output_trigger,
+};
+
+static void pisnd_get_port_info(struct snd_rawmidi *rmidi, int number, struct snd_seq_port_info *seq_port_info)
+{
+    seq_port_info->type =
+    SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
+    SNDRV_SEQ_PORT_TYPE_HARDWARE |
+    SNDRV_SEQ_PORT_TYPE_PORT;
+    seq_port_info->midi_voices = 0;
+}
+
+static struct snd_rawmidi_global_ops hsnd_global_ops = {.get_port_info = pisnd_get_port_info, };
+
+static int hsound_midi_init(struct snd_card *card)
+{
+    int err;
+    struct resource *res;
+
+    err = snd_rawmidi_new(card, "SocMIDI", 0, midi_outs, midi_ins, &g_rmidi);
+
+    if (err < 0) {
+        printe("snd_rawmidi_new failed: %d\n", err);
+        return err;
+    }
+
+    strcpy(g_rmidi->name, "Holosynth MIDI ");
+
+    g_rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT;
+    // rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
+    //                     SNDRV_RAWMIDI_INFO_INPUT |
+    //                     SNDRV_RAWMIDI_INFO_DUPLEX;
+
+    g_rmidi->ops = &hsnd_global_ops;
+
+    g_rmidi->private_data = (void *)0;
+
+    snd_rawmidi_set_ops(g_rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_socmidi_output_ops);
+    //    snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_socmidi_input_ops);
+
+    res = request_mem_region((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE, "MIDIREG");
+    if (res == NULL) {
+        return -EBUSY;
+    }
+
+    midireg_mem = ioremap((MIDIREG_BASE + MIDIREG_OFFSET), MIDIREG_SIZE);
+    if (midireg_mem == NULL) {
+        release_mem_region(MIDIREG_BASE, MIDIREG_SIZE);
+        return -EFAULT;
+    }
+
+    return 0;
+}
+
+static unsigned int i2c_mux_gpio;
+
+static int de10soc_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+//    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct device *dev = rtd->card->dev;
+    unsigned int mclk_freq;
+//    int ret;
+
+    if ((params_rate(params) % 44100) == 0) {
+        mclk_freq = MCLK_RATE_44K;
+    } else if ((params_rate(params) % 48000) == 0) {
+        mclk_freq = MCLK_RATE_48K;
+    } else
+        return -EINVAL;
+
+    /* set codec mclk configuration */
+//     ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+//         mclk_freq, SND_SOC_CLOCK_OUT);
+//     if (ret < 0)
+//         return ret;
+
+    dev_dbg(dev, "hw_params: mclk_freq=%d\n", mclk_freq);
+    return 0;
+}
+
+// static void de10soc_shutdown(struct snd_pcm_substream *substream)
+// {
+//     struct snd_soc_pcm_runtime *rtd = substream->private_data;
+//     struct snd_soc_dai *codec_dai = rtd->codec_dai;
+//     struct device *dev = rtd->card->dev;
+//     int ret;
+//
+//     dev_dbg(dev, "shutdown\n");
+//     ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+//         0, SND_SOC_CLOCK_OUT);
+//     if (ret < 0) {
+//         dev_err(dev, "Failed to reset WM8731 SYSCLK: %d\n", ret);
+//     }
+// }
+
+static struct snd_soc_ops de10soc_ops = {
+    // .startup
+//    .shutdown = de10soc_shutdown,
+    .hw_params = de10soc_hw_params,
+    // .hw_free
+    // .prepare
+    // .trigger
+};
+
+static const struct snd_soc_dapm_widget de10soc_dapm_widgets[] = {
+    SND_SOC_DAPM_LINE("Line Out", NULL),
+    SND_SOC_DAPM_LINE("Hsynth in", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+    {"Line Out", NULL, "PCMOUT"},
+    {"HSYNTH", NULL, "Hsynth in"},
+};
+
+static int de10soc_hsynthpcm5102_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct device *dev = rtd->card->dev;
+    unsigned int fmt;
+    int ret;
+
+    dev_dbg(dev, "init\n");
+
+    fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+        SND_SOC_DAIFMT_CBS_CFS;
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+    if (ret < 0)
+        return ret;
+
+    /* Don't let codec constraints interfere */
+//     ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_MCLK,
+//         0, SND_SOC_CLOCK_OUT);
+//     if (ret < 0) {
+//         dev_err(dev, "Failed to set WM8731 SYSCLK: %d\n", ret);
+//         return ret;
+//     }
+
+    return 0;
+}
+
+// static int soc_hsynth_init(struct snd_soc_pcm_runtime *rtd)
+// {
+//     struct snd_soc_dai *codec_dai = rtd->codec_dai;
+//     struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+//     struct device *dev = rtd->card->dev;
+//     unsigned int fmt;
+//     int ret;
+//
+//     dev_dbg(dev, "init\n");
+//
+//     fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+//     SND_SOC_DAIFMT_CBS_CFS;
+//
+//     /* set cpu DAI configuration */
+//     ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+//     if (ret < 0)
+//         return ret;
+//
+//     /* set codec DAI configuration */
+//     ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+//     if (ret < 0)
+//         return ret;
+//
+//     return 0;
+// }
+
+static struct snd_soc_dai_link de10soc_dai = {
+//	{ /* Primary DAI i/f */
+    .name = "SSND0",
+    .stream_name = "HSYNTH PCM5102",
+    .cpu_dai_name = "ff200000.i2s",
+    .codec_dai_name = "hsynthpcm5102-hifi",
+    .init = de10soc_hsynthpcm5102_init,
+    .platform_name = "de10soc",
+    .codec_name = "hsynthpcm5102.hsynth",
+    .ops = &de10soc_ops,
+// 	}, { /* Sec_Fifo Playback i/f */
+//     .name = "SSND1",
+//     .stream_name = "HSYNTH PCM",
+//     .cpu_dai_name = "ff200000.dmalink",
+//     .codec_dai_name = "hsynth7002-hifi",
+//     .init = soc_hsynth_init,
+//     .platform_name = "de10soc",
+//     .codec_name = "hsynth7002.hsynth",
+//	},
+};
+
+static struct snd_soc_card snd_soc_de10soc = {
+    .name = "DE10SND",
+    .owner = THIS_MODULE,
+    .dai_link = &de10soc_dai,
+//    .num_links = ARRAY_SIZE(de10soc_dai),
+    .num_links = 1,
+
+    .probe        = hmidi_card_probe,
+    .remove       = hmidi_card_remove,
+
+    .dapm_widgets = de10soc_dapm_widgets,
+    .num_dapm_widgets = ARRAY_SIZE(de10soc_dapm_widgets),
+    .dapm_routes = intercon,
+    .num_dapm_routes = ARRAY_SIZE(intercon),
+};
+
+static int de10soc_audio_probe(struct platform_device *pdev)
+{
+    struct device_node *np = pdev->dev.of_node;
+    struct device_node *codec_np, *cpu_np;
+    struct snd_soc_card *card = &snd_soc_de10soc;
+    int ret;
+
+    if (!np) {
+        return -ENODEV;
+    }
+
+    card->dev = &pdev->dev;
+
+    /* I2C bus is muxed between HPS and FPGA. Set mux to HPS */
+//     i2c_mux_gpio = of_get_named_gpio(np, "i2c-mux-gpio", 0);
+//     if (gpio_is_valid(i2c_mux_gpio)) {
+//         ret = devm_gpio_request_one(&pdev->dev,
+//             i2c_mux_gpio, GPIOF_OUT_INIT_LOW, "I2C_MUX");
+//         if (ret) {
+//             dev_err(&pdev->dev,
+//                 "Failed to request GPIO_%d for i2c_mux: %d\n",
+//                 i2c_mux_gpio, ret);
+//             return ret;
+//         }
+//         gpio_set_value(i2c_mux_gpio, 1);
+//     }
+
+    /* Parse codec1 info */
+    de10soc_dai.codec_name = NULL;
+    codec_np = of_parse_phandle(np, "audio-codec", 0);
+    if (!codec_np) {
+        dev_err(&pdev->dev, "audio-codec info missing\n");
+        return -EINVAL;
+    }
+    de10soc_dai.codec_of_node = codec_np;
+
+    /* Parse dai and platform info */
+    de10soc_dai.cpu_dai_name = NULL;
+    de10soc_dai.platform_name = NULL;
+    cpu_np = of_parse_phandle(np, "i2s-controller", 0);
+    if (!cpu_np) {
+        dev_err(&pdev->dev, "i2s dai1 and pcm info missing\n");
+        return -EINVAL;
+    }
+
+    de10soc_dai.cpu_of_node = cpu_np;
+    de10soc_dai.platform_of_node = cpu_np;
+
+    of_node_put(codec_np);
+    of_node_put(cpu_np);
+
+    /* Parse codec2 info */
+//     de10soc_dai[1].codec_name = NULL;
+//     codec_np = of_parse_phandle(np, "synth-codec", 0);
+//     if (!codec_np) {
+//         dev_err(&pdev->dev, "synth-codec info missing\n");
+//         return -EINVAL;
+//     }
+//     de10soc_dai[1].codec_of_node = codec_np;
+//
+//     /* Parse dai and platform info */
+//     de10soc_dai[1].cpu_dai_name = NULL;
+//     de10soc_dai[1].platform_name = NULL;
+//     cpu_np = of_parse_phandle(np, "dmalink-controller", 0);
+//     if (!cpu_np) {
+//         dev_err(&pdev->dev, "dmalink-controller info missing\n");
+//         return -EINVAL;
+//     }
+//
+//     de10soc_dai[1].cpu_of_node = cpu_np;
+//     de10soc_dai[1].platform_of_node = cpu_np;
+//
+//     of_node_put(codec_np);
+//     of_node_put(cpu_np);
+//
+
+    ret = snd_soc_register_card(card);
+    if (ret) {
+        dev_err(&pdev->dev, "snd_soc_register_card() failed\n");
+    }
+
+    return ret;
+}
+
+static int de10soc_audio_remove(struct platform_device *pdev)
+{
+    struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+    if (gpio_is_valid(i2c_mux_gpio))
+        devm_gpio_free(&pdev->dev, i2c_mux_gpio);
+
+    snd_soc_unregister_card(card);
+
+    return 0;
+}
+
+static const struct of_device_id de10soc_hsynthpcm5102_dt_ids[] = {
+    { .compatible = "opencores,de10soc-hsynthpcm5102-audio-midi", },
+    { }
+};
+MODULE_DEVICE_TABLE(of, de10soc_hsynthpcm5102_dt_ids);
+
+static struct platform_driver de10soc_audio_driver = {
+    .driver = {
+        .name	= "de10soc-audio",
+        .owner	= THIS_MODULE,
+        .of_match_table = of_match_ptr(de10soc_hsynthpcm5102_dt_ids),
+    },
+    .probe	= de10soc_audio_probe,
+    .remove	= de10soc_audio_remove,
+};
+
+module_platform_driver(de10soc_audio_driver);
+
+/* Module information */
+MODULE_AUTHOR("Bjarne Steinsbo <bsteinsbo@gmail.com>");
+MODULE_DESCRIPTION("ALSA SoC DE10-SoC_PWM5102");
+MODULE_LICENSE("GPL");
-- 
2.7.4


From cb03fe3053149c122bc01ab2c6786325edb005cf Mon Sep 17 00:00:00 2001
From: Michael Brown <producer@holotronic.dk>
Date: Fri, 18 May 2018 20:35:35 +0200
Subject: [PATCH 16/16] Add framebuffer-ii core driver based on Mister, and
 enable it

Signed-off-by: Michael Brown <producer@holotronic.dk>
---
 arch/arm/configs/socfpga_defconfig |   1 +
 drivers/video/fbdev/Kconfig        |  48 +++--
 drivers/video/fbdev/Makefile       |   1 +
 drivers/video/fbdev/altvipfb.c     | 420 ++++++++++++++++++-------------------
 drivers/video/fbdev/altvipfbii.c   | 260 +++++++++++++++++++++++
 5 files changed, 501 insertions(+), 229 deletions(-)
 create mode 100644 drivers/video/fbdev/altvipfbii.c

diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index c74d6ea..8febed5 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -117,6 +117,7 @@ CONFIG_REGULATOR=y
 CONFIG_REGULATOR_FIXED_VOLTAGE=y
 CONFIG_FB=y
 CONFIG_FB_ALTERA_VIP=y
+CONFIG_FB_ALTERA_VIP_II=y
 CONFIG_FB_ALTERA_VIP_FB2_PLAT=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index cf29ed5..d306017 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -238,6 +238,16 @@ config FB_ALTERA_VIP
 	  This driver supports the Altera Video and Image Processing(VIP)
 	  Frame Reader
 
+config FB_ALTERA_VIP_II
+	tristate "Altera VIP II Framebuffer support"
+	depends on FB
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This driver supports the Altera Video and Image Processing(VIP)
+	  Framebuffer II
+
 config FB_ALTERA_VIP_FB2
     tristate "Altera VIP Frame Buffer II framebuffer support"
 	depends on FB
@@ -725,7 +735,7 @@ config FB_STI
 	  BIOS routines contained in a ROM chip in HP PA-RISC based machines.
 	  Enabling this option will implement the linux framebuffer device
 	  using calls to the STI BIOS routines for initialisation.
-	
+
 	  If you enable this option, you will get a planar framebuffer device
 	  /dev/fb which will work on the most common HP graphic cards of the
 	  NGLE family, including the artist chips (in the 7xx and Bxxx series),
@@ -1159,36 +1169,36 @@ config FB_I810
 	select FB_CFB_IMAGEBLIT
 	select VGASTATE
 	help
-	  This driver supports the on-board graphics built in to the Intel 810 
+	  This driver supports the on-board graphics built in to the Intel 810
           and 815 chipsets.  Say Y if you have and plan to use such a board.
 
           To compile this driver as a module, choose M here: the
 	  module will be called i810fb.
 
-          For more information, please read 
+          For more information, please read
 	  <file:Documentation/fb/intel810.txt>
 
 config FB_I810_GTF
 	bool "use VESA Generalized Timing Formula"
 	depends on FB_I810
 	help
-	  If you say Y, then the VESA standard, Generalized Timing Formula 
+	  If you say Y, then the VESA standard, Generalized Timing Formula
           or GTF, will be used to calculate the required video timing values
-	  per video mode.  Since the GTF allows nondiscrete timings 
+	  per video mode.  Since the GTF allows nondiscrete timings
           (nondiscrete being a range of values as opposed to discrete being a
-          set of values), you'll be able to use any combination of horizontal 
+          set of values), you'll be able to use any combination of horizontal
 	  and vertical resolutions, and vertical refresh rates without having
 	  to specify your own timing parameters.  This is especially useful
-	  to maximize the performance of an aging display, or if you just 
-          have a display with nonstandard dimensions. A VESA compliant 
+	  to maximize the performance of an aging display, or if you just
+          have a display with nonstandard dimensions. A VESA compliant
 	  monitor is recommended, but can still work with non-compliant ones.
-	  If you need or want this, then select this option. The timings may 
-	  not be compliant with Intel's recommended values. Use at your own 
+	  If you need or want this, then select this option. The timings may
+	  not be compliant with Intel's recommended values. Use at your own
 	  risk.
 
-          If you say N, the driver will revert to discrete video timings 
+          If you say N, the driver will revert to discrete video timings
 	  using a set recommended by Intel in their documentation.
-  
+
           If unsure, say N.
 
 config FB_I810_I2C
@@ -1306,10 +1316,10 @@ config FB_MATROX_G
 	  G450/G550 secondary head and digital output are supported without
 	  additional modules.
 
-	  The driver starts in monitor mode. You must use the matroxset tool 
-	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to 
-	  swap primary and secondary head outputs, or to change output mode.  
-	  Secondary head driver always start in 640x480 resolution and you 
+	  The driver starts in monitor mode. You must use the matroxset tool
+	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to
+	  swap primary and secondary head outputs, or to change output mode.
+	  Secondary head driver always start in 640x480 resolution and you
 	  must use fbset to change it.
 
 	  Do not forget that second head supports only 16 and 32 bpp
@@ -1392,7 +1402,7 @@ config FB_RADEON_I2C
 	select FB_DDC
 	default y
 	help
-	  Say Y here if you want DDC/I2C support for your Radeon board. 
+	  Say Y here if you want DDC/I2C support for your Radeon board.
 
 config FB_RADEON_BACKLIGHT
 	bool "Support for backlight control"
@@ -1625,7 +1635,7 @@ config FB_NEOMAGIC
 	select VGASTATE
 	help
 	  This driver supports notebooks with NeoMagic PCI chips.
-	  Say Y if you have such a graphics card. 
+	  Say Y if you have such a graphics card.
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called neofb.
@@ -1680,7 +1690,7 @@ config FB_VOODOO1
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
 	---help---
-	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or 
+	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or
 	  Voodoo2 (cvg) based graphics card.
 
 	  To compile this driver as a module, choose M here: the
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index bb8f9d0..5951a8f 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_FB_WMT_GE_ROPS)   += wmt_ge_rops.o
 
 # Hardware specific drivers go first
 obj-$(CONFIG_FB_ALTERA_VIP)	  += altvipfb.o
+obj-$(CONFIG_FB_ALTERA_VIP_II)	  += altvipfbii.o
 obj-$(CONFIG_FB_ALTERA_VIP_FB2) += altvipfb2.o
 obj-$(CONFIG_FB_ALTERA_VIP_FB2_PLAT) += altvipfb2_drv.o
 altvipfb2_drv-objs := altvipfb2-plat.o altvipfb2.o
diff --git a/drivers/video/fbdev/altvipfb.c b/drivers/video/fbdev/altvipfb.c
index b247858..4724a0e 100644
--- a/drivers/video/fbdev/altvipfb.c
+++ b/drivers/video/fbdev/altvipfb.c
@@ -41,260 +41,260 @@
 struct altvipfb_type;
 
 struct altvipfb_dev {
-	struct platform_device *pdev;
-	struct fb_info info;
-	struct resource *reg_res;
-	void __iomem *base;
-	int mem_word_width;
-	u32 pseudo_palette[PALETTE_SIZE];
+    struct platform_device *pdev;
+    struct fb_info info;
+    struct resource *reg_res;
+    void __iomem *base;
+    int mem_word_width;
+    u32 pseudo_palette[PALETTE_SIZE];
 };
 
 static int altvipfb_setcolreg(unsigned regno, unsigned red, unsigned green,
-			   unsigned blue, unsigned transp, struct fb_info *info)
+                              unsigned blue, unsigned transp, struct fb_info *info)
 {
-	/*
-	 *  Set a single color register. The values supplied have a 32 bit
-	 *  magnitude.
-	 *  Return != 0 for invalid regno.
-	 */
+    /*
+     *  Set a single color register. The values supplied have a 32 bit
+     *  magnitude.
+     *  Return != 0 for invalid regno.
+     */
 
-	if (regno > 255)
-		return 1;
+    if (regno > 255)
+        return 1;
 
-	red >>= 8;
-	green >>= 8;
-	blue >>= 8;
+    red >>= 8;
+    green >>= 8;
+    blue >>= 8;
 
-	if (regno < 255) {
-		((u32 *)info->pseudo_palette)[regno] =
-		((red & 255) << 16) | ((green & 255) << 8) | (blue & 255);
-	}
+    if (regno < 255) {
+        ((u32 *)info->pseudo_palette)[regno] =
+        ((red & 255) << 16) | ((green & 255) << 8) | (blue & 255);
+    }
 
-	return 0;
+    return 0;
 }
 
 static struct fb_ops altvipfb_ops = {
-	.owner = THIS_MODULE,
-	.fb_fillrect = cfb_fillrect,
-	.fb_copyarea = cfb_copyarea,
-	.fb_imageblit = cfb_imageblit,
-	.fb_setcolreg = altvipfb_setcolreg,
+    .owner = THIS_MODULE,
+    .fb_fillrect = cfb_fillrect,
+    .fb_copyarea = cfb_copyarea,
+    .fb_imageblit = cfb_imageblit,
+    .fb_setcolreg = altvipfb_setcolreg,
 };
 
 static int altvipfb_of_setup(struct altvipfb_dev *fbdev)
 {
-	struct device_node *np = fbdev->pdev->dev.of_node;
-	int ret;
-	u32 bits_per_color;
-
-	ret = of_property_read_u32(np, "max-width", &fbdev->info.var.xres);
-	if (ret) {
-		dev_err(&fbdev->pdev->dev,
-			"Missing required parameter 'max-width'");
-		return ret;
-	}
-	fbdev->info.var.xres_virtual = fbdev->info.var.xres,
-
-	ret = of_property_read_u32(np, "max-height", &fbdev->info.var.yres);
-	if (ret) {
-		dev_err(&fbdev->pdev->dev,
-			"Missing required parameter 'max-height'");
-		return ret;
-	}
-	fbdev->info.var.yres_virtual = fbdev->info.var.yres;
-
-	ret = of_property_read_u32(np, "bits-per-color", &bits_per_color);
-	if (ret) {
-		dev_err(&fbdev->pdev->dev,
-			"Missing required parameter 'bits-per-color'");
-		return ret;
-	}
-	if (bits_per_color != 8) {
-		dev_err(&fbdev->pdev->dev,
-			"bits-per-color is set to %i.  Curently only 8 is supported.",
-			bits_per_color);
-		return -ENODEV;
-	}
-	fbdev->info.var.bits_per_pixel = 32;
-
-	ret = of_property_read_u32(np, "mem-word-width",
-				   &fbdev->mem_word_width);
-	if (ret) {
-		dev_err(&fbdev->pdev->dev,
-			"Missing required parameter 'mem-word-width'");
-		return ret;
-	}
-	if (!(fbdev->mem_word_width >= 32 && fbdev->mem_word_width % 32 == 0)) {
-		dev_err(&fbdev->pdev->dev,
-			"mem-word-width is set to %i.  must be >= 32 and multiple of 32.",
-			fbdev->mem_word_width);
-		return -ENODEV;
-	}
-
-	return 0;
+    struct device_node *np = fbdev->pdev->dev.of_node;
+    int ret;
+    u32 bits_per_color;
+
+    ret = of_property_read_u32(np, "max-width", &fbdev->info.var.xres);
+    if (ret) {
+        dev_err(&fbdev->pdev->dev,
+                "Missing required parameter 'max-width'");
+        return ret;
+    }
+    fbdev->info.var.xres_virtual = fbdev->info.var.xres,
+
+    ret = of_property_read_u32(np, "max-height", &fbdev->info.var.yres);
+    if (ret) {
+        dev_err(&fbdev->pdev->dev,
+                "Missing required parameter 'max-height'");
+        return ret;
+    }
+    fbdev->info.var.yres_virtual = fbdev->info.var.yres;
+
+    ret = of_property_read_u32(np, "bits-per-color", &bits_per_color);
+    if (ret) {
+        dev_err(&fbdev->pdev->dev,
+                "Missing required parameter 'bits-per-color'");
+        return ret;
+    }
+    if (bits_per_color != 8) {
+        dev_err(&fbdev->pdev->dev,
+                "bits-per-color is set to %i.  Curently only 8 is supported.",
+                bits_per_color);
+        return -ENODEV;
+    }
+    fbdev->info.var.bits_per_pixel = 32;
+
+    ret = of_property_read_u32(np, "mem-word-width",
+                               &fbdev->mem_word_width);
+    if (ret) {
+        dev_err(&fbdev->pdev->dev,
+                "Missing required parameter 'mem-word-width'");
+        return ret;
+    }
+    if (!(fbdev->mem_word_width >= 32 && fbdev->mem_word_width % 32 == 0)) {
+        dev_err(&fbdev->pdev->dev,
+                "mem-word-width is set to %i.  must be >= 32 and multiple of 32.",
+                fbdev->mem_word_width);
+        return -ENODEV;
+    }
+
+    return 0;
 }
 
 static void altvipfb_start_hw(struct altvipfb_dev *fbdev)
 {
-	writel(fbdev->info.fix.smem_start, fbdev->base +
-	       ALTVIPFB_FRAME0_BASE_ADDRESS);
-	writel(fbdev->info.var.xres * fbdev->info.var.yres /
-	       (fbdev->mem_word_width/32),
-	       fbdev->base + ALTVIPFB_FRAME0_NUM_WORDS);
-	writel(fbdev->info.var.xres * fbdev->info.var.yres,
-	       fbdev->base + ALTVIPFB_FRAME0_SAMPLES);
-	writel(fbdev->info.var.xres, fbdev->base + ALTVIPFB_FRAME0_WIDTH);
-	writel(fbdev->info.var.yres, fbdev->base + ALTVIPFB_FRAME0_HEIGHT);
-	writel(3, fbdev->base + ALTVIPFB_FRAME0_INTERLACED);
-	writel(0, fbdev->base + ALTVIPFB_FRAME_SELECT);
-
-	/* Finally set the control register to 1 to start streaming */
-	writel(1, fbdev->base + ALTVIPFB_CONTROL);
+    writel(fbdev->info.fix.smem_start, fbdev->base +
+    ALTVIPFB_FRAME0_BASE_ADDRESS);
+    writel(fbdev->info.var.xres * fbdev->info.var.yres /
+    (fbdev->mem_word_width/32),
+           fbdev->base + ALTVIPFB_FRAME0_NUM_WORDS);
+    writel(fbdev->info.var.xres * fbdev->info.var.yres,
+           fbdev->base + ALTVIPFB_FRAME0_SAMPLES);
+    writel(fbdev->info.var.xres, fbdev->base + ALTVIPFB_FRAME0_WIDTH);
+    writel(fbdev->info.var.yres, fbdev->base + ALTVIPFB_FRAME0_HEIGHT);
+    writel(3, fbdev->base + ALTVIPFB_FRAME0_INTERLACED);
+    writel(0, fbdev->base + ALTVIPFB_FRAME_SELECT);
+
+    /* Finally set the control register to 1 to start streaming */
+    writel(1, fbdev->base + ALTVIPFB_CONTROL);
 }
 
 static void altvipfb_disable_hw(struct altvipfb_dev *fbdev)
 {
-	/* set the control register to 0 to stop streaming */
-	writel(0, fbdev->base + ALTVIPFB_CONTROL);
+    /* set the control register to 0 to stop streaming */
+    writel(0, fbdev->base + ALTVIPFB_CONTROL);
 }
 
 
 static int altvipfb_setup_fb_info(struct altvipfb_dev *fbdev)
 {
-	struct fb_info *info = &fbdev->info;
-	int ret;
-
-	strcpy(info->fix.id, DRIVER_NAME);
-	info->fix.type = FB_TYPE_PACKED_PIXELS;
-	info->fix.visual = FB_VISUAL_TRUECOLOR;
-	info->fix.accel = FB_ACCEL_NONE;
-
-	info->fbops = &altvipfb_ops;
-	info->var.activate = FB_ACTIVATE_NOW;
-	info->var.height = -1;
-	info->var.width = -1;
-	info->var.vmode = FB_VMODE_NONINTERLACED;
-
-	ret = altvipfb_of_setup(fbdev);
-	if (ret)
-		return ret;
-
-	/* settings for 32bit pixels */
-	info->var.red.offset = 16;
-	info->var.red.length = 8;
-	info->var.red.msb_right = 0;
-	info->var.green.offset = 8;
-	info->var.green.length = 8;
-	info->var.green.msb_right = 0;
-	info->var.blue.offset = 0;
-	info->var.blue.length = 8;
-	info->var.blue.msb_right = 0;
-
-	info->fix.line_length = (info->var.xres *
-		(info->var.bits_per_pixel >> 3));
-	info->fix.smem_len = info->fix.line_length * info->var.yres;
-
-	info->pseudo_palette = fbdev->pseudo_palette;
-	info->flags = FBINFO_FLAG_DEFAULT;
-
-	return 0;
+    struct fb_info *info = &fbdev->info;
+    int ret;
+
+    strcpy(info->fix.id, DRIVER_NAME);
+    info->fix.type = FB_TYPE_PACKED_PIXELS;
+    info->fix.visual = FB_VISUAL_TRUECOLOR;
+    info->fix.accel = FB_ACCEL_NONE;
+
+    info->fbops = &altvipfb_ops;
+    info->var.activate = FB_ACTIVATE_NOW;
+    info->var.height = -1;
+    info->var.width = -1;
+    info->var.vmode = FB_VMODE_NONINTERLACED;
+
+    ret = altvipfb_of_setup(fbdev);
+    if (ret)
+        return ret;
+
+    /* settings for 32bit pixels */
+    info->var.red.offset = 16;
+    info->var.red.length = 8;
+    info->var.red.msb_right = 0;
+    info->var.green.offset = 8;
+    info->var.green.length = 8;
+    info->var.green.msb_right = 0;
+    info->var.blue.offset = 0;
+    info->var.blue.length = 8;
+    info->var.blue.msb_right = 0;
+
+    info->fix.line_length = (info->var.xres *
+    (info->var.bits_per_pixel >> 3));
+    info->fix.smem_len = info->fix.line_length * info->var.yres;
+
+    info->pseudo_palette = fbdev->pseudo_palette;
+    info->flags = FBINFO_FLAG_DEFAULT;
+
+    return 0;
 }
 
 static int altvipfb_probe(struct platform_device *pdev)
 {
-	int retval;
-	void *fbmem_virt;
-	struct altvipfb_dev *fbdev;
-
-	fbdev = devm_kzalloc(&pdev->dev, sizeof(*fbdev), GFP_KERNEL);
-	if (!fbdev)
-		return -ENOMEM;
-
-	fbdev->pdev = pdev;
-	fbdev->reg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!fbdev->reg_res)
-		return -ENODEV;
-
-	retval = altvipfb_setup_fb_info(fbdev);
-
-	fbmem_virt = dma_alloc_coherent(NULL,
-					fbdev->info.fix.smem_len,
-					(void *)&(fbdev->info.fix.smem_start),
-					GFP_KERNEL);
-	if (!fbmem_virt) {
-		dev_err(&pdev->dev,
-			"altvipfb: unable to allocate %d Bytes fb memory\n",
-			fbdev->info.fix.smem_len);
-		return retval;
-	}
-
-	fbdev->info.screen_base = fbmem_virt;
-
-	retval = fb_alloc_cmap(&fbdev->info.cmap, PALETTE_SIZE, 0);
-	if (retval < 0)
-		goto err_dma_free;
-
-	platform_set_drvdata(pdev, fbdev);
-
-	fbdev->base = devm_ioremap_resource(&pdev->dev, fbdev->reg_res);
-	if (IS_ERR(fbdev->base)) {
-		dev_err(&pdev->dev, "devm_ioremap_resource failed\n");
-		retval = PTR_ERR(fbdev->base);
-		goto err_dealloc_cmap;
-	}
-
-	altvipfb_start_hw(fbdev);
-
-	retval = register_framebuffer(&fbdev->info);
-	if (retval < 0)
-		goto err_dealloc_cmap;
-
-	dev_info(&pdev->dev, "fb%d: %s frame buffer device at 0x%x+0x%x\n",
-		 fbdev->info.node, fbdev->info.fix.id,
-		 (unsigned)fbdev->info.fix.smem_start,
-		 fbdev->info.fix.smem_len);
-
-	return 0;
-
-err_dealloc_cmap:
-	fb_dealloc_cmap(&fbdev->info.cmap);
-err_dma_free:
-	dma_free_coherent(NULL, fbdev->info.fix.smem_len, fbmem_virt,
-			  fbdev->info.fix.smem_start);
-	return retval;
+    int retval;
+    void *fbmem_virt;
+    struct altvipfb_dev *fbdev;
+
+    fbdev = devm_kzalloc(&pdev->dev, sizeof(*fbdev), GFP_KERNEL);
+    if (!fbdev)
+        return -ENOMEM;
+
+    fbdev->pdev = pdev;
+    fbdev->reg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!fbdev->reg_res)
+        return -ENODEV;
+
+    retval = altvipfb_setup_fb_info(fbdev);
+
+    fbmem_virt = dma_alloc_coherent(NULL,
+                                    fbdev->info.fix.smem_len,
+                                    (void *)&(fbdev->info.fix.smem_start),
+                                    GFP_KERNEL);
+    if (!fbmem_virt) {
+        dev_err(&pdev->dev,
+                "altvipfb: unable to allocate %d Bytes fb memory\n",
+                fbdev->info.fix.smem_len);
+        return retval;
+    }
+
+    fbdev->info.screen_base = fbmem_virt;
+
+    retval = fb_alloc_cmap(&fbdev->info.cmap, PALETTE_SIZE, 0);
+    if (retval < 0)
+        goto err_dma_free;
+
+    platform_set_drvdata(pdev, fbdev);
+
+    fbdev->base = devm_ioremap_resource(&pdev->dev, fbdev->reg_res);
+    if (IS_ERR(fbdev->base)) {
+        dev_err(&pdev->dev, "devm_ioremap_resource failed\n");
+        retval = PTR_ERR(fbdev->base);
+        goto err_dealloc_cmap;
+    }
+
+    altvipfb_start_hw(fbdev);
+
+    retval = register_framebuffer(&fbdev->info);
+    if (retval < 0)
+        goto err_dealloc_cmap;
+
+    dev_info(&pdev->dev, "fb%d: %s frame buffer device at 0x%x+0x%x\n",
+             fbdev->info.node, fbdev->info.fix.id,
+             (unsigned)fbdev->info.fix.smem_start,
+             fbdev->info.fix.smem_len);
+
+    return 0;
+
+    err_dealloc_cmap:
+    fb_dealloc_cmap(&fbdev->info.cmap);
+    err_dma_free:
+    dma_free_coherent(NULL, fbdev->info.fix.smem_len, fbmem_virt,
+                      fbdev->info.fix.smem_start);
+    return retval;
 }
 
 static int altvipfb_remove(struct platform_device *dev)
 {
-	struct altvipfb_dev *fbdev = platform_get_drvdata(dev);
-
-	if (fbdev) {
-		unregister_framebuffer(&fbdev->info);
-		fb_dealloc_cmap(&fbdev->info.cmap);
-		dma_free_coherent(NULL, fbdev->info.fix.smem_len,
-				  fbdev->info.screen_base,
-				  fbdev->info.fix.smem_start);
-		altvipfb_disable_hw(fbdev);
-	}
-	return 0;
+    struct altvipfb_dev *fbdev = platform_get_drvdata(dev);
+
+    if (fbdev) {
+        unregister_framebuffer(&fbdev->info);
+        fb_dealloc_cmap(&fbdev->info.cmap);
+        dma_free_coherent(NULL, fbdev->info.fix.smem_len,
+                          fbdev->info.screen_base,
+                          fbdev->info.fix.smem_start);
+        altvipfb_disable_hw(fbdev);
+    }
+    return 0;
 }
 
 
 static struct of_device_id altvipfb_match[] = {
-	{ .compatible = "altr,vip-frame-reader-1.0" },
-	{ .compatible = "altr,vip-frame-reader-9.1" },
-	{},
+    { .compatible = "altr,vip-frame-reader-1.0" },
+    { .compatible = "altr,vip-frame-reader-9.1" },
+    {},
 };
 MODULE_DEVICE_TABLE(of, altvipfb_match);
 
 static struct platform_driver altvipfb_driver = {
-	.probe = altvipfb_probe,
-	.remove = altvipfb_remove,
-	.driver = {
-		.owner = THIS_MODULE,
-		.name = DRIVER_NAME,
-		.of_match_table = altvipfb_match,
-	},
+    .probe = altvipfb_probe,
+    .remove = altvipfb_remove,
+    .driver = {
+        .owner = THIS_MODULE,
+        .name = DRIVER_NAME,
+        .of_match_table = altvipfb_match,
+    },
 };
 module_platform_driver(altvipfb_driver);
 
diff --git a/drivers/video/fbdev/altvipfbii.c b/drivers/video/fbdev/altvipfbii.c
new file mode 100644
index 0000000..a80ae1a
--- /dev/null
+++ b/drivers/video/fbdev/altvipfbii.c
@@ -0,0 +1,260 @@
+/*
+ *  altvipfb.c -- Altera Video and Image Processing(VIP) Frame Reader driver
+ *
+ *  This is based on a driver made by Thomas Chou <thomas@wytron.com.tw> and
+ *  Walter Goossens <waltergoossens@home.nl> This driver supports the Altera VIP
+ *  Frame Reader component.  More info on the hardware can be found in
+ *  the Altera Video and Image Processing Suite User Guide at this address
+ *  http://www.altera.com/literature/ug/ug_vip.pdf.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#define PALETTE_SIZE	256
+#define DRIVER_NAME	"altvipfbii"
+
+/* control registers */
+#define ALTVIPFB_CONTROL		0
+#define ALTVIPFB_FRAMEINFO		20
+#define ALTVIPFB_FRAMEADDR		24
+
+struct altvipfb_type;
+
+struct altvipfb_dev {
+    struct platform_device *pdev;
+    struct fb_info info;
+    struct resource *reg_res;
+    void __iomem *base;
+    u32 pseudo_palette[PALETTE_SIZE];
+};
+
+static int altvipfb_setcolreg(unsigned regno, unsigned red, unsigned green,
+                              unsigned blue, unsigned transp, struct fb_info *info)
+{
+    /*
+     *  Set a single color register. The values supplied have a 32 bit
+     *  magnitude.
+     *  Return != 0 for invalid regno.
+     */
+
+    if (regno > 255)
+        return 1;
+
+    red >>= 8;
+    green >>= 8;
+    blue >>= 8;
+
+    if (regno < 255) {
+        ((u32 *)info->pseudo_palette)[regno] =
+        ((red & 255) << 16) | ((green & 255) << 8) | (blue & 255);
+    }
+
+    return 0;
+}
+
+static struct fb_ops altvipfb_ops = {
+    .owner = THIS_MODULE,
+    .fb_fillrect = cfb_fillrect,
+    .fb_copyarea = cfb_copyarea,
+    .fb_imageblit = cfb_imageblit,
+    .fb_setcolreg = altvipfb_setcolreg,
+};
+
+static void altvipfb_start_hw(struct altvipfb_dev *fbdev)
+{
+    writel(1, fbdev->base + ALTVIPFB_CONTROL);
+    writel((fbdev->info.var.xres & 0xFFF) | ((fbdev->info.var.yres & 0xFFF) << 13), fbdev->base + ALTVIPFB_FRAMEINFO);
+    writel(fbdev->info.fix.smem_start, fbdev->base + ALTVIPFB_FRAMEADDR);
+}
+
+static void altvipfb_disable_hw(struct altvipfb_dev *fbdev)
+{
+    /* set the control register to 0 to stop streaming */
+    writel(0, fbdev->base + ALTVIPFB_CONTROL);
+}
+
+static int altvipfb_setup_fb_info(struct altvipfb_dev *fbdev)
+{
+    struct fb_info *info = &fbdev->info;
+    struct device_node *np = fbdev->pdev->dev.of_node;
+
+    int ret;
+
+    //     u32 width = readl(fbdev->base + 0x80);
+    //     u32 height = readl(fbdev->base + 0x88);
+    //     info->var.xres = (((width>>12)&0xf)*1000) + (((width>>8)&0xf)*100) + (((width>>4)&0xf)*10) + (width&0xf);
+    //     info->var.yres = (((height>>12)&0xf)*1000) + (((height>>8)&0xf)*100) + (((height>>4)&0xf)*10) + (height&0xf);
+
+    ret = of_property_read_u32(np, "max-width", &fbdev->info.var.xres);
+    if (ret) {
+        dev_err(&fbdev->pdev->dev,
+                "Missing required parameter 'max-width'");
+        return ret;
+    }
+
+    ret = of_property_read_u32(np, "max-height", &fbdev->info.var.yres);
+    if (ret) {
+        dev_err(&fbdev->pdev->dev,
+                "Missing required parameter 'max-height'");
+        return ret;
+    }
+
+    strcpy(info->fix.id, DRIVER_NAME);
+    info->fix.type = FB_TYPE_PACKED_PIXELS;
+    info->fix.visual = FB_VISUAL_TRUECOLOR;
+    info->fix.accel = FB_ACCEL_NONE;
+
+    info->fbops = &altvipfb_ops;
+    info->var.activate = FB_ACTIVATE_NOW;
+    info->var.height = -1;
+    info->var.width = -1;
+    info->var.vmode = FB_VMODE_NONINTERLACED;
+
+    info->var.xres_virtual = info->var.xres,
+    info->var.yres_virtual = info->var.yres;
+    info->var.bits_per_pixel = 32;
+
+    dev_info(&fbdev->pdev->dev, "FB width = %u, FB height = %u\n", info->var.xres, info->var.yres);
+
+    /* settings for 32bit pixels */
+    info->var.red.offset = 16;
+    info->var.red.length = 8;
+    info->var.red.msb_right = 0;
+    info->var.green.offset = 8;
+    info->var.green.length = 8;
+    info->var.green.msb_right = 0;
+    info->var.blue.offset = 0;
+    info->var.blue.length = 8;
+    info->var.blue.msb_right = 0;
+
+    info->fix.line_length = (info->var.xres *
+    (info->var.bits_per_pixel >> 3));
+    info->fix.smem_len = info->fix.line_length * info->var.yres;
+
+    info->pseudo_palette = fbdev->pseudo_palette;
+    info->flags = FBINFO_FLAG_DEFAULT;
+
+    return 0;
+}
+
+static int altvipfb_probe(struct platform_device *pdev)
+{
+    int retval;
+    void *fbmem_virt;
+    struct altvipfb_dev *fbdev;
+
+    fbdev = devm_kzalloc(&pdev->dev, sizeof(*fbdev), GFP_KERNEL);
+    if (!fbdev)
+        return -ENOMEM;
+
+    fbdev->pdev = pdev;
+    fbdev->reg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!fbdev->reg_res)
+        return -ENODEV;
+
+    //     fbdev->base = devm_ioremap_resource(&pdev->dev, fbdev->reg_res);
+    //     if (IS_ERR(fbdev->base)) {
+    //         dev_err(&pdev->dev, "devm_ioremap_resource failed\n");
+    //         return PTR_ERR(fbdev->base);
+    //     }
+
+    retval = altvipfb_setup_fb_info(fbdev);
+
+    fbmem_virt = dma_alloc_coherent(NULL,
+                                    fbdev->info.fix.smem_len,
+                                    (void *)&(fbdev->info.fix.smem_start),
+                                    GFP_KERNEL);
+    if (!fbmem_virt) {
+        dev_err(&pdev->dev,
+                "altvipfb: unable to allocate %d Bytes fb memory\n",
+                fbdev->info.fix.smem_len);
+        return retval;
+    }
+
+    fbdev->info.screen_base = fbmem_virt;
+
+    retval = fb_alloc_cmap(&fbdev->info.cmap, PALETTE_SIZE, 0);
+    if (retval < 0)
+        goto err_dma_free;
+
+    platform_set_drvdata(pdev, fbdev);
+
+    fbdev->base = devm_ioremap_resource(&pdev->dev, fbdev->reg_res);
+    if (IS_ERR(fbdev->base)) {
+        dev_err(&pdev->dev, "devm_ioremap_resource failed\n");
+        retval = PTR_ERR(fbdev->base);
+        goto err_dealloc_cmap;
+    }
+
+    altvipfb_start_hw(fbdev);
+
+    retval = register_framebuffer(&fbdev->info);
+    if (retval < 0)
+        goto err_dealloc_cmap;
+
+    dev_info(&pdev->dev, "fb%d: %s frame buffer device at 0x%x+0x%x\n",
+             fbdev->info.node, fbdev->info.fix.id,
+             (unsigned)fbdev->info.fix.smem_start,
+             fbdev->info.fix.smem_len);
+
+    return 0;
+
+    err_dealloc_cmap:
+    fb_dealloc_cmap(&fbdev->info.cmap);
+    err_dma_free:
+    dma_free_coherent(NULL, fbdev->info.fix.smem_len, fbmem_virt,
+                      fbdev->info.fix.smem_start);
+    return retval;
+}
+
+static int altvipfb_remove(struct platform_device *dev)
+{
+    struct altvipfb_dev *fbdev = platform_get_drvdata(dev);
+
+    if (fbdev) {
+        unregister_framebuffer(&fbdev->info);
+        fb_dealloc_cmap(&fbdev->info.cmap);
+        dma_free_coherent(NULL, fbdev->info.fix.smem_len,
+                          fbdev->info.screen_base,
+                          fbdev->info.fix.smem_start);
+        altvipfb_disable_hw(fbdev);
+    }
+    return 0;
+}
+
+
+static struct of_device_id altvipfb_match[] = {
+    { .compatible = "altr,vip-frame-buffer-ii-2.0" },
+    {},
+};
+MODULE_DEVICE_TABLE(of, altvipfb_match);
+
+static struct platform_driver altvipfb_driver = {
+    .probe = altvipfb_probe,
+    .remove = altvipfb_remove,
+    .driver = {
+        .owner = THIS_MODULE,
+        .name = DRIVER_NAME,
+        .of_match_table = altvipfb_match,
+    },
+};
+module_platform_driver(altvipfb_driver);
+
+MODULE_DESCRIPTION("Altera VIP Frame Reader framebuffer driver");
+MODULE_AUTHOR("Chris Rauer <crauer@altera.com>");
+MODULE_LICENSE("GPL v2");
-- 
2.7.4

